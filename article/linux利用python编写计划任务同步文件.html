<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>linux利用python编写计划任务同步文件</title>
    <link rel="icon" href="../static/img/favicon.png" type="image/png">
    <link rel="stylesheet" href="../static/css/styles.css"> <!-- 静态文件的链接 -->
    <!-- 引入 highlight.js 的 CSS 样式 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-dark.min.css">

</head>
<body>
    <header>
        <div class="navbar container">
            <div class="menu">
                <div class="nav-title"><a href="/index.html">各自花开</a></div>
                <ul class="nav-menu">
                    
                        <li><a href="/index.html">首页</a></li>
                        <li><a href="/categories.html">分类</a>
                        <li><a href="/tags.html">标签</a>






                        <li><a href="webnav.html">网址导航</a></li>
                        <li><a href="https://www.baidu.com" target="_blank">资源分享
                        <!-- 外部链接图标 -->
                        <img src="../static/img/分享_share.png" alt="外部链接" style="position: absolute; top: 0; right: 0; width: 12px; height: 12px;transform: translateX(100%)">
                        </a></li>
                        <li><a href="/search.html">搜索</a></li>
                    
                </ul>
            </div>
        </div>
    </header>
    <div id="app" class="container">

            
            


        <div class="main container">
                
    <div class="content article-content">
        <h3>linux利用python编写计划任务同步文件</h3>
        <div class="tag-container">
        








            
                <span>
                <img src="../static/img/标签_tag-one.png" class="img-icon">
                <a>linux</a>
            </span>
            
                <span>
                <img src="../static/img/标签_tag-one.png" class="img-icon">
                <a>python</a>
            </span>
            

        </div>
        
        <div class="container article">
            <h3>python利用rsync每隔30秒同步一次文件并记录到日志</h3>
<pre class="codehilite"><code class="language-python">import subprocess
import datetime
from apscheduler.schedulers.blocking import BlockingScheduler

def sync_files():
    # 原始路径
    source_path = &quot;/home/dev/192.168.10.114&quot;
    # 目标路径,如果是远程目录,需要配置ssh免密，否则需要输入密码
    destination_path = &quot;/tmp/&quot;

    # 获取当前时间作为日志记录时间
    timestamp = datetime.datetime.now().strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)
    log_message = f&quot;[{timestamp}] Starting file synchronization...\n&quot;

    try:
        rsync_cmd = f&quot;rsync -avz --delete {source_path} {destination_path}&quot;
        output = subprocess.check_output(rsync_cmd, shell=True, stderr=subprocess.STDOUT)
        log_message += output.decode(&quot;utf-8&quot;) + &quot;\n&quot;

        log_message += f&quot;[{timestamp}] File synchronization completed successfully.\n&quot;
    except subprocess.CalledProcessError as e:
        log_message += f&quot;[{timestamp}] File synchronization failed. Error: {e.output.decode('utf-8')}\n&quot;

    # 将日志写入文件
    with open(&quot;/tmp/log.txt&quot;, &quot;a&quot;) as log_file:
        log_file.write(log_message)

if __name__ == '__main__':
    scheduler = BlockingScheduler()
    scheduler.add_job(sync_files, 'interval', seconds=30)
    scheduler.start()
</code></pre>

<h4>代码中subprocess.check_output和supprocess.call的不同</h4>
<p><code>subprocess.call</code>和<code>subprocess.check_output</code>是Python的<code>subprocess</code>模块提供的两个函数，用于执行外部命令。它们之间的区别如下：</p>
<ol>
<li><code>subprocess.call</code>：</li>
<li>功能：<code>call</code>函数用于执行指定的命令，并等待命令执行完成后返回。</li>
<li>返回值：返回命令的执行状态，一般情况下，返回值为0表示命令执行成功，非零值表示命令执行失败。</li>
<li>
<p>输出：命令的输出将直接打印到标准输出。</p>
</li>
<li>
<p><code>subprocess.check_output</code>：</p>
</li>
<li>功能：<code>check_output</code>函数用于执行指定的命令，并等待命令执行完成后返回命令的输出结果。</li>
<li>返回值：返回命令的输出结果（字节串类型）。</li>
<li>异常：如果命令执行失败（返回值非零），则会引发<code>CalledProcessError</code>异常。</li>
</ol>
<p>因此，<code>call</code>函数适用于只需要执行命令并检查执行状态的情况，而<code>check_output</code>函数适用于需要获取命令执行的输出结果的情况。</p>
<p>需要注意的是，<code>call</code>和<code>check_output</code>函数都是同步执行的，即程序会在执行命令的过程中暂停等待，直到命令执行完成。如果需要异步执行命令，可以考虑使用<code>subprocess.Popen</code>函数。</p>
<p>下面是一个简单的示例，演示了<code>call</code>和<code>check_output</code>函数的使用：</p>
<pre class="codehilite"><code class="language-python">import subprocess

# 使用call函数执行命令
exit_code = subprocess.call(&quot;ls -l&quot;, shell=True)
print(&quot;Command executed with exit code:&quot;, exit_code)

# 使用check_output函数执行命令并获取输出结果
output = subprocess.check_output(&quot;ls -l&quot;, shell=True)
print(&quot;Command output:&quot;)
print(output.decode(&quot;utf-8&quot;))
</code></pre>

<p>在上述示例中，首先使用<code>call</code>函数执行了一个<code>ls -l</code>的命令，并将执行状态存储在<code>exit_code</code>变量中，然后打印了执行状态。接下来，使用<code>check_output</code>函数执行同样的命令，并将输出结果存储在<code>output</code>变量中，最后打印了输出结果。</p>
<p>请注意，<code>shell=True</code>参数用于在shell环境中执行命令，<code>decode("utf-8")</code>用于将输出结果从字节串转换为字符串。</p>
<h3>添加到开机自启动</h3>
<p>要将该同步脚本作为Linux系统的守护进程，并实现开机自启动，你可以使用Systemd服务来完成。Systemd是现代Linux系统的守护进程管理器，它提供了管理和控制系统服务的功能。</p>
<p>以下是具体的设置步骤：</p>
<ol>
<li>创建一个Systemd服务配置文件。</li>
</ol>
<p>在Linux系统中，Systemd服务配置文件通常存储在<code>/etc/systemd/system/</code>目录下，以<code>.service</code>为后缀。你可以选择在该目录下创建一个新的服务配置文件，例如<code>file-sync.service</code>。</p>
<pre class="codehilite"><code class="language-shell">sudo nano /etc/systemd/system/file-sync.service
</code></pre>

<p>在打开的文件中，添加以下内容：</p>
<pre class="codehilite"><code>[Unit]
Description=File Synchronization Service
After=network.target

[Service]
User=your_username
ExecStart=/usr/bin/python3 /path/to/your_script.py

[Install]
WantedBy=default.target
</code></pre>

<p>请确保按照实际情况修改以下内容：
- <code>Description</code>：描述服务的信息。
- <code>User</code>：你希望该服务以哪个用户身份运行，将<code>your_username</code>替换为你的用户名。
- <code>ExecStart</code>：指定要运行的Python解释器路径和你的同步脚本的路径。</p>
<ol>
<li>保存并关闭文件。</li>
</ol>
<p>按下<code>Ctrl + X</code>，然后按下<code>Y</code>，最后按下<code>Enter</code>来保存并关闭文件。</p>
<ol>
<li>启用并启动服务。</li>
</ol>
<p>执行以下命令启用并启动服务：</p>
<pre class="codehilite"><code class="language-shell">sudo systemctl enable file-sync.service
sudo systemctl start file-sync.service
</code></pre>

<p>这将会启用该服务，并立即启动它。</p>
<ol>
<li>验证服务状态。</li>
</ol>
<p>你可以执行以下命令来验证服务的状态：</p>
<pre class="codehilite"><code class="language-shell">sudo systemctl status file-sync.service
</code></pre>

<p>如果一切正常，你应该能够看到服务正在运行。</p>
<ol>
<li>开机自启动设置。</li>
</ol>
<p>要让该服务在系统开机时自动启动，执行以下命令：</p>
<pre class="codehilite"><code class="language-shell">sudo systemctl enable file-sync.service
</code></pre>

<p>这将会在系统开机时自动启动该服务。</p>
<p>现在，你的同步脚本已经作为一个守护进程运行，并实现了开机自启动。你可以根据需要对脚本和服务进行调整和管理。</p>
<h3>scheduler.add_job解析</h3>
<p>根据您提供的代码片段，看起来您正在使用一个调度程序（scheduler）来执行名为<code>sync_files</code>的函数。<code>scheduler.add_job()</code>函数用于向调度程序添加一个任务，并指定任务的执行方式和参数。</p>
<p>具体来说，<code>add_job()</code>函数的参数解析如下：</p>
<ol>
<li>
<p>第一个参数 (<code>sync_files</code>) 是要执行的函数或方法的名称或引用。这是您希望调度程序定期执行的任务。</p>
</li>
<li>
<p>第二个参数 (<code>'interval'</code>) 是触发器的类型。在这种情况下，您使用了<code>'interval'</code>触发器，它会在指定的时间间隔内重复执行任务。</p>
</li>
<li>
<p><code>seconds=30</code>是一个关键字参数，用于指定触发器的时间间隔。在这里，任务将每隔30秒执行一次。</p>
</li>
</ol>
<p>综上所述，您的代码片段将会向调度程序添加一个任务，该任务是定期（每隔30秒）执行名为<code>sync_files</code>的函数。请注意，这只是调度程序的一部分，您可能还需要其他代码来实际启动和运行调度程序。</p>
<h3>触发器类型</h3>
<p>在调度程序中，常见的触发器类型有以下几种：</p>
<ol>
<li>
<p><code>date</code>（日期触发器）：在指定的日期和时间执行一次任务。</p>
</li>
<li>
<p><code>interval</code>（间隔触发器）：在指定的时间间隔内重复执行任务。</p>
</li>
<li>
<p><code>cron</code>（Cron触发器）：根据Cron表达式设置任务执行的时间计划。Cron表达式可以非常灵活地定义任务执行的时间，包括分钟、小时、日期、月份和星期几等。</p>
</li>
<li>
<p><code>trigger</code>（自定义触发器）：您可以创建自定义的触发器类来满足特定的调度需求。</p>
</li>
</ol>
<p>这些触发器类型为任务的执行提供了不同的时间安排方式，使您能够根据具体需求来安排任务的执行。您可以根据任务的执行频率、时间间隔或特定日期/时间来选择适合的触发器类型。</p>
<h3>触发器类型举例</h3>
<p>当使用调度程序时，以下是不同类型的触发器的示例：</p>
<ol>
<li><code>date</code> 触发器示例：</li>
</ol>
<pre class="codehilite"><code class="language-python">scheduler.add_job(my_function, 'date', run_date=datetime(2023, 5, 10, 8, 30, 0))
</code></pre>

<p>上述示例中，<code>my_function</code> 函数将在 2023 年 5 月 10 日 8:30:00 执行一次。</p>
<ol>
<li><code>interval</code> 触发器示例：</li>
</ol>
<pre class="codehilite"><code class="language-python">scheduler.add_job(my_function, 'interval', seconds=60)
</code></pre>

<p>上述示例中，<code>my_function</code> 函数将每隔 60 秒执行一次。</p>
<ol>
<li><code>cron</code> 触发器示例：</li>
</ol>
<pre class="codehilite"><code class="language-python">scheduler.add_job(my_function, 'cron', minute='*/15', hour='9-17', day_of_week='mon-fri')
</code></pre>

<p>上述示例中，<code>my_function</code> 函数将在每小时的每隔 15 分钟执行一次，从周一到周五的 9 点到 17 点之间。</p>
<ol>
<li>自定义触发器示例：
您可以根据自己的需求创建自定义的触发器类，这里只展示一个简单的示例：</li>
</ol>
<pre class="codehilite"><code class="language-python">class MyCustomTrigger:
    def __init__(self, some_parameter):
        self.parameter = some_parameter

    def get_next_run_time(self, previous_run_time):
        # 自定义计算下一次运行时间的逻辑
        # 返回下一次运行时间的 datetime 对象

# 使用自定义触发器
my_trigger = MyCustomTrigger(some_value)
scheduler.add_job(my_function, my_trigger)
</code></pre>

<p>上述示例中，您可以创建一个自定义的触发器类<code>MyCustomTrigger</code>，根据自己的逻辑计算下一次运行时间，并将其传递给调度程序的 <code>add_job()</code> 方法。</p>
<p>这些示例涵盖了常见的触发器类型，您可以根据自己的需求选择适合的触发器类型，并根据触发器的参数进行调整。</p>
        </div>
        
    </div>



                


        </div>

    </div>
    <footer>
        
        <p>&copy; 2024 | 我的博客. 保留所有权利。</p>
    <!--    <p><a href="/privacy">隐私政策</a> | <a href="/terms">使用条款</a></p>-->
        
    </footer>

</body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
 <!-- 在页面加载完成后启用代码高亮 -->
    <script>
        // 等待页面加载完成后执行高亮
        document.addEventListener('DOMContentLoaded', function() {
            // 启用 highlight.js 代码高亮
            hljs.highlightAll();
        });
    </script>


</html>