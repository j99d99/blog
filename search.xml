<?xml version='1.0' encoding='utf-8'?>
<search><item><title>docker部署confluence与破解</title><description>&lt;h2&gt;mysql安装&lt;/h2&gt;
&lt;p&gt;略..&lt;/p&gt;
&lt;p&gt;innodb_log_file_size=2GB
max_allowed_packet=256M &lt;/p&gt;
&lt;h2&gt;创建mysql用户&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#CREATE DATABASE &amp;lt;database-name&amp;gt;</description><html_content>&lt;h2&gt;mysql安装&lt;/h2&gt;
&lt;p&gt;略..&lt;/p&gt;
&lt;p&gt;innodb_log_file_size=2GB
max_allowed_packet=256M &lt;/p&gt;
&lt;h2&gt;创建mysql用户&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#CREATE DATABASE &amp;lt;database-name&amp;gt; CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;
create database confluence character set utf8mb4 collate utf8mb4_bin;
#CREATE user '&amp;lt;confluenceuser&amp;gt;'@'localhost' IDENTIFIED BY '&amp;lt;password&amp;gt;';
create user confluence_user@localhost identified by '3e4r5t6y';
create user confluence_user@192.168.248.128 identified by '3e4r5t6y';
#GRANT ALL PRIVILEGES ON &amp;lt;database-name&amp;gt;.* TO '&amp;lt;confluenceuser&amp;gt;'@'localhost' WITH GRANT OPTION;
grant all privileges on confluence.* to confluence_user@localhost with grant option;
grant all privileges on confluence.* to confluence_user@192.168.248.128 with grant option;
grant all privileges on confluence.* to confluence_user@172.21.0.2 with grant option;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;启动&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;version: '3'
services:
    confluence:
        image: &amp;quot;atlassian/confluence-server&amp;quot;
        volumes: 
            - ./atlassian-agent.jar:/var/atlassian/atlassian-agent.jar
            - ./mysql-connector-java-8.0.22.jar:/opt/atlassian/confluence/confluence/WEB-INF/lib/mysql-connector-java-8.0.22.jar
            - /your-confluence-home:/var/atlassian/application-data/confluence
        environment:
            - JAVA_OPTS=&amp;quot;-javaagent:/var/atlassian/atlassian-agent.jar&amp;quot;
            - JVM_MINIMUM_MEMORY=2048m
            - JVM_MAXIMUM_MEMORY=2048m
            - JVM_RESERVED_CODE_CACHE_SIZE=512m
        ports: 
            - &amp;quot;8090:8090&amp;quot;
        restart: always
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;首次登陆获取Server ID&lt;/h2&gt;
&lt;h2&gt;破解,进入docker容器内部atlassian-agent.jar文件所在目录下执行如下命令&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker exec -it confluence_confluence_1  java -jar /var/atlassian/atlassian-agent.jar -d -m test@test.com -n BAT -p 'conf' -o http://localhost:8090 -s BJED-OHiT-J0AL-ZLM9
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux下常用命令find</title><description>&lt;p&gt;find 常用选项&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;-name   #按名字查找
-user   #按文件属主(用户)查找
-group  # 按文件所属的组查找
-nouser     #查找无有效属主的文件
-nogroup    #查找无有效所属组的文件
-size   #按文件大小查找

depth</description><html_content>&lt;p&gt;find 常用选项&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;-name   #按名字查找
-user   #按文件属主(用户)查找
-group  # 按文件所属的组查找
-nouser     #查找无有效属主的文件
-nogroup    #查找无有效所属组的文件
-size   #按文件大小查找

depth #首先查找当前目录中的文件
-maxdepth n #查找几级目录

-amin n #查找最后N分钟访问的文件
-cmin n #查找最后n分钟被改变文件状态的文件
-mmin n #查找最后n分钟被改变文件内容的文件

#find查找到内容后执行命令的格式
find . -perm 644 -exec COMMAND {} \; ##{}表示查找到的内容
find . -perm 644 | xargs rm -rf     #
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;p&gt;按文件权限查找&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;-perm [+-]mode

#mode解释
mode 正好符合mode
+mode 部分符合mode
-mode 完全符合mode

#举例：查找当前目录文件权限为644的文件
find . -perm 644
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按文件的更改时间查找&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;-mtime(表示文件内容修改时间)
find . -mtime -n 查找n天以内更改的文件
find . -mtime +n 查找n天以前更改的文件
-atime(同上，表示文件访问时间)
-ctime(同上，表示文件状态改变的时间)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查找比file1新但比file2旧的文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;-newer file1 ! -newer file2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;按文件类型查找&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;-type {
b 块设备文件
d 查找目录
c 查找字符设备文件
p 查找管道文件
l 查找链接文件
f 查找普通文件
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;find . -type f -exec cp {}{,.bak} \; ##将当期目录下的普通文件备份
find . -type -f |xarg cp |xargs rm -rf ##删除查找到的文件
find . -size 100m -type f #查找等于100M的文件
find . -size -100 -type f #查找小于100M的文件
find . -size +100 -type f #查找大于100M的文件

#查找多个后缀名文件
find .  \( -name &amp;quot;*.JPG&amp;quot; -o -name &amp;quot;*.jpg&amp;quot; \)

#查找删除带空格文件名
find .  \( -name &amp;quot;*.JPG&amp;quot; -o -name &amp;quot;*.jpg&amp;quot; \) -print0|xargs -0 rm
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>Linux下文件同步神器rsync</title><description>&lt;h2&gt;rsync的安装&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y rsync
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;添加配置文件&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vi /etc/rsyncd.conf
uid =</description><html_content>&lt;h2&gt;rsync的安装&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y rsync
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;添加配置文件&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vi /etc/rsyncd.conf
uid = nobody
gid = nobody
use chroot = yes
max connection = 2
pid file = /var/run/rsyncd.pid
hosts allow = *
#hosts deny = *

[test]
path = /root/soft
auth user = rsync
read only = false
secrets file = /etc/rsyncd.secrets  #密码文件
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h2&gt;创建密码文件&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/rsyncd.secrets
rsync:rsync@123
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;启动&lt;/h2&gt;
&lt;p&gt;centos7下启动&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;systemctl start rsyncd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;centos6下启动&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;rsync --daemon
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;centos6通过守护进程xinetd启动rsync&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y xinetd
vim /etc/xinetd.d/rsync
service rsync
{
        disable = no
        flags           = IPv6
        socket_type     = stream
        wait            = no
        user            = root
        server          = /usr/bin/rsync
        server_args     = --daemon
        log_on_failure  += USERID
}
#vi /etc/service
#添加以下内容
rsync           873/tcp                 # rsync
#启动xinetd服务
/etc/init.d/xinetd start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;客户端安装配置&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#yum install -y rsync
#配置服务端指定的secrets file文件
#vi /etc/rsyncd.secrets
#format user:password
rsync:rsync@123

chmod 600 /etc/rsyncd.secrets
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;文件同步命令&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;rsync -avzP --password-file=/etc/rsyncd.secrets rsync@192.168.3.2::path $des_path
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;参数&lt;/strong&gt;
- -a    以递归方式传输文件，并保持文件属性。等于 -rtopgDl
- -v    详细输出，显示输出信息
- -z    压缩传输，添加--compress-level=2 2表示压缩级别
- -P    显示同步的过程及传输时的进度等信息
- --exclude=  指定排除不需要传输的文件
- --exclude-from=  将要排除的文件写入一个文件，通过该参数指定可以排除文件内的文件
- --delete  无差异同步，如果服务器上删除了，同步时也会删除本地&lt;/p&gt;
&lt;h2&gt;文件实时同步inotify-tools安装配置&lt;/h2&gt;
&lt;h3&gt;安装&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://sourceforge.net/projects/inotify-tools/files/inotify-tools/3.13/inotify-tools-3.13.tar.gz/download
tar -zxvf inotify-tools-3.13.tar.gz
./configure 
make
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;举例&lt;/strong&gt;
实时监控/root/test目录变化，并调用rsync同步w文件到远程目录脚本&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#!/bin/sh

# get the current path
CURPATH=`pwd`

inotifywait -mr --timefmt '%d/%m/%y %H:%M' --format '%T %w %f' \
-e close_write /root/test | while read date time dir file; do

       FILECHANGE=${dir}${file}
       # convert absolute path to relative
       FILECHANGEREL=`echo &amp;quot;$FILECHANGE&amp;quot; | sed 's_'$CURPATH'/__'`

       #rsync --progress --relative -vrae 'ssh -p 22'  $FILECHANGEREL usernam@example.com:/backup/root/dir &amp;amp;&amp;amp; \

    ##同步的目录需注意，此处的$FILECHANGE是绝对路径，所以同步--relative参数是递归形势,不加此参数，所有文件包括子文件夹内的文件都会在同一级目录下
       rsync --progress  --relative -vzra --password-file=/etc/rsyncd.secrets $FILECHANGE rsync@192.168.3.2::test &amp;amp;&amp;amp; \  
       echo &amp;quot;At ${time} on ${date}, file $FILECHANGE was backed up via rsync&amp;quot;
done
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>进程管理利器-supervisor的安装配置使用</title><description>&lt;p&gt;今天介绍一个进程管理工具supervisor，Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的</description><html_content>&lt;p&gt;今天介绍一个进程管理工具supervisor，Supervisor是用Python开发的一套通用的进程管理程序，能将一个普通的命令行进程变为后台daemon，并监控进程状态，异常退出时能自动重启。它是通过fork/exec的方式把这些被管理的进程当作supervisor的子进程来启动，这样只要在supervisor的配置文件中，把要管理的进程的可执行文件的路径写进去即可。也实现当子进程挂掉的时候，父进程可以准确获取子进程挂掉的信息的，可以选择是否自己启动和报警。supervisor还提供了一个功能，可以为supervisord或者每个子进程，设置一个非root的user，这个user就可以管理它对应的进程。
 &lt;!--more--&gt;
&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;supervisor的安装很简单&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;easy_install supervisor
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1.生成初始配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;echo_supervisord_conf &amp;gt; /etc/supervisord.conf
vim /etc/supervisord.conf
#配置文件最后一行进行修改
[include]
;files = relative/directory/*.ini
files = /etc/supervisord.d/*.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.配置应用启动文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里以创建某个程序启动服务为样例
&lt;strong&gt;举例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mkdir -p /etc/supervisord.d/
cd /etc/supervisord.d/
vim suptest.conf
#配置段内容如下
[program:suptest]    #定义program，启动时使用,比如&amp;quot;supervisorctl start suptest&amp;quot;
user=root
command= java -jar test.jar     #应用启动命令,具体实际为准
autostart=true        #伴随服务自动启动
autorestart=true    #伴随服务自动重启
startsecs=10
stdout_logfile=/data/logs/suptest.log    #定义日志输出路径,需确保目录存在
stdout_logfile_maxbytes=1MB
stdout_logfile_backups=10
stdout_capture_maxbytes=1MB
stderr_logfile=/data/logs/suptest_err.log    #定义错误日志输出路径,需确保目录存在
stderr_logfile_maxbytes=1MB
stderr_logfile_backups=10
stderr_capture_maxbytes=1MB
stopsignal=INT
[supervisord]    #配置结束标志
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;3.启动supervisor服务&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;/usr/local/bin/supervisord -c /etc/supervisord.conf    #启动服务
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;4.suptest服务的启动关闭重启操作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;supervisorctl start suptest
supervisorctl stop suptest
supervisorctl restart suptest
supervisorctl status 
supervisorctl start all    #所有进程的操作
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;5.supervisor的web管理界面配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/supervisord.conf
#配置文件最后一行进行修改
[inet_http_server]
port=0.0.0.0:8080
username=supervisor
password=supervisor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启服务，可通过web访问控制&lt;/p&gt;</html_content></item><item><title>strongswan配置l2tpd/ipsec连接VPN</title><description>&lt;h2&gt;安装软件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;安装依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install pam-devel openssl-devel  make  gcc  gmp-devel wget</description><html_content>&lt;h2&gt;安装软件&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;安装依赖&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install pam-devel openssl-devel  make  gcc  gmp-devel wget -y
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;安装strongswan&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget http://download.strongswan.org/strongswan-5.5.1.tar.gz
tar xzf strongswan-5.5.1.tar.gz
cd strongswan-5.5.1

./configure  --enable-eap-identity --enable-eap-md5 \
--enable-eap-mschapv2 --enable-eap-tls --enable-eap-ttls --enable-eap-peap \
--enable-eap-tnc --enable-eap-dynamic --enable-eap-radius --enable-xauth-eap \
--enable-xauth-pam  --enable-dhcp  --enable-openssl  --enable-addrblock --enable-unity  \
--enable-certexpire --enable-radattr --enable-tools --enable-openssl --disable-gmp

make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;安装xl2tpd,httpd&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install xl2tpd httpd
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装证书&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;生成CA证书私钥&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ipsec pki --gen --outform pem &amp;gt; ca.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;签名CA证书&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ipsec pki --self --in ca.pem --dn &amp;quot;C=com, O=myvpn, CN=VPN CA&amp;quot; \
--ca --outform pem &amp;gt;ca.cert.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;生成服务器证书使用的私钥&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ipsec pki --gen --outform pem &amp;gt; server.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用CA证书签发服务器证书
&lt;strong&gt;说明:&lt;/strong&gt;
将下面命令中的&lt;code&gt;121.xx.xx.82&lt;/code&gt;替换成自己服务器IP地址或域名，&lt;code&gt;C=&lt;/code&gt;和&lt;code&gt;O=&lt;/code&gt;的值保持与前面的信息一致&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ipsec pki --pub --in server.pem | ipsec pki --issue --cacert ca.cert.pem \
--cakey ca.pem --dn &amp;quot;C=com, O=myvpn, CN=121.xx.xx.82&amp;quot; \
--san=&amp;quot;121.xx.xx.82&amp;quot; --flag serverAuth --flag ikeIntermediate  \
--outform pem &amp;gt; server.cert.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;生成客户端使用私钥&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ipsec pki --gen --outform pem &amp;gt; client.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用CA证书签发客户端证书
&lt;strong&gt;说明:&lt;/strong&gt;
生成的ca.cert.pem证书复制一份命名为ca.cert.cer提供给手机客户端使用，&lt;code&gt;C=&lt;/code&gt;和&lt;code&gt;O=&lt;/code&gt;的值保持与前面的信息一致&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ipsec pki --pub --in client.pem | ipsec pki --issue --cacert ca.cert.pem \
--cakey ca.pem --dn &amp;quot;C=com, O=myvpn, CN=VPN Client&amp;quot;  \
--outform pem &amp;gt; client.cert.pem
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;生成pkcs12用户证书，使用&lt;code&gt;RSA&lt;/code&gt;模式连接时使用此证书，令中的&lt;code&gt;-caname&lt;/code&gt;后面的引号里的值必须要与前面第二步CA中的&lt;code&gt;CN=&lt;/code&gt;的值保持一致&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;openssl pkcs12 -export -inkey client.pem -in client.cert.pem \
-name &amp;quot;client&amp;quot; -certfile ca.cert.pem -caname &amp;quot;VPN CA&amp;quot;  \
-out client.cert.p12
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;服务器证书安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cp -r ca.cert.pem /usr/local/etc/ipsec.d/cacerts/
cp -r server.cert.pem /usr/local/etc/ipsec.d/certs/
cp -r server.pem /usr/local/etc/ipsec.d/private/
cp -r client.cert.pem /usr/local/etc/ipsec.d/certs/
cp -r client.pem  /usr/local/etc/ipsec.d/private/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置&lt;/h2&gt;
&lt;p&gt;配置主要涉及到如下几个文件&lt;/p&gt;
&lt;p&gt;一、 xl2tpd相关配置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/etc/ppp/options.xl2tpd&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cat /etc/ppp/options.xl2tpd
refuse-pap
refuse-chap
refuse-mschap
require-mschap-v2


noccp
auth
#crtscts
mtu 1410
mru 1410
nodefaultroute
#lock
proxyarp
#silent
ms-dns 8.8.8.8
ms-dns 8.8.4.4
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;/etc/ppp/chap-secrets&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cat /etc/ppp/chap-secrets
# Secrets for authentication using CHAP
# client        server  secret                  IP addresses
&amp;quot;test&amp;quot;  *       &amp;quot;123456&amp;quot;        *
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;/etc/xl2tpd/xl2tpd.conf&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cat /etc/xl2tpd/xl2tpd.conf
[global]
port = 1701

[lns default]
ip range = 10.10.0.2-10.10.0.254
local ip = 10.10.0.1
length bit = yes
refuse pap = yes
refuse chap = yes
require authentication = yes
name = l2tp
pppoptfile = /etc/ppp/options.xl2tpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、 strongswan相关配置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/usr/local/etc/strongswan.conf&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cat /usr/local/etc/strongswan.conf 
# strongswan.conf - strongSwan configuration file
#
# Refer to the strongswan.conf(5) manpage for details
#
# Configuration changes should be made in the included files

charon {
        load_modular = yes
        duplicheck.enable = no
        compress = yes
        plugins {
                include strongswan.d/charon/*.conf
        }
        dns1 = 8.8.8.8
        dns2 = 8.8.4.4
        nbns1 = 8.8.8.8
        nbns2 = 8.8.4.4
}
filelog {
    /tmp/charon.log {
        # add a timestamp prefix
        time_format = %b %e %T
        # prepend connection name, simplifies grepping
        ike_name = yes
        # overwrite existing files
        append = no
        # increase default loglevel for all daemon subsystems
        default = 1
        # flush each line to disk
        flush_line = yes
    }
}


include strongswan.d/*.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;/usr/local/etc/ipsec.secrets&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cat /usr/local/etc/ipsec.secrets 
# ipsec.secrets - strongSwan IPsec secrets file
: RSA server.pem
: PSK &amp;quot;123456&amp;quot;
: XAUTH &amp;quot;123456&amp;quot;
test : EAP &amp;quot;123456&amp;quot; 
test %any : EAP &amp;quot;123456&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;/usr/local/etc/ipsec.conf&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cat /usr/local/etc/ipsec.conf 
config setup
    uniqueids=never
    charondebug=&amp;quot;chd 2,ike 1 ,ike 2, knl 2, net 2, esp 2, dmn 2,  mgr 2, lib 1, cfg 1, enc 1&amp;quot;
conn QVPN_L2TP/IPsec-PSK
    keyexchange=ikev1
    left=192.168.0.61
    leftsubnet=0.0.0.0/0
    leftprotoport=17/1701
    authby=secret
    leftfirewall=no
    right=%any
    rightprotoport=17/%any
    type=transport
    auto=add
conn QVPN_L2TP/IPsec-RSA
    keyexchange=ikev1
    keyingtries=1
    left=%any
    leftprotoport=udp/l2tp
    leftid=192.168.0.61
    #leftsubnet=0.0.0.0/0
    leftcert=server.cert.pem
    #leftsendcert=always
    right=%any
    rightprotoport=udp/%any
    type=transport
    auto=add

conn QVPN_IPsec-Xauth-PSK
    keyexchange=ikev1
    left=%defaultroute
    leftauth=psk
    leftsubnet=0.0.0.0/0
    right=%any
    rightauth=psk
    rightauth2=xauth
    rightsourceip=10.10.0.0/24
    rightsubnet=0.0.0.0/0
    auto=add
conn QVPN_IPsec-Xauth-RSA
    keyexchange=ikev1
    fragmentation = yes
    leftsubnet=0.0.0.0/0
    leftid=192.168.0.61
    leftcert=server.cert.pem
    leftsendcert=always
    # secure cipher suits
    #ike=aes128-sha1-modp1536,aes128-sha1-modp1024,aes128-md5-modp1536,aes128-md5-modp1024,3des-sha1-modp1536,3des-sha1-modp1024,3des-md5-modp1536,3des-md5-modp1024
    #esp=aes128-sha1-modp1536,aes128-sha1-modp1024,aes128-md5-modp1536,aes128-md5-modp1024,3des-sha1-modp1536,3des-sha1-modp1024,3des-md5-modp1536,3des-md5-modp1024
    rightsourceip=10.10.0.0/24
    rightsubnet=0.0.0.0/0
    rightca=&amp;quot;C=CN, O=QiKuVPN, CN=360QiKU&amp;quot;
    rightcert=client.cert.pem
    rightauth2=xauth
    xauth=server
    auto=add
conn QVPN_IPsec-Hybrid-RSA
    keyexchange=ikev1
    leftid=192.168.0.61
    leftsubnet=0.0.0.0/0
    leftcert=server.cert.pem
    leftsendcert=always
    leftauth=pubkey
    leftfirewall=yes
    right=%any
    rightsourceip=10.10.0.0/24
    rightsubnet=0.0.0.0/0
    rightauth=xauth
    xauth=server
    auto=add

conn ios_ikev2
    keyexchange=ikev2
    ike=aes256-sha256-modp2048,3des-sha1-modp2048,aes256-sha1-modp2048!
    esp=aes256-sha256,3des-sha1,aes256-sha1!
    rekey=no
    left=%defaultroute
    leftid=192.168.0.61
    leftsendcert=always
    leftsubnet=0.0.0.0/0
    leftcert=server.cert.pem
    right=%any
    rightauth=eap-mschapv2
    rightsourceip=10.31.4.0/24
    rightsendcert=never
    eap_identity=%any
    dpdaction=clear
    fragmentation=yes
    auto=add
conn windows7
    keyexchange=ikev2
    ike=aes256-sha1-modp1024!
    rekey=no
    left=%defaultroute
    leftauth=pubkey
    leftsubnet=0.0.0.0/0
    leftcert=server.cert.pem
    right=%any
    rightauth=eap-mschapv2
    rightsourceip=10.31.5.0/24
    rightsendcert=never
    eap_identity=%any
    auto=add
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置iptables和内核参数&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;内核参数配置&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cat &amp;gt;&amp;gt; /etc/sysctl.conf&amp;lt;&amp;lt;-EOF
net.ipv4.ip_forward = 1
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.all.send_redirects = 0
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;iptables配置
&lt;strong&gt;说明&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;10.10.0.0&lt;/code&gt;根据&lt;code&gt;/etc/xl2tpd/xl2tpd.conf&lt;/code&gt;文件设置的IP进行修改&lt;/li&gt;
&lt;li&gt;&lt;code&gt;eth0&lt;/code&gt;根据具体的服务器网卡名进行修改&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p udp --dport 500 -j ACCEPT
iptables -A INPUT -p udp --dport 4500 -j ACCEPT
iptables -A INPUT -p udp --dport 1701 -j ACCEPT
iptables -A INPUT -p udp --dport 1723 -j ACCEPT
iptables -t nat -A POSTROUTING -s 10.10.0.0/24 -o eth0 -j MASQUERADE
iptables -A FORWARD -s 10.10.0.0/24 -j ACCEPT
iptables -t nat -A POSTROUTING -s 10.10.0.0/24 -o eth0 -m policy --dir out --pol none -j MASQUERADE
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置证书下载&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;拷贝证书&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mkdir /var/www/html/key
cp -p ca.cert.pem  /var/www/html/key/ca.cert.cer
cp -p ca.cert.pem  /var/www/html/key/
cp -p client.cert.p12  /var/www/html/key/
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;添加apach配置段&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 配置apache登录账户密码
htpasswd -c -b /etc/httpd/htpasdb  test  123456

# 在apache配置文件/etc/httpd/conf/httpd.conf最后追加：

&amp;lt;directory /&amp;gt;
options indexes
AuthType Basic
AuthName &amp;quot;!!!&amp;quot;
AuthBasicProvider file
AuthUserFile /etc/httpd/htpasdb
Require user test

&amp;lt;/directory&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;启动httpd服务&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;service httpd restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;测试&lt;/h2&gt;
&lt;p&gt;省略...&lt;/p&gt;</html_content></item><item><title>linux系统搭建本地yum源-debian</title><description>&lt;h3&gt;下载debian的dvd版本iso镜像文件&lt;/h3&gt;
&lt;p&gt;参考下载地址：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code</description><html_content>&lt;h3&gt;下载debian的dvd版本iso镜像文件&lt;/h3&gt;
&lt;p&gt;参考下载地址：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;https://cdimage.debian.org/cdimage/archive/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;上传下载好的镜像并挂载&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;
下面的挂载重启系统后需要重新挂载，可以考虑将挂载添加到&lt;code&gt;/etc/fstab&lt;/code&gt;文件当中&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mount -t iso9660 -o loop debian-9.13.0-amd64-DVD-1.iso /media/cdrom1
mount -t iso9660 -o loop debian-9.13.0-amd64-DVD-2.iso /media/cdrom2
mount -t iso9660 -o loop debian-9.13.0-amd64-DVD-3.iso /media/cdrom3
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;添加/etc/apt/sources.list文件&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cat &amp;gt; /etc/apt/sources.list &amp;lt;&amp;lt;EOF
deb [ trusted=yes ] file:/media/cdrom1/ stretch main contrib 
deb [ trusted=yes ] file:/media/cdrom2/ stretch main contrib 
deb [ trusted=yes ] file:/media/cdrom3/ stretch main contrib 


EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;更新并安装软件&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;apt update
apt install vim
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>zookeeper集群搭建与配置</title><description>&lt;h2&gt;服务器信息&lt;/h2&gt;
&lt;p&gt;| hosts | ip |
| ---- | ---- |
| zookeeper01 | 192.168.122.217 |
| zookeeper02 | 192.168.122.132 |
| zookeeper03 | 192.168.122.112 |&lt;/p&gt;
&lt;h2&gt;软件版本&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;</description><html_content>&lt;h2&gt;服务器信息&lt;/h2&gt;
&lt;p&gt;| hosts | ip |
| ---- | ---- |
| zookeeper01 | 192.168.122.217 |
| zookeeper02 | 192.168.122.132 |
| zookeeper03 | 192.168.122.112 |&lt;/p&gt;
&lt;h2&gt;软件版本&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;    jdk-7u80-linux-x64.rpm
    zookeeper-3.4.6.tar.gz
    官方下载地址:http://www.apache.org/dyn/closer.cgi/zookeeper/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装jdk&lt;/h2&gt;
&lt;p&gt;三台服务器均需要安装&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code&gt;rpm -vih jdk-7u80-linux-x64.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;zookeeper的安装配置&lt;/h2&gt;
&lt;h3&gt;在zookeeper01上&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;tar zxvf zookeeper-3.4.6.tar.gz 
mv zookeeper-3.4.6 /usr/local/zookeeper-3.4.6
vim /etc/profile
......
#设置zookeeper环境变量
#ZOOKEEPER  
ZOOKEEPER=/usr/local/zookeeper-3.4.6 
PATH=$PATH:$ZOOKEEPER/bin

source /etc/profile
cp /usr/local/zookeeper-3.4.6/conf/zoo_sample.cfg /usr/local/zookeeper-3.4.6/conf/zoo.cfg     #拷贝zookeeper的配置文件
cd /usr/local/zookeeper-3.4.6/conf
sed -i 's#dataDir=/tmp/zookeeper#dataDir=/data/zookeeper#g' zoo.cfg    #修改data目录
vim zoo.cfg
......
#server.A=B：C：D：A表示第几号服务器；B 是这个服务器的 ip 地址；C 与集群中的 Leader 服务器交换信息的端口；D 表示Leader 服务器挂了，执行选举时服务器相互通信的端口
server.1=192.168.122.217:2888:3888 
server.2=192.168.122.132:2888:3888
server.3=192.168.122.112:2888:3888

mkdir -p /data/zookeeper
cd /data/zookeeper/
vim myid  #常见myid文件
1   #此处的1对应server.1
#启动zookeeper
zkServer.sh start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;在zookeeper02上&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;tar zxvf zookeeper-3.4.6.tar.gz 
mv zookeeper-3.4.6 /usr/local/zookeeper-3.4.6
vim /etc/profile
......
#设置zookeeper环境变量
#ZOOKEEPER  
ZOOKEEPER=/usr/local/zookeeper-3.4.6 
PATH=$PATH:$ZOOKEEPER/bin

source /etc/profile

cp /usr/local/zookeeper-3.4.6/conf/zoo_sample.cfg /usr/local/zookeeper-3.4.6/conf/zoo.cfg     #拷贝zookeeper的配置文件
cd /usr/local/zookeeper-3.4.6/conf
sed -i 's#dataDir=/tmp/zookeeper#dataDir=/data/zookeeper#g' zoo.cfg    #修改data目录

vim zoo.cfg
......
#server.A=B：C：D：A表示第几号服务器；B 是这个服务器的 ip 地址；C 与集群中的 Leader 服务器交换信息的端口；D 表示Leader 服务器挂了，执行选举时服务器相互通信的端口
server.1=192.168.122.217:2888:3888 
server.2=192.168.122.132:2888:3888
server.3=192.168.122.112:2888:3888

mkdir -p /data/zookeeper
cd /data/zookeeper/
vim myid  #常见myid文件
2   #此处的2对应server.2
#启动zookeeper
zkServer.sh start
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;在zookeeper03上&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;tar zxvf zookeeper-3.4.6.tar.gz 
mv zookeeper-3.4.6 /usr/local/zookeeper-3.4.6
vim /etc/profile
......
#设置zookeeper环境变量
#ZOOKEEPER  
ZOOKEEPER=/usr/local/zookeeper-3.4.6 
PATH=$PATH:$ZOOKEEPER/bin

source /etc/profile
cp /usr/local/zookeeper-3.4.6/conf/zoo_sample.cfg /usr/local/zookeeper-3.4.6/conf/zoo.cfg     #拷贝zookeeper的配置文件
cd /usr/local/zookeeper-3.4.6/conf
sed -i 's#dataDir=/tmp/zookeeper#dataDir=/data/zookeeper#g' zoo.cfg    #修改data目录
vim zoo.cfg
......
#server.A=B：C：D：A表示第几号服务器；B 是这个服务器的 ip 地址；C 与集群中的 Leader 服务器交换信息的端口；D 表示Leader 服务器挂了，执行选举时服务器相互通信的端口
server.1=192.168.122.217:2888:3888 
server.2=192.168.122.132:2888:3888
server.3=192.168.122.112:2888:3888
mkdir -p /data/zookeeper
cd /data/zookeeper/
vim myid  #常见myid文件
3   #此处的3对应server.3
#启动zookeeper
zkServer.sh start
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;查看zookeeper状态&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;#zookeeper01
zkServer.sh status
JMX enabled by default
Using config: /usr/local/zookeeper-3.4.6/bin/../conf/zoo.cfg
Mode: leader    #区别另外两台

#zookeeper02
zkServer.sh status
JMX enabled by default
Using config: /usr/local/zookeeper-3.4.6/bin/../conf/zoo.cfg
Mode: follower

#zookeeper03
zkServer.sh status
JMX enabled by default
Using config: /usr/local/zookeeper-3.4.6/bin/../conf/zoo.cfg
Mode: follower
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>pgsql的安装和基本操作</title><description>&lt;p&gt;平时工作中，使用mysql的时候比较多，pgsql使用很少。所以接触的也少，偶尔一次小项目需要使用pgsql，于是记录一下，pgsql最基本的一些操作&lt;/p&gt;
&lt;h6&gt;pgsql的安装&lt;/h6&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code&gt;tar xvf xxx
./configure
make
su
make install
adduser</description><html_content>&lt;p&gt;平时工作中，使用mysql的时候比较多，pgsql使用很少。所以接触的也少，偶尔一次小项目需要使用pgsql，于是记录一下，pgsql最基本的一些操作&lt;/p&gt;
&lt;h6&gt;pgsql的安装&lt;/h6&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code&gt;tar xvf xxx
./configure
make
su
make install
adduser postgres
mkdir /usr/local/pgsql/data
chown postgres /usr/local/pgsql/data
su - postgres
/usr/local/pgsql/bin/initdb -D /usr/local/pgsql/data
/usr/local/pgsql/bin/postgres -D /usr/local/pgsql/data &amp;gt;logfile 2&amp;gt;&amp;amp;1 &amp;amp;
/usr/local/pgsql/bin/createdb test
/usr/local/pgsql/bin/psql test
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;设置pgsql必须密码登录&lt;/h6&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;vim pg_hba.conf

#host all all 127.0.0.1/32 trust
host all all 127.0.0.1/32 passowrd
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;一些基本命令&lt;/h6&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;#创建用户
create user hbyc with password'LQ123er48vzz';
#创建数据库
create database ychbV1 with encoding='utf8' owner=hbyc;
#授权
grant all privileges on database ychbV1 to hbyc;
#登录
psql -Upostgres -dtest -h127.0.0.1
#查看已有数据库
\l
#查看表
\dt
#导入sql文件
psql -d ychbv1 -Uhbyc -h127.0.0.1 -f ychb.sql

#修改用户密码
alter user postgres with password'U5123ewqyjEi5';
#设置密码
\password postgres
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;数据库备份&lt;/h6&gt;
&lt;p&gt;下面是一个pgsql数据库备份的脚本&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;#通过变量设置pgsql相关信息
vim ~/.pgpass
格式如下
hostname：port：dbname：username：password 

#备份脚本
vim pgsql_backup.sh
#!/bin/bash
pg_dump -U dbuser -h 127.0.0.1 -p 5432 -f /data/db_backup/ychbv1_$(date +%Y%m%d_%H_%M_%S).sql
echo &amp;quot;backup finished&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux下使用rpmbuild定制rpm包</title><description>&lt;p&gt;以打包源码tengine为例&lt;/p&gt;
&lt;h2&gt;安装rpmbuild命令&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install rpm-build
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;基础目录配置&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code</description><html_content>&lt;p&gt;以打包源码tengine为例&lt;/p&gt;
&lt;h2&gt;安装rpmbuild命令&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install rpm-build
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;基础目录配置&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim .rpmmacros
#.rpmmacros
%_topdir /root/rpmbuild
%_tmppath /root/rpmbuild/tmp
%buildroot /root/rpmbuild/BUILDROOT
%_prefix   /

mkdir -pv ~/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
rpmbuild -showrc|grep _topdir
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h2&gt;将需要制作的源码包放入~/rpmbuild/SOURCES&lt;/h2&gt;
&lt;p&gt;打包需要用到的文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cd ~/rpmbuild/SOURCES
ls
tengine-x.x.x.tar.gz        #软件源码
init.nginx        #nginx启动脚本
fastcgi_params    #nginx配置文件
nginx.conf        #nginx配置文件
www.conf    #定义好的默认代理配置文件模板
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置rpmbuild配置文件nginx.spec&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cd ~/rpmbuild/SPECS
vim nginx.spec
Name:           tengine
Version:        x.x.x
Release:        1%{?dist}
Summary:        tengine-x.x.x.tar.gz
Group:          Applications/Archiving
License:        GPL
URL:            http://tengine.taobao.org/
Source0:        tengine-x.x.x.tar.gz
Source1:        init.nginx
Source2:        nginx.conf
Source3:        fastcgi_params
Source4:        www.conf
BuildRequires:  gcc
Requires:       openssl,openssl-devel,pcre-devel,pcre
BuildRoot:      %_topdir/BUILDROOT
%description
Custom a rpm by yourself!Build tengine-2.1.2.tar.gz to tengine-2.1.2-1.el6.x86_64.rpm
%prep
%setup -q
%build
./configure --prefix=/usr/local/nginx \
--conf-path=/etc/nginx/nginx.conf \
--sbin-path=/usr/sbin/nginx \
--with-http\_ssl\_module \
--with-http\_realip\_module \
--with-http\_addition\_module \
--with-http\_image\_filter_module \
--with-http\_sub\_module \
--with-http\_dav\_module \
--with-http\_flv\_module \
--with-http\_mp4\_module \
--with-http\_gzip\_static_module \
--with-http\_concat\_module \
--with-http\_random\_index_module \
--with-http\_secure\_link_module \
--with-http\_degradation\_module \
--with-http\_sysguard\_module \
--with-backtrace_module \
--with-http\_stub\_status_module \
--with-http\_upstream\_check_module \
--with-debug --with-http\_realip\_module
make %{?\_smp\_mflags}
%install
rm -rf %{buildroot}
make install DESTDIR=%{buildroot}
%{__install} -p -D -m 0755 %{SOURCE1} %{buildroot}/etc/rc.d/init.d/nginx
%{__install} -p -D %{SOURCE2} %{buildroot}/etc/nginx/nginx.conf
%{\_\_install} -p -D %{SOURCE3} %{buildroot}/etc/nginx/fastcgi\_params
%{__install} -p -D %{SOURCE4} %{buildroot}/etc/nginx/vhosts/www.conf

%clean
rm -rf %{buildroot}
%pre
%post
%preun
%postun
rm -rf /usr/local/nginx

%files
%defattr(-,root,root)
/etc/nginx/
/usr/local/nginx
/usr/sbin/nginx
/etc/rc.d/init.d/nginx


%changelog
* Tue date   - x.x.x-x
- Initial version
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;执行命令&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;rpmbuild –ba nginx.spec
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;执行完毕,rpm被放入~/rpmbuild/RPMS目录，可自行测试打包文件是否正确&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cd ~/rpmbuild/RPMS
ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;Source文件每添加一个，都需在%install段和%file段内添加
%build段之前的
%pre表示编译前的工作（源码解压，进入解压包等）
%setup –q(用来完成%pre段内的所有工作，-q表示静默完成)
%install（make install）段内的
%pre表示安装前的工作
%post表示安装后的工作
%preun表示卸载前的工作
%postun表示卸载后的工作
%files段需要包含到rpm包内的文件，buildroot文件夹内的文件都需要包含进去，否则会报错
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux下静默方式安装oracle 11g</title><description>&lt;h1&gt;安装前准备工作&lt;/h1&gt;
&lt;h2&gt;一、安装相关依赖包&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum -y install binutils compat-libstdc++-33 elfutils-libelf elfutils-libelf-devel elfutils-libelf-devel-static</description><html_content>&lt;h1&gt;安装前准备工作&lt;/h1&gt;
&lt;h2&gt;一、安装相关依赖包&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum -y install binutils compat-libstdc++-33 elfutils-libelf elfutils-libelf-devel elfutils-libelf-devel-static gcc gcc-c++ glibc glibc-common glibc-devel glibc-headers kernel-headers ksh libaio libaio-devel libgcc libgomp libstdc++ libstdc++-devel make sysstat unixODBC unixODBC-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、修改内核参数&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;（root身份，没有的自行添加）
vi /etc/sysctl.conf
kernel.shmall = 2097152    //表示系统一次可以使用的共享内存总量(以页为单位)。缺省值就是2097152，通常不需要修改
kernel.shmmax = 2147483648    //定义了共享内存段的最大尺寸(以字节为单位)。缺省为32M，对于oracle来说，该缺省值太低了，通常将其设置为2G=2147483648/1024/1024/1024
kernel.shmmni = 4096   //用于设置系统范围内共享内存段的最大数量。该参数的默认值是4096 。通常不需要更改
kernel.sem = 250 32000 100 128    //表示设置的信号量
fs.file-max = 65536    //表示文件句柄的最大数量。文件句柄表示在Linux系统中可以打 开的文件数量。其实是由&amp;quot;fs.file-max = 512 * PROCESSES&amp;quot;得到的，我们指定PROCESSES的值为128，即为&amp;quot;fs.file-max =512 *128&amp;quot;。
fs.aio-max-nr = 1048576    //同时可以拥有的的异步IO请求数目。
net.ipv4.ip_local_port_range = 1024 65000    //应用程序可使用的Ipv4端口范围。
net.core.rmem_default = 262144    //默认的接收窗口大小
net.core.rmem_max = 4194304      //接收窗口的最大大小
net.core.wmem_default = 262144   //默认的发送窗口大小
net.core.wmem_max = 1048586    //发送窗口的最大大小

实例：
fs.aio-max-nr = 1048576
fs.file-max = 6815744
kernel.shmall = 2097152
kernel.shmmax = 536870912
kernel.shmmni = 4096
kernel.sem = 250 32000 100 128
net.ipv4.ip_local_port_range = 9000 65500
net.core.rmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 1048586
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使修改生效&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sysctl -p   //使修改立即生效
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sysctl -p报错处理 &lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;error: &amp;quot;net.bridge.bridge-nf-call-ip6tables&amp;quot; is an unknown key  
error: &amp;quot;net.bridge.bridge-nf-call-iptables&amp;quot; is an unknown key  
error: &amp;quot;net.bridge.bridge-nf-call-arptables&amp;quot; is an unknown key

modprobe bridge  
lsmod | grep bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;为oracle用户设置shell限制&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#vi /etc/security/limits.conf   添加以下内容
oracle           soft    nproc   2047
oracle           hard    nproc   16384
oracle           soft    nofile  1024
oracle           hard    nofile  65536

#vi /etc/pam.d/login     添加以下内容
session    required     pam_limits.so

关闭selinux
#vi /etc/selinux/config 修改为disabled
SELINUX=disabled

临时关闭命令
setenforce 0
 ```

编辑/etc/profile，添加如下内容
```bash
#vi /etc/profile
if [ $USER = &amp;quot;oracle&amp;quot; ]; then
        if [ $SHELL = &amp;quot;/bin/ksh&amp;quot; ]; then
     ulimit -p 16384
              ulimit -n 65536
        else
     ulimit -u 16384 -n 65536
        fi
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑/etc/csh.login,添加如下内容&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#vi /etc/csh.login
if ( $USER == &amp;quot;oracle&amp;quot; ) then
        limit maxproc 16384
        limit descriptors 65536
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：内核参数并非必须修改，可以根据自己实际情况而定。  以上为安装oracle的前置工作&lt;/p&gt;
&lt;h1&gt;安装oracle&lt;/h1&gt;
&lt;h2&gt;创建需要的目录&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;groupadd oinstall
groupadd oradba
useradd -g oinstall -G oradba oracle
id oracle   //查看账户是否建立完成
mkdir -p /opt/oracle
mkdir /opt/oracle/11g
chown -R oracle:oinstall /opt/oracle
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;添加oracle环境变量&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#vi /etc/profile
export ORACLE_BASE=/opt/oracle
export ORACLE_HOME=/opt/oracle/11g
export ORACLE_SID=orcl11g
export PATH=$PATH:$ORACLE_HOME/bin

#source /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;设置&lt;code&gt;db_install.rsp&lt;/code&gt;安装文件&lt;/h2&gt;
&lt;p&gt;编辑oracle应答文件db_install.rsp，文件存在解压目录的response目录下（最好将文件解压到oracle家目录/home/oracle下）&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#vi db_install.rsp
oracle.install.option=INSTALL_DB_SWONLY
ORACLE_HOSTNAME=localhost
UNIX_GROUP_NAME=oinstall
INVENTORY_LOCATION=/opt/oracle/oraInventory
SELECTED\_LANGUAGES=en,zh_CN
ORACLE_HOME=/opt/oracle/11g
ORACLE_BASE=/opt/oracle
oracle.install.db.InstallEdition=EE
oracle.install.db.DBA_GROUP=oradba
oracle.install.db.OPER_GROUP=oradba
DECLINE_SECURITY_UPDATES=true

#su oracle
$./runInstaller  -silent  -responseFile /home/oracle/database/response/db_install.rsp -ignorePrereq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当出现下面提示时，脚本执行正常完成&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;The following configuration scripts need to be executed as the &amp;quot;root&amp;quot; user. 
 #!/bin/sh 
 #Root scripts to run

/opt/oracle/oraInventory/orainstRoot.sh
/opt/oracle/11g/root.sh
To execute the configuration scripts:
         1. Open a terminal window 
         2. Log in as &amp;quot;root&amp;quot; 
         3. Run the scripts 
         4. Return to this window and hit &amp;quot;Enter&amp;quot; key to continue 

Successfully Setup Software.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;系统初始化&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;su root
$ORACLE_BASE/oraInventory/orainstRoot.sh
$ORACLE_HOME/root.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装网络监听器&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;su oracle
$ORACLE_HOME/bin/netca /silent /responseFile /home/oracle/database/response/netca.rsp
查看监听器状态
$ORACLE_HOME/bin/lsnrctl status



su oracle
vi $ORACLE_HOME/bin/dbstart
将ORACLE_HOME_LISTNER=/ade/vikrkuma_new/oracle（或者是ORACLE_HOME_LISTNER=$1）修改成ORACLE_HOME_LISTNER=$ORACLE_HOME
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装数据库实例&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;编辑response目录下的dbca.rsp文件
#vi dbca.rsp
GDBNAME = &amp;quot;orcl11g&amp;quot;  //全局数据库的名字=SID+主机域名
SID = &amp;quot;orcl11g&amp;quot;    //对应的实例名字
TEMPLATENAME = &amp;quot;General_Purpose.dbc&amp;quot; //建库用的模板文件
SYSPASSWORD = 9xxxx     //SYS用户初始密码
SYSTEMPASSWORD = 9xxxxx   //SYSTEM用户初始密码
DATAFILEDESTINATION = /opt/oracle/oradata   //数据文件存放目录
RECOVERYAREADESTINATION = /opt/oracle/oradata_back   //恢复数据文件存放目录
CHARACTERSET = &amp;quot;ZHS16GBK&amp;quot;
TOTALMEMORY = &amp;quot;2048&amp;quot;

保存完毕后切换到oracle身份
su oracle
$ORACLE_HOME/bin/dbca -silent -responseFile /home/oracle/database/response/dbca.rsp 

修改oracle启动配置文件/etc/oratab
su oracle
vi /etc/oratab
将
orcl11g:/usr/local/oracle/11g:N
修改为
orcl11g:/usr/local/oracle/11g:Y
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;ORACLE的启动和关闭&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;su oracle

监听器的启动
$ORACLE_HOME/bin/lsnrctl start
监听器的状态查看
$ORACLE_HOME/bin/lsnrctl status

启动oracle实例
sqlplus sys as sysdba
输入密码后进入
SQL&amp;gt;startup   //启动数据库命令
或者使用命令启动
$ORACLE_HOME/bin/dbstart

关闭数据库实例
SQL&amp;gt;shutdown immediate
或者使用命令关闭
$ORACLE_HOME/bin/dbstart

关闭监听
$lsnrctl stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;将oracle作为服务&lt;/h2&gt;
&lt;p&gt;在root登录下&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vi /etc/init.d/oracle  复制以下文本后保存

#!/bin/sh

# chkconfig: 35 80 10 
# description: Oracle auto start-stop script.

# 
# Set ORACLE\_HOME to be equivalent to the $ORACLE\_HOME
# from which you wish to execute dbstart and dbshut;
# 
# Set ORACLE_OWNER to the user id of the owner of the
# Oracle database in ORACLE_HOME.
ORACLE_HOME=/opt/oracle/11g
ORACLE_OWNER=oracle 
if [ ! -f $ORACLE_HOME/bin/dbstart ]
then 
    echo &amp;quot;Oracle startup: cannot start&amp;quot;
    exit
fi 
case &amp;quot;$1&amp;quot; in
'start') 
# Start the Oracle databases: 
echo &amp;quot;Starting Oracle Databases ... &amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Starting Oracle Databases as part of system up.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
su - $ORACLE_OWNER -c &amp;quot;$ORACLE_HOME/bin/dbstart&amp;quot; &amp;gt;&amp;gt;/var/log/oracle
echo &amp;quot;Done&amp;quot; 

# Start the Listener: 
echo &amp;quot;Starting Oracle Listeners ... &amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Starting Oracle Listeners as part of system up.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
su - $ORACLE_OWNER -c &amp;quot;$ORACLE_HOME/bin/lsnrctl start&amp;quot; &amp;gt;&amp;gt;/var/log/oracle
echo &amp;quot;Done.&amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Finished.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
touch /var/lock/subsys/oracle
;;

'stop') 
# Stop the Oracle Listener: 
echo &amp;quot;Stoping Oracle Listeners ... &amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Stoping Oracle Listener as part of system down.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
su - $ORACLE_OWNER -c &amp;quot;$ORACLE_HOME/bin/lsnrctl stop&amp;quot; &amp;gt;&amp;gt;/var/log/oracle
echo &amp;quot;Done.&amp;quot; 
rm -f /var/lock/subsys/oracle

# Stop the Oracle Database: 
echo &amp;quot;Stoping Oracle Databases ... &amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Stoping Oracle Databases as part of system down.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
su - $ORACLE_OWNER -c &amp;quot;$ORACLE_HOME/bin/dbshut&amp;quot; &amp;gt;&amp;gt;/var/log/oracle
echo &amp;quot;Done.&amp;quot;
echo &amp;quot;&amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Finished.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
;;

'restart')
$0 stop
$0 start
;;
esac





chmod +x /etc/init.d/oracle
chkconfig --level 35 oracle on
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;## 错误解决
启动oracle时提示找不到pflie文件错误解决&lt;br /&gt;
1.启动时指定pfile文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;SQL&amp;gt; startup pfile=/oradata/oracle/admin/orcl/pfile/init.ora.3102012232637
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.启动后，重新创建spfile文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;SQL&amp;gt; create spfile from pfile='/oradata/oracle/admin/orcl/pfile/init.ora.3102012232637';
File created.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.关闭数据库&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;SQL&amp;gt; shutdown immediate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.此时启动就不需要指定pfile文件了，默认以spfile文件启动&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;SQL&amp;gt; startup
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;修改用户&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sqlplus /nolog
SQL&amp;gt; conn /as sysdba
已连接。
SQL&amp;gt; alter user system identified by password;

用户已更改。

SQL&amp;gt; alter user sys identified by password;

用户已更改。

SQL&amp;gt; alter user system identified by manger;

解锁方法
 alter user system account unlock;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;Oracle开启远程连接
listener.ora文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 修改前
LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
      (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521))
    )
  )

ADR_BASE_LISTENER = /opt/oracle

# 修改后

SID_LIST_LISTENER =
  (SID_LIST =
    (SID_DESC =
        (GLOBAL_DBNAME = orcl11g)
        (ORACLE_HOME = /opt/oracle/11g)
        (SID_NAME = orcl11g)
    )
  )
LISTENER =
  (DESCRIPTION_LIST =
    (DESCRIPTION =
      (ADDRESS = (PROTOCOL = TCP)(HOST = 172.16.90.57)(PORT = 1521))
    )
  )

ADR_BASE_LISTENER = /opt/oracle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tnsnames.ora文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 修改前
ORCL11G =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 172.16.90.57)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = orcl11g)
    )
  )
# 修改后
ORCL11G =
  (DESCRIPTION =
    (ADDRESS_LIST = 
        (ADDRESS = (PROTOCOL = TCP)(HOST = 172.16.90.57)(PORT = 1521))
    )
    (CONNECT_DATA =
        (SID = orcl11g)
    )
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重启oracle监听服务&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;lsnrctl stop
lsnrctl start
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux下redis集群配置</title><description>&lt;h1&gt;集群环境介绍&lt;/h1&gt;
&lt;p&gt;redis集群环境搭建，下面是一个三台服务器组件完成的redis集群&lt;/p&gt;
&lt;p&gt;| host    | ip   |
| ----------- | ----------- |
| redis1 | 192.168.122.217 |
| redis2 | 192.168.122.132 |
| redis3 | 192.168.122.112</description><html_content>&lt;h1&gt;集群环境介绍&lt;/h1&gt;
&lt;p&gt;redis集群环境搭建，下面是一个三台服务器组件完成的redis集群&lt;/p&gt;
&lt;p&gt;| host    | ip   |
| ----------- | ----------- |
| redis1 | 192.168.122.217 |
| redis2 | 192.168.122.132 |
| redis3 | 192.168.122.112 |&lt;/p&gt;
&lt;h1&gt;redis的安装&lt;/h1&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget http://download.redis.io/releases/redis-3.0.4.tar.gz         #下载软件
yum install -y gcc-c++        #安装gcc-c++依赖,初始最小化系统未安装，需安装
tar zxvf redis-3.0.4.tar.gz
cd redis-3.0.4
make PREFIX=/usr/local/redis6379 install        #一台服务器安装两个redis,所以命名以端口区分
make PREFIX=/usr/local/redis6380 install
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;h2&gt;redis的初始配置&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[root@redis01 redis-3.0.4]# cd utils/
[root@redis01 utils]# sh install_server.sh  ##redis6379的初始化配置
Welcome to the redis service installer
This script will help you easily set up a running redis server

Please select the redis port for this instance: [6379]  #默认6379端口,不需要修改，直接回车即可
Selecting default: 6379
Please select the redis config file name [/etc/redis/6379.conf]     #默认，直接回车即可
Selected default - /etc/redis/6379.conf
Please select the redis log file name [/var/log/redis_6379.log] /data/weblogs/redis/redis_6379.log  #修改redis6379的日志路径
Please select the data directory for this instance [/var/lib/redis/6379] /data/redis/6379           #修改redis6379实例数据位置
Please select the redis executable path [] /usr/local/redis6379/bin/redis-server                #redis6379的执行文件目录
Selected config:
Port           : 6379
Config file    : /etc/redis/6379.conf
Log file       : /data/weblogs/redis/redis_6379.log
Data dir       : /data/redis/6379
Executable     : /usr/local/redis6379/bin/redis-server
Cli Executable : /usr/local/redis6379/bin/redis-cli
Is this ok? Then press ENTER to go on or Ctrl-C to abort.
Copied /tmp/6379.conf =&amp;gt; /etc/init.d/redis_6379
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
Starting Redis server...
Installation successful!

[root@redis01 utils]# sh install_server.sh  ##redis6380的初始化配置 
Welcome to the redis service installer
This script will help you easily set up a running redis server

Please select the redis port for this instance: [6379] 6380         ##配置redis6380的端口为6380
Please select the redis config file name [/etc/redis/6380.conf]     #配置文件路径，直接回车即可
Selected default - /etc/redis/6380.conf
Please select the redis log file name [/var/log/redis_6380.log] /data/weblogs/redis/redis_6380.log      #修改redis6380的日志路径
Please select the data directory for this instance [/var/lib/redis/6380] /data/redis/6380               #修改redis6380实例数据位置
Please select the redis executable path [] /usr/local/redis6380/bin/redis-server                        #redis6380的执行文件目录
Selected config:
Port           : 6380
Config file    : /etc/redis/6380.conf
Log file       : /data/weblogs/redis/redis_6380.log
Data dir       : /data/redis/6380
Executable     : /usr/local/redis6380/bin/redis-server
Cli Executable : /usr/local/redis6380/bin/redis-cli
Is this ok? Then press ENTER to go on or Ctrl-C to abort.
Copied /tmp/6380.conf =&amp;gt; /etc/init.d/redis_6380
Installing service...
Successfully added to chkconfig!
Successfully added to runlevels 345!
Starting Redis server...
Installation successful!
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;开启redis持久化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1.修改redis配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sed -i 's/appendonly no/appendonly yes/g' /etc/redis/6379.conf
sed -i 's/appendonly no/appendonly yes/g' /etc/redis/6380.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.重启生效&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#重启服务
service redis_6379 restart 
service redis_6380 restart

#查看是否有持久化文件
ls /data/redis/6379/
appendonly.aof  dump.rdb        

ls /data/redis/6380/
appendonly.aof  dump.rdb
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;集群配置&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;以redis01为例，另外两台操作相同&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;开启redis集群相关配置项&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#修改redis6379
[root@redis01 ~]# sed -i 's/# cluster-enabled yes/cluster-enabled yes/g' /etc/redis/6379.conf
[root@redis01 ~]# sed -i 's/# cluster-config-file nodes-6379.conf/cluster-config-file nodes-6379.conf/g' /etc/redis/6379.conf
[root@redis01 ~]# sed -i 's/# cluster-node-timeout 15000/cluster-node-timeout 5000/g' /etc/redis/6379.conf

#修改redis6380
[root@redis01 ~]# sed -i 's/# cluster-enabled yes/cluster-enabled yes/g' /etc/redis/6380.conf
[root@redis01 ~]# sed -i 's/# cluster-config-file nodes-6379.conf/cluster-config-file nodes-6380.conf/g' /etc/redis/6380.conf
[root@redis01 ~]# sed -i 's/# cluster-node-timeout 15000/cluster-node-timeout 5000/g' /etc/redis/6380.conf

#重启redis服务
[root@redis01 ~]# service redis_6379 restart 
Stopping ...
Redis stopped
Starting Redis server...
[root@redis01 ~]# service redis_6380 restart
Stopping ...
Redis stopped
Starting Redis server...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装集群需要的组件&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum -y  install zlib ruby rubygems rubygems-devel
gem install redis  --version 3.0.4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置集群&lt;/h2&gt;
&lt;p&gt;在redis源码目录下有一个&lt;code&gt;src/redis-trib.rd&lt;/code&gt;命令，用来创建redis集群，只需要在三台中的一台撒谎给你操作即可&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cd redis-3.0.4

#创建集群
./src/redis-trib.rb create --replicas 1 192.168.122.217:6379 192.168.122.217:6380 192.168.122.132:6379 192.168.122.132:6380 192.168.122.112:6379 192.168.122.112:6380
&amp;gt;&amp;gt;&amp;gt; Creating cluster
Connecting to node 192.168.122.217:6379: OK
Connecting to node 192.168.122.217:6380: OK
Connecting to node 192.168.122.132:6379: OK
Connecting to node 192.168.122.132:6380: OK
Connecting to node 192.168.122.112:6379: OK
Connecting to node 192.168.122.112:6380: OK
&amp;gt;&amp;gt;&amp;gt; Performing hash slots allocation on 6 nodes...
Using 3 masters:
192.168.122.112:6379
192.168.122.217:6379
192.168.122.132:6379
Adding replica 192.168.122.217:6380 to 192.168.122.112:6379
Adding replica 192.168.122.112:6380 to 192.168.122.217:6379
Adding replica 192.168.122.132:6380 to 192.168.122.132:6379
M: 6343d46d255182e0e116dfad536028702e776251 192.168.122.217:6379
   slots:5461-10922 (5462 slots) master
S: 28cca88d789477a1bae4abfbe20c187bb54583cf 192.168.122.217:6380
   replicates c18bae19c335c2bfad4c4628d562bd937bd608ec
M: 3bde122a2d531d562f932657a67ae0461479cbd1 192.168.122.132:6379
   slots:10923-16383 (5461 slots) master
S: 5f25c4e5e0891530e54570f51cf9de8015c08d9e 192.168.122.132:6380
   replicates 3bde122a2d531d562f932657a67ae0461479cbd1
M: c18bae19c335c2bfad4c4628d562bd937bd608ec 192.168.122.112:6379
   slots:0-5460 (5461 slots) master
S: c67e2adf957cb6f123103c677fb998135ca61a5b 192.168.122.112:6380
   replicates 6343d46d255182e0e116dfad536028702e776251
Can I set the above configuration? (type 'yes' to accept): yes  #确认集群节点信息
&amp;gt;&amp;gt;&amp;gt; Nodes configuration updated
&amp;gt;&amp;gt;&amp;gt; Assign a different config epoch to each node
&amp;gt;&amp;gt;&amp;gt; Sending CLUSTER MEET messages to join the cluster
Waiting for the cluster to join....
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 192.168.122.217:6379)
M: 6343d46d255182e0e116dfad536028702e776251 192.168.122.217:6379
   slots:5461-10922 (5462 slots) master
M: 28cca88d789477a1bae4abfbe20c187bb54583cf 192.168.122.217:6380
   slots: (0 slots) master
   replicates c18bae19c335c2bfad4c4628d562bd937bd608ec
M: 3bde122a2d531d562f932657a67ae0461479cbd1 192.168.122.132:6379
   slots:10923-16383 (5461 slots) master
M: 5f25c4e5e0891530e54570f51cf9de8015c08d9e 192.168.122.132:6380
   slots: (0 slots) master
   replicates 3bde122a2d531d562f932657a67ae0461479cbd1
M: c18bae19c335c2bfad4c4628d562bd937bd608ec 192.168.122.112:6379
   slots:0-5460 (5461 slots) master
M: c67e2adf957cb6f123103c677fb998135ca61a5b 192.168.122.112:6380
   slots: (0 slots) master
   replicates 6343d46d255182e0e116dfad536028702e776251
[OK] All nodes agree about slots configuration.
&amp;gt;&amp;gt;&amp;gt; Check for open slots...
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.  #表示集群创建完成
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;查看集群节点&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;/usr/local/redis6379/bin/redis-cli -c -p 6379   #登录集群

127.0.0.1:6379&amp;gt; cluster nodes       #查看集群节点信息
6343d46d255182e0e116dfad536028702e776251 192.168.122.217:6379 myself,master - 0 0 1 connected 5461-10922
c18bae19c335c2bfad4c4628d562bd937bd608ec 192.168.122.112:6379 master - 0 1478586739489 5 connected 0-5460
c67e2adf957cb6f123103c677fb998135ca61a5b 192.168.122.112:6380 slave 6343d46d255182e0e116dfad536028702e776251 0 1478586740491 6 connected
28cca88d789477a1bae4abfbe20c187bb54583cf 192.168.122.217:6380 slave c18bae19c335c2bfad4c4628d562bd937bd608ec 0 1478586739991 5 connected
3bde122a2d531d562f932657a67ae0461479cbd1 192.168.122.132:6379 master - 0 1478586739489 3 connected 10923-16383
5f25c4e5e0891530e54570f51cf9de8015c08d9e 192.168.122.132:6380 slave 3bde122a2d531d562f932657a67ae0461479cbd1 0 1478586740491 4 connected


127.0.0.1:6379&amp;gt; cluster info    #查看集群信息
cluster_state:ok
cluster_slots_assigned:16384
cluster_slots_ok:16384
cluster_slots_pfail:0
cluster_slots_fail:0
cluster_known_nodes:6
cluster_size:3
cluster_current_epoch:6
cluster_my_epoch:1
cluster_stats_messages_sent:10661
cluster_stats_messages_received:10661
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;检查集群节点状态&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;./src/redis-trib.rb check 192.168.122.217:6379

Connecting to node 192.168.122.217:6379: OK
Connecting to node 192.168.122.112:6379: OK
Connecting to node 192.168.122.112:6380: OK
Connecting to node 192.168.122.217:6380: OK
Connecting to node 192.168.122.132:6379: OK
Connecting to node 192.168.122.132:6380: OK
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 192.168.122.217:6379)
M: 6343d46d255182e0e116dfad536028702e776251 192.168.122.217:6379
   slots:5461-10922 (5462 slots) master
   1 additional replica(s)
M: c18bae19c335c2bfad4c4628d562bd937bd608ec 192.168.122.112:6379
   slots:0-5460 (5461 slots) master
   1 additional replica(s)
S: c67e2adf957cb6f123103c677fb998135ca61a5b 192.168.122.112:6380
   slots: (0 slots) slave
   replicates 6343d46d255182e0e116dfad536028702e776251
S: 28cca88d789477a1bae4abfbe20c187bb54583cf 192.168.122.217:6380
   slots: (0 slots) slave
   replicates c18bae19c335c2bfad4c4628d562bd937bd608ec
M: 3bde122a2d531d562f932657a67ae0461479cbd1 192.168.122.132:6379
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: 5f25c4e5e0891530e54570f51cf9de8015c08d9e 192.168.122.132:6380
   slots: (0 slots) slave
   replicates 3bde122a2d531d562f932657a67ae0461479cbd1
[OK] All nodes agree about slots configuration.
&amp;gt;&amp;gt;&amp;gt; Check for open slots...
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;集群节点的增删以及分片(数据槽slot重新分配)&lt;/h1&gt;
&lt;h2&gt;删除集群节点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1.删除从节点&lt;/strong&gt;
删除从节点直接删除就可以
删除命令：redis-trib.rb del-node "del_slave_ip:port" "slave_node_id"
比如&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;./src/redis-trib.rb del-node 192.168.122.112:6380 c67e2adf957cb6f123103c677fb998135ca61a5b  #删除192.168.122.112:6380这个从节点
&amp;gt;&amp;gt;&amp;gt; Removing node c67e2adf957cb6f123103c677fb998135ca61a5b from cluster 192.168.122.112:6380
Connecting to node 192.168.122.112:6380: OK
Connecting to node 192.168.122.217:6380: OK
Connecting to node 192.168.122.217:6379: OK
Connecting to node 192.168.122.132:6379: OK
Connecting to node 192.168.122.112:6379: OK
Connecting to node 192.168.122.132:6380: OK
&amp;gt;&amp;gt;&amp;gt; Sending CLUSTER FORGET messages to the cluster...
&amp;gt;&amp;gt;&amp;gt; SHUTDOWN the node.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2.删除主节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主节点的删除分三步
- 1.首先需要删除对应主节点的从节点，参考&lt;code&gt;删除从节点&lt;/code&gt;
- 2.移除主节点上的数据槽(分配的slot)
    &lt;code&gt;bash
    ./src/redis-trib.rb reshard 192.168.122.217:6379
    ... #省略号表示省略无关内容
    How many slots do you want to move (from 1 to 16384)? 16384         #被移除的数据槽,可根据cluster nodes 查看
    ...
    What is the receiving node ID? 28cca88d789477a1bae4abfbe20c187bb54583cf         #接收被删除节点数据的主节点
    ...
    Source node #1:6343d46d255182e0e116dfad536028702e776251 #被删除主节点的node-id  
    Source node #2:done         #结束标志，开始执行
    ...
    Do you want to proceed with the proposed reshard plan (yes/no)? yes #删除要被删除节点的slot后，重新分配
    [root@redis01 redis-3.0.4]# /usr/local/redis6379/bin/redis-cli -c -p 6379 cluster nodes     #查看节点信息
    28cca88d789477a1bae4abfbe20c187bb54583cf 192.168.122.217:6380 master - 0 1478593786321 7 connected 0-10922
    6343d46d255182e0e116dfad536028702e776251 192.168.122.217:6379 myself,master - 0 0 1 connected       #此时要被删除的主节点的slot信息没有了
    c18bae19c335c2bfad4c4628d562bd937bd608ec 192.168.122.112:6379 slave 28cca88d789477a1bae4abfbe20c187bb54583cf 0 1478593786823 7 connected
    3bde122a2d531d562f932657a67ae0461479cbd1 192.168.122.132:6379 master - 0 1478593785820 3 connected 10923-16383
    5f25c4e5e0891530e54570f51cf9de8015c08d9e 192.168.122.132:6380 slave 3bde122a2d531d562f932657a67ae0461479cbd1 0 1478593787322 4 connected&lt;/code&gt;
- 3.删除主节点,参考&lt;code&gt;删除从节点&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;增加集群节点&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;增加主集群节点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将上面测试删除节点时删除的节点从新加入集群&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;./src/redis-trib.rb add-node 192.168.122.217:6379 192.168.122.217:6380
&amp;gt;&amp;gt;&amp;gt; Adding node 192.168.122.217:6379 to cluster 192.168.122.217:6380
Connecting to node 192.168.122.217:6380: OK
Connecting to node 192.168.122.132:6379: OK
Connecting to node 192.168.122.112:6379: OK
Connecting to node 192.168.122.132:6380: OK
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 192.168.122.217:6380)
M: 28cca88d789477a1bae4abfbe20c187bb54583cf 192.168.122.217:6380
   slots:0-10922 (10923 slots) master
   1 additional replica(s)
M: 3bde122a2d531d562f932657a67ae0461479cbd1 192.168.122.132:6379
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: c18bae19c335c2bfad4c4628d562bd937bd608ec 192.168.122.112:6379
   slots: (0 slots) slave
   replicates 28cca88d789477a1bae4abfbe20c187bb54583cf
S: 5f25c4e5e0891530e54570f51cf9de8015c08d9e 192.168.122.132:6380
   slots: (0 slots) slave
   replicates 3bde122a2d531d562f932657a67ae0461479cbd1
[OK] All nodes agree about slots configuration.
&amp;gt;&amp;gt;&amp;gt; Check for open slots...
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.
Connecting to node 192.168.122.217:6379: OK
[ERR] Node 192.168.122.217:6379 is not empty. Either the node already knows other nodes (check with CLUSTER NODES) or contains some key in database 0.  #此处报错原因是因为前面测试删除节点，不是使用全新安装的redis服务,相关目录还保留残留文件,需手动删除
#以下是解决办法
[root@redis01 redis-3.0.4]# cd /data/redis/6379/
[root@redis01 6379]# rm -rf nodes-6379.conf     #删除原有节点信息文件
[root@redis01 redis-3.0.4]# service redis_6379 restart  #重启redis服务
Stopping ...
Waiting for Redis to shutdown ...
Redis stopped
Starting Redis server...

##重新添加
[root@redis01 redis-3.0.4]# ./src/redis-trib.rb add-node 192.168.122.217:6379 192.168.122.217:6380  #重新添加新节点
&amp;gt;&amp;gt;&amp;gt; Adding node 192.168.122.217:6379 to cluster 192.168.122.217:6380
Connecting to node 192.168.122.217:6380: OK
Connecting to node 192.168.122.132:6379: OK
Connecting to node 192.168.122.112:6379: OK
Connecting to node 192.168.122.132:6380: OK
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 192.168.122.217:6380)
M: 28cca88d789477a1bae4abfbe20c187bb54583cf 192.168.122.217:6380
   slots:0-10922 (10923 slots) master
   1 additional replica(s)
M: 3bde122a2d531d562f932657a67ae0461479cbd1 192.168.122.132:6379
   slots:10923-16383 (5461 slots) master
   1 additional replica(s)
S: c18bae19c335c2bfad4c4628d562bd937bd608ec 192.168.122.112:6379
   slots: (0 slots) slave
   replicates 28cca88d789477a1bae4abfbe20c187bb54583cf
S: 5f25c4e5e0891530e54570f51cf9de8015c08d9e 192.168.122.132:6380
   slots: (0 slots) slave
   replicates 3bde122a2d531d562f932657a67ae0461479cbd1
[OK] All nodes agree about slots configuration.
&amp;gt;&amp;gt;&amp;gt; Check for open slots...
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.
Connecting to node 192.168.122.217:6379: OK
&amp;gt;&amp;gt;&amp;gt; Send CLUSTER MEET to node 192.168.122.217:6379 to make it join the cluster.
[OK] New node added correctly.


[root@redis01 redis-3.0.4]# /usr/local/redis6379/bin/redis-cli -c -p 6380 cluster nodes            #查看集群节点信息
3bde122a2d531d562f932657a67ae0461479cbd1 192.168.122.132:6379 master - 0 1478594694846 3 connected 10923-16383
c18bae19c335c2bfad4c4628d562bd937bd608ec 192.168.122.112:6379 slave 28cca88d789477a1bae4abfbe20c187bb54583cf 0 1478594693844 7 connected
e0fab3c8d591f84535c46841c16c9c287c6d73e2 192.168.122.217:6379 master - 0 1478594692841 0 connected  #发现添加成功
28cca88d789477a1bae4abfbe20c187bb54583cf 192.168.122.217:6380 myself,master - 0 0 7 connected 0-10922
5f25c4e5e0891530e54570f51cf9de8015c08d9e 192.168.122.132:6380 slave 3bde122a2d531d562f932657a67ae0461479cbd1 0 1478594693342 4 connected
#添加成功的节点并没有真正在集群中使用，集群的slot槽需要重新分配


[root@redis01 redis-3.0.4]# ./src/redis-trib.rb reshard 192.168.122.217:6379
Connecting to node 192.168.122.217:6379: OK
Connecting to node 192.168.122.217:6380: OK
Connecting to node 192.168.122.112:6379: OK
Connecting to node 192.168.122.132:6380: OK
Connecting to node 192.168.122.132:6379: OK
&amp;gt;&amp;gt;&amp;gt; Performing Cluster Check (using node 192.168.122.217:6379)
......      #s省略号表示省略无关信息
&amp;gt;&amp;gt;&amp;gt; Check slots coverage...
[OK] All 16384 slots covered.
How many slots do you want to move (from 1 to 16384)? 5600          #设置solt，设置每个节点的solt区间范围
What is the receiving node ID? e0fab3c8d591f84535c46841c16c9c287c6d73e2 #此处填新添加的节点的nodeID
Please enter all the source node IDs.
  Type 'all' to use all the nodes as source nodes for the hash slots.
  Type 'done' once you entered all the source nodes IDs.
Source node #1:all #表示全部重新分配
....
Do you want to proceed with the proposed reshard plan (yes/no)? yes     #确认重启分配


[root@redis01 redis-3.0.4]# /usr/local/redis6379/bin/redis-cli -c -p 6380 cluster nodes #查看节点信息，发现新添加的主节点也有slot
3bde122a2d531d562f932657a67ae0461479cbd1 192.168.122.132:6379 master - 0 1478595533541 9 connected 1914-5599
c18bae19c335c2bfad4c4628d562bd937bd608ec 192.168.122.112:6379 slave 28cca88d789477a1bae4abfbe20c187bb54583cf 0 1478595533041 10 connected
e0fab3c8d591f84535c46841c16c9c287c6d73e2 192.168.122.217:6379 master - 0 1478595533541 8 connected 9286-16383
28cca88d789477a1bae4abfbe20c187bb54583cf 192.168.122.217:6380 myself,master - 0 0 10 connected 0-1913 5600-9285
5f25c4e5e0891530e54570f51cf9de8015c08d9e 192.168.122.132:6380 slave 3bde122a2d531d562f932657a67ae0461479cbd1 0 1478595532539 9 connected
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;增加从集群节点&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#添加从节点
命令参考:redis-trib.rb add-node --slave --master-id &amp;quot;master_node_id&amp;quot; &amp;quot;new_slave&amp;quot; &amp;quot;集群已有任一集群节点&amp;quot;
[root@redis01 redis-3.0.4]# redis-trib.rb add-node --slave --master-id e0fab3c8d591f84535c46841c16c9c287c6d73e2 192.168.122.112:6380 192.168.122.132:6380

[root@redis01 redis-3.0.4]# /usr/local/redis6379/bin/redis-cli -c -p 6380 cluster nodes     #查看节点信息
c67e2adf957cb6f123103c677fb998135ca61a5b :0 slave,noaddr e0fab3c8d591f84535c46841c16c9c287c6d73e2 1478596060068 1478596057963 8 disconnected
3bde122a2d531d562f932657a67ae0461479cbd1 192.168.122.132:6379 master - 0 1478596780704 9 connected 1914-5599
400667d62c9dd1581f5c5161d9d52b91e1ee137d 192.168.122.112:6380 slave e0fab3c8d591f84535c46841c16c9c287c6d73e2 0 1478596781206 8 connected    #添加从节点成功
c18bae19c335c2bfad4c4628d562bd937bd608ec 192.168.122.112:6379 slave 28cca88d789477a1bae4abfbe20c187bb54583cf 0 1478596781706 10 connected
e0fab3c8d591f84535c46841c16c9c287c6d73e2 192.168.122.217:6379 master - 0 1478596780203 8 connected 9286-16383
28cca88d789477a1bae4abfbe20c187bb54583cf 192.168.122.217:6380 myself,master - 0 0 10 connected 0-1913 5600-9285
5f25c4e5e0891530e54570f51cf9de8015c08d9e 192.168.122.132:6380 slave 3bde122a2d531d562f932657a67ae0461479cbd1 0 1478596780203 9 connected
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;设置集群密码&lt;/h2&gt;
&lt;p&gt;如果要提高集群的安全性，可以使用如下命令设置密码&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;config set masterauth abc  
config set requirepass abc  
config rewrite 
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>nginx+keepalived高可用配置</title><description>&lt;h4&gt;服务器IP:&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;    server_ip
        172.16.88.179
        172.16.88.180
    vip
        172.16.88.178
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;软件版本及下载&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;</description><html_content>&lt;h4&gt;服务器IP:&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;    server_ip
        172.16.88.179
        172.16.88.180
    vip
        172.16.88.178
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;软件版本及下载&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;    http://tengine.taobao.org/download/tengine-2.1.2.tar.gz
    http://www.keepalived.org/software/keepalived-1.3.2.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h4&gt;nginx安装&lt;/h4&gt;
&lt;p&gt;参加&lt;a href="/linux/nginx-install-by-source-code"&gt;nginx的安装文档&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;keepalived安装&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;tar zxvf keepalived-1.3.2.tar.gz
cd keepalived-1.3.2
./configure --sysconf=/etc
make &amp;amp;&amp;amp; make install 
ln -s /usr/local/sbin/keepalived /sbin/keepalived
cp  keepalived/etc/init.d/keepalived /etc/init.d/
chkconfig --add keepalived
chkconfig keepalived on
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;配置nginx+keepalived&lt;/h4&gt;
&lt;h5&gt;在172.16.88.179上&lt;/h5&gt;
&lt;p&gt;创建nginx服务监测脚本&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;vim /etc/keepalived/chk_nginx.sh
#!/bin/bash
# description:
# 查看nginx进程是否存在，如果不存在则启动nginx
# 如果启动失败，则停止keepalived
status=$(ps -C nginx --no-heading|wc -l)
if [ &amp;quot;${status}&amp;quot; = &amp;quot;0&amp;quot; ]; then
        /usr/sbin/nginx
        status2=$(ps -C nginx --no-heading|wc -l)
        if [ &amp;quot;${status2}&amp;quot; = &amp;quot;0&amp;quot;  ]; then
                service keepalived stop
        fi
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加可执行权限&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;chmod +x /etc/keepalived/chk_nginx.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;配置keepalived.conf&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;mv /etc/keepalived/keepalived.conf{,.bak}

vim /etc/keepalived/keepalived.conf
#主配置文件
#定义监控脚本
vrrp_script chk_nginx {
        script &amp;quot;/etc/keepalived/chk_nginx.sh&amp;quot;   #脚本位置
        interval 2  #检查时间间隔,单位秒
        weight 2    #定义失败时对应的权重减少值
        fall 3      #定义多少次失败则判定失败(检测3次失败,就认为失败)
        rise 2      #判定成功检测次数(检测二次成功,就认为在线)
}


vrrp_instance VI_1 {
    state MASTER    #角色
    interface eth0  #监听的网卡
    virtual_router_id 51    #虚拟路由标志
    priority 100    #优先级
    advert_int 1    #检查时间间隔，单位秒
    authentication {
        auth_type PASS  #验证类型
        auth_pass 1111  #验证密码
    }

    track_script {
        chk_nginx
    }

    virtual_ipaddress {
        172.16.88.178   #vip
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;拷贝配置文件到172.16.88.180&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;scp /etc/keepalived/keepalived.conf root@172.16.88.180:/etc/keepalived/
scp /etc/keepalived/chk_nginx.sh root@172.16.88.180:/etc/keepalived/
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;在172.16.88.180上&lt;/h5&gt;
&lt;p&gt;修改从172.16.88.179拷贝过来的配置文件/etc/keepalived/keepalived.conf&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;vim /etc/keepalived/keepalived.conf

#主配置文件
global_defs {
   notification_email {     #设置管理员的email邮箱信息
     acassen@firewall.loc
     failover@firewall.loc
     sysadmin@firewall.loc
   }
   notification_email_from Alexandre.Cassen@firewall.loc    #通知邮件来源
   smtp_server 127.0.0.1    #设置邮件服务器地址为本地
   smtp_connect_timeout 30  #设置连接超时时间
   router_id LVS_DEVEL      #设置本keepalived的ID名称
   vrrp_skip_check_adv_addr
#   vrrp_strict             ##严格遵守vrrp协议，下面这些功能将会禁止：1.VIP;2.unicast(单播) peers;3.vrrp 版本2的ipv6功能,开启此选项会开启防火墙并DROP所以VIP请求
#   vrrp_garp_interval 0
#   vrrp_gna_interval 0
}

vrrp_script chk_nginx {
        script &amp;quot;/etc/keepalived/chk_nginx.sh&amp;quot;
        interval 2
        weight 2
        fall 3
        rise 2
}


vrrp_instance VI_1 {
    state SLAVE     #修改角色
    interface eth0
    virtual_router_id 51
    priority 90     #修改优先级
    advert_int 1
    authentication {
        auth_type PASS
        auth_pass 1111
    }

    track_script {
        chk_nginx
    }

    virtual_ipaddress {
        172.16.88.178
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;测试&lt;/h4&gt;
&lt;p&gt;启动nginx+keepalived服务(两台均启动)&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;/usr/sbin/ngix  #启动nginx
service keepalived start    #启动keepalived
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在优先级较高的这条查看ip&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;ip addr
eth0:mtu 1500 qdisc pfifo_fast state UP qlen 1000
link/ether 52:54:00:0c:47:79 brd ff:ff:ff:ff:ff:ff
inet 172.16.88.179/23 brd 172.16.89.255 scope global eth0
inet 172.16.88.178/23 scope global secondary eth0   #发现多了一个虚拟ip
inet6 fe80::5054:ff:fe0c:4779/64 scope link 
   valid\_lft forever preferred\_lft forever
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意:此时在优先级低的服务器上是看不到这个虚拟ip的&lt;/p&gt;
&lt;p&gt;模拟master(172.16.88.179)宕机，关闭keepalived&lt;/p&gt;
&lt;p&gt;此时查看ip,发现虚拟IP漂移到SLAVE(172.16.88.180)上了&lt;/p&gt;</html_content></item><item><title>centos搭建本地yum源</title><description>&lt;h2&gt;基础信息&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum源IP:172.10.1.101
测试客户端IP:172.10.1.102
镜像：  CentOS-6.8-x86_64-bin-DVD1.iso
       </description><html_content>&lt;h2&gt;基础信息&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum源IP:172.10.1.101
测试客户端IP:172.10.1.102
镜像：  CentOS-6.8-x86_64-bin-DVD1.iso
        CentOS-6.8-x86_64-bin-DVD2.iso
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;挂在镜像并拷贝数据&lt;/h2&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#挂载DVD1.iso盘
mount -o loop -t iso9660 /dev/cdrom /mnt
\cp -r /mnt/Packages/ /data/www/centos/6/x86_64
cp /mnt/RPM-GPG-KEY-CentOS-* /data/www/centos
#挂载DVD2.iso盘
umount
mount -o loop -t iso9660 /dev/cdrom /mnt
\cp -r /mnt/Packages/ /data/www/centos/6/x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;创建仓库&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;createrepo /data/www/centos/6/x86_64
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;使用nginx代理建立http访问&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1.添加配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;chmod 755 /data/www
#在nginx中添加配置项
        root /data/www;
        # 开启Nginx的目录文件列表
        autoindex on;
        autoindex_exact_size off;
        autoindex_localtime on;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.测试是否访问正常&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;```wp-block-preformatted bash
curl -s http://172.10.1.101/centos/6/x86_64&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;## 在客户端配置使用yum源

```bash
mv /etc/yum.repos.d/Centos-Base.repo{,.bak}    #备份原有yum源
vim Centos-Base.repo    
\[base\]
name=CentOS-6-Base-LAN 
baseurl=http://172.10.1.101/centos/6/$basearch/ 
gpgcheck=1 
gpgkey=http://172.10.1.101/centos/RPM-GPG-KEY-CentOS-6
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行以下命令后即可使用&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum clean all
yum makecache
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>日志收集ELK配置使用</title><description>&lt;h2&gt;软件下载&lt;/h2&gt;
&lt;p&gt;2.3版本官网下载链接以及具体的下载地址&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.17.6-linux-x86_64.tar.gz
wget</description><html_content>&lt;h2&gt;软件下载&lt;/h2&gt;
&lt;p&gt;2.3版本官网下载链接以及具体的下载地址&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.17.6-linux-x86_64.tar.gz
wget https://artifacts.elastic.co/downloads/beats/filebeat/filebeat-7.17.6-linux-x86_64.tar.gz
wget https://artifacts.elastic.co/downloads/kibana/kibana-7.17.6-linux-x86_64.tar.gz
wget https://artifacts.elastic.co/downloads/logstash/logstash-7.17.6-linux-x86_64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;elasticsearch安装&lt;/h2&gt;
&lt;!--more--&gt;
&lt;ul&gt;
&lt;li&gt;1.安装 &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;tar -zxvf elasticsearch-7.17.6-linux-x86_64.tar.gz  -C /data/
cd /data/elasticsearch-7.17.6

useradd -M efk -s /bin/false 

# 限制一个进程可以拥有的VMA(虚拟内存区域)的数量要超过262144，不然elasticsearch会报max virtual memory areas vm.max_map_count [65535] is too low, increase to at least [262144]
echo &amp;quot;vm.max_map_count = 655350&amp;quot; &amp;gt;&amp;gt; /etc/sysctl.conf
sysctl -p

解普通用户打开文件句柄的限制
vi /etc/security/limits.conf
* soft nofile 65536
* hard nofile 65536
* soft nproc 65536
* hard nproc 65536
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;配置config/elasticsearch.yml
创建日志和数据目录&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mkdir -p /data/efk/elasticsearch
mkdir -p /data/logs/efk
chown -R efk. /data/efk/elasticsearch
chown -R efk. /data/logs/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;各节点配置&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;172.16.90.210&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 集群名字
cluster.name: my-application

# 节点名字
node.name: 172.16.90.210

# 日志位置
path.logs: /data/logs/elasticsearch

# 数据位置
path.data: /data/efk/elasticsearch

# 本节点访问IP
network.host: 172.16.90.210

# 本节点访问
http.port: 9200

# 节点运输端口
transport.port: 9300

# 集群中其他主机的列表
discovery.seed_hosts: [&amp;quot;172.16.90.210&amp;quot;, &amp;quot;172.16.90.211&amp;quot;, &amp;quot;172.16.90.212&amp;quot;]

# 首次启动全新的Elasticsearch集群时，在第一次选举中便对其票数进行计数的master节点的集合
cluster.initial_master_nodes: [&amp;quot;172.16.90.210&amp;quot;, &amp;quot;172.16.90.211&amp;quot;, &amp;quot;172.16.90.212&amp;quot;]

xpack.security.enabled: false
#xpack.security.transport.ssl.enabled: true

# 启用跨域资源共享
#http.cors.enabled: true
#http.cors.allow-origin: &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;172.16.90.211&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 集群名字
cluster.name: my-application

# 节点名字
node.name: 172.16.90.211

# 日志位置
path.logs: /data/logs/elasticsearch

# 数据位置
path.data: /data/efk/elasticsearch

# 本节点访问IP
network.host: 172.16.90.211

# 本节点访问
http.port: 9200

# 节点运输端口
transport.port: 9300

# 集群中其他主机的列表
discovery.seed_hosts: [&amp;quot;172.16.90.210&amp;quot;, &amp;quot;172.16.90.211&amp;quot;, &amp;quot;172.16.90.212&amp;quot;]

# 首次启动全新的Elasticsearch集群时，在第一次选举中便对其票数进行计数的master节点的集合
cluster.initial_master_nodes: [&amp;quot;172.16.90.210&amp;quot;, &amp;quot;172.16.90.211&amp;quot;, &amp;quot;172.16.90.212&amp;quot;]

xpack.security.enabled: false
#xpack.security.transport.ssl.enabled: true

# 启用跨域资源共享
#http.cors.enabled: true
#http.cors.allow-origin: &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;172.16.90.212&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 集群名字
cluster.name: my-application

# 节点名字
node.name: 172.16.90.212

# 日志位置
path.logs: /data/logs/elasticsearch

# 数据位置
path.data: /data/efk/elasticsearch

# 本节点访问IP
network.host: 172.16.90.212

# 本节点访问
http.port: 9200

# 节点运输端口
transport.port: 9300

# 集群中其他主机的列表
discovery.seed_hosts: [&amp;quot;172.16.90.210&amp;quot;, &amp;quot;172.16.90.211&amp;quot;, &amp;quot;172.16.90.212&amp;quot;]

# 首次启动全新的Elasticsearch集群时，在第一次选举中便对其票数进行计数的master节点的集合
cluster.initial_master_nodes: [&amp;quot;172.16.90.210&amp;quot;, &amp;quot;172.16.90.211&amp;quot;, &amp;quot;172.16.90.212&amp;quot;]

xpack.security.enabled: false
#xpack.security.transport.ssl.enabled: true

# 启用跨域资源共享,安装head插件时必须开启此参数
http.cors.enabled: true
http.cors.allow-origin: &amp;quot;*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.启动elasticsearch&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sudo -u efk /data/elasticsearch-7.17.6/bin/elasticsearch &amp;amp;   #使用www身份启动
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;插件安装&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#需要安装node环境
curl -fsSL https://rpm.nodesource.com/setup_lts.x | bash -
yum install -y nodejs



#安装head插件,elasticsearch-head放置在任意目录。不要放在elasticsearch的plugin或module目录下
https://github.com/mobz/elasticsearch-head
git clone https://github.com/mobz/elasticsearch-head.git
npm install -g grunt-cli
npm install
grunt server

#访问
http://172.16.90.210:9100/


#npm install过程中如果有报错phantomjs不存在，则执行，
cd /usr/local/share
wget https://bitbucket.org/ariya/phantomjs/downloads/phantomjs-2.1.1-linux-x86_64.tar.bz2
 tar xjf phantomjs-2.1.1-linux-x86_64.tar.bz2
ln -s /usr/local/share/phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/local/share/phantomjs
ln -s /usr/local/share/phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/local/bin/phantomjs
ln -s /usr/local/share/phantomjs-2.1.1-linux-x86_64/bin/phantomjs /usr/bin/phantomjs
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;4.访问测试&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;http://172.16.90.210:9200
http://172.16.90.210:9200/_plugiin/head
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;kibana安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;tar -zxvf kibana-7.17.6-linux-x86_64.tar.gz -C /data/
chown -R efk:efk /data/kibana-7.17.6/
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.配置config/kibana.yaml&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 本节点访问端口
server.port: 5601

# 本节点IP
server.host: &amp;quot;172.16.90.210&amp;quot;

# 本节点名字
server.name: &amp;quot;172.16.90.210&amp;quot;

# elasticsearch集群IP
elasticsearch.hosts: [&amp;quot;http://172.16.90.210:9200&amp;quot;,
                      &amp;quot;http://172.16.90.211:9200&amp;quot;,
                      &amp;quot;http://172.16.90.212:9200&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;启动kibana&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sudo -u efk /data/kibana-7.17.6-linux-x86_64/bin/kibana &amp;amp; &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装filebeat&lt;/h2&gt;
&lt;h3&gt;filebeat安装在需要被收集日志的服务器上&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;tar -zxvf filebeat-7.17.6-linux-x86_64.tar.gz -C /data/filebeat-7.17.6
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;ol&gt;
&lt;li&gt;配置filebeat.yml&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 文件输入
filebeat.inputs:
  # 文件输入类型
  - type: log
    # 开启加载
    enabled: true
    # 文件位置
    paths:
      - /var/log/nginx/access.log
    # 自定义参数
    fields:
      type: nginx_access  # 类型是nginx_access,和上面fields.type是一致的
# 输出类型有Elasticsearch，Logstash，Kafka，Redis，File，Console，ElasticCloud，Changetheoutputcodec（最常用的就是Elasticsearch，Logstash）
# 输出至elasticsearch
output.elasticsearch:
  # elasticsearch集群
  hosts: [&amp;quot;http://172.16.90.210:9200&amp;quot;,
          &amp;quot;http://172.16.90.211:9200&amp;quot;,
          &amp;quot;http://172.16.90.212:9200&amp;quot;]

  # 索引配置
  indices:
    # 索引名
    - index: &amp;quot;nginx_access_%{+yyy.MM}&amp;quot;
      # 当类型是nginx_access时使用此索引
      when.equals:
        fields.type: &amp;quot;nginx_access&amp;quot;

# 关闭自带模板
setup.template.enabled: false

# 开启日志记录
logging.to_files: true
# 日志等级
logging.level: info
# 日志文件
logging.files:
  # 日志位置
  path: /opt/logs/filebeat/
  # 日志名字
  name: filebeat
  # 日志轮转期限，必须要2~1024
  keepfiles: 7
  # 日志轮转权限
  permissions: 0600
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;type: log #input类型为log,支持的类型有Multilinemessages，Azureeventhub，CloudFoundry，Container，Docker，GooglePub/Sub，HTTPJSON，Kafka，Log，MQTT，NetFlow，Office 365 Management Activity API，Redis，s3，Stdin，Syslog，TCP，UDP（最常用的就是Log）
enable: true #表示是该log类型配置生效
paths：     #指定要监控的日志，目前按照Go语言的glob函数处理。没有对配置目录做递归处理，比如配置的如果是：
- /var/log/* /*.log  #则只会去/var/log目录的所有子目录中寻找以&amp;quot;.log&amp;quot;结尾的文件，而不会寻找/var/log目录下以&amp;quot;.log&amp;quot;结尾的文件。
recursive_glob.enabled: #启用全局递归模式，例如/foo/**包括/foo, /foo/*, /foo/*/*
encoding：#指定被监控的文件的编码类型，使用plain和utf-8都是可以处理中文日志的
exclude_lines: ['^DBG'] #不包含匹配正则的行
include_lines: ['^ERR', '^WARN']  #包含匹配正则的行
harvester_buffer_size: 16384 #每个harvester在获取文件时使用的缓冲区的字节大小
max_bytes: 10485760 #单个日志消息可以拥有的最大字节数。max_bytes之后的所有字节都被丢弃而不发送。默认值为10MB (10485760)
exclude_files: ['.gz$']  #用于匹配希望Filebeat忽略的文件的正则表达式列表
ingore_older: 0 #默认为0，表示禁用，可以配置2h，2m等，注意ignore_older必须大于close_inactive的值.表示忽略超过设置值未更新的
文件或者文件从来没有被harvester收集
close_* #close_ *配置选项用于在特定标准或时间之后关闭harvester。 关闭harvester意味着关闭文件处理程序。 如果在harvester关闭
后文件被更新，则在scan_frequency过后，文件将被重新拾取。 但是，如果在harvester关闭时移动或删除文件，Filebeat将无法再次接收文件
，并且harvester未读取的任何数据都将丢失。
close_inactive  #启动选项时，如果在制定时间没有被读取，将关闭文件句柄
读取的最后一条日志定义为下一次读取的起始点，而不是基于文件的修改时间
如果关闭的文件发生变化，一个新的harverster将在scan_frequency运行后被启动
建议至少设置一个大于读取日志频率的值，配置多个prospector来实现针对不同更新速度的日志文件
使用内部时间戳机制，来反映记录日志的读取，每次读取到最后一行日志时开始倒计时使用2h 5m 来表示
close_rename #当选项启动，如果文件被重命名和移动，filebeat关闭文件的处理读取
close_removed #当选项启动，文件被删除时，filebeat关闭文件的处理读取这个选项启动后，必须启动clean_removed
close_eof #适合只写一次日志的文件，然后filebeat关闭文件的处理读取
close_timeout #当选项启动时，filebeat会给每个harvester设置预定义时间，不管这个文件是否被读取，达到设定时间后，将被关闭
close_timeout 不能等于ignore_older,会导致文件更新时，不会被读取如果output一直没有输出日志事件，这个timeout是不会被启动的，
至少要要有一个事件发送，然后haverter将被关闭
设置0 表示不启动
clean_inactived #从注册表文件中删除先前收获的文件的状态
设置必须大于ignore_older+scan_frequency，以确保在文件仍在收集时没有删除任何状态
配置选项有助于减小注册表文件的大小，特别是如果每天都生成大量的新文件
此配置选项也可用于防止在Linux上重用inode的Filebeat问题
clean_removed #启动选项后，如果文件在磁盘上找不到，将从注册表中清除filebeat
如果关闭close removed 必须关闭clean removed
scan_frequency #prospector检查指定用于收获的路径中的新文件的频率,默认10s
tail_files：#如果设置为true，Filebeat从文件尾开始监控文件新增内容，把新增的每一行文件作为一个事件依次发送，
而不是从文件开始处重新发送所有内容。
symlinks：#符号链接选项允许Filebeat除常规文件外,可以收集符号链接。收集符号链接时，即使报告了符号链接的路径，
Filebeat也会打开并读取原始文件。
backoff： #backoff选项指定Filebeat如何积极地抓取新文件进行更新。默认1s，backoff选项定义Filebeat在达到EOF之后
再次检查文件之间等待的时间。
max_backoff： #在达到EOF之后再次检查文件之前Filebeat等待的最长时间
backoff_factor： #指定backoff尝试等待时间几次，默认是2
harvester_limit：#harvester_limit选项限制一个prospector并行启动的harvester数量，直接影响文件打开数
tags #列表中添加标签，用过过滤，例如：tags: [&amp;quot;json&amp;quot;]
fields #可选字段，选择额外的字段进行输出可以是标量值，元组，字典等嵌套类型
默认在sub-dictionary位置
filebeat.inputs:
fields:
app_id: query_engine_12
fields_under_root #如果值为ture，那么fields存储在输出文档的顶级位置
multiline.pattern #必须匹配的regexp模式
multiline.negate #定义上面的模式匹配条件的动作是 否定的，默认是false
假如模式匹配条件'^b'，默认是false模式，表示讲按照模式匹配进行匹配 将不是以b开头的日志行进行合并
如果是true，表示将不以b开头的日志行进行合并
multiline.match # 指定Filebeat如何将匹配行组合成事件,在之前或者之后，取决于上面所指定的negate
multiline.max_lines #可以组合成一个事件的最大行数，超过将丢弃，默认500
multiline.timeout #定义超时时间，如果开始一个新的事件在超时时间内没有发现匹配，也将发送日志，默认是5s
max_procs #设置可以同时执行的最大CPU数。默认值为系统中可用的逻辑CPU的数量。
name #为该filebeat指定名字，默认为主机的hostname
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装logstash&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;tar zxf logstash-1.5.6.tar.gz -C /usr/local/
#patterns目录里存放匹配的配置文件，pattern文件具体位置
cd /usr/local/logstash-1.5.6/vendor/bundle/jruby/1.9/gems/logstash-patterns-core-2.0.5/patterns/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;logstash搜集tomcat日志&lt;/h2&gt;
&lt;p&gt;参考logstash搜集tomcat日志配置样例:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#收集tomcat日志
input {
    file {
        codec =&amp;gt; multiline {
                         pattern =&amp;gt; &amp;quot;^\\s&amp;quot;
                         what =&amp;gt; &amp;quot;previous&amp;quot;
                }
        path =&amp;gt; &amp;quot;/data/weblogs/tomcat_test/tomcat01-service-test.log&amp;quot;
                start_position =&amp;gt; &amp;quot;beginning&amp;quot;
    }
}
filter {
  grok {
        patterns_dir =&amp;gt; &amp;quot;/usr/local/logstash-1.5.6/vendor/bundle/jruby/1.9/gems/logstash-patterns-core-0.4.0/patterns/&amp;quot;
        match =&amp;gt; {
            &amp;quot;message&amp;quot; =&amp;gt; &amp;quot;%{TOMCATLOG}&amp;quot;
        }
        add\_field =&amp;gt; \[ &amp;quot;server\_ip&amp;quot;, &amp;quot;10.168.xx.xxx&amp;quot; \]
  }
}
output {
    elasticsearch {
        host =&amp;gt; '121.40.xx.xx'    #elasticsearch服务端的iP 
        index =&amp;gt; 'tomcat01-%{+YYYY.MM.dd}'#如果多台服务器使用同一索引的话，每台服务器填写一样的名字，按时间建立索引%{+YYYY.MM.dd}
        bind_host =&amp;gt; '121.40.yy.yy'#当双网卡时,可通过此参数指定绑定本机ip
    }
}
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>ubuntu系统gcc多版本共存</title><description>&lt;h2&gt;查看系统gcc版本&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;gcc -v
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;添加安装源&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sudo add-apt-repository</description><html_content>&lt;h2&gt;查看系统gcc版本&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;gcc -v
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;添加安装源&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sudo add-apt-repository ppa:ubuntu-toolchain-r/test
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装需要使用的gcc&lt;/h2&gt;
&lt;p&gt;安装不同版本的gcc&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 安装gcc-5
sudo apt-get install gcc-5 gcc-5-multilib g++-5 g++-5-multilib

# 安装gcc-7
sudo apt-get install gcc-7 gcc-7-multilib g++-7 g++-7-multilib

# 安装gcc-9
sudo apt-get install gcc-9 gcc-9-multilib g++-9 g++-9-multilib
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;绑定gcc并设置版本标识&lt;/h2&gt;
&lt;p&gt;设置gcc和g++关联各版本并设置不同的标识&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 50
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 50

sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-7 70
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-7 70

sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-9 90
sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-9 90
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;版本切换&lt;/h2&gt;
&lt;p&gt;执行下面的命令，然后在列表中选择对应的数字可以切换到对应版本的gcc和g++&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sudo update-alternatives --config gcc   #选取对应版本的数字即可进行切换
sudo update-alternatives --config g++
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>apache配置ssl访问</title><description>&lt;p&gt;apache配置ssl的大致方法如下，具体的根据实际情况进行修改，仅供参考&lt;/p&gt;
&lt;h2&gt;修改httpd.conf的配置文件&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim $Apache_path/conf/httpd.conf
#将以下两行的&amp;quot;#&amp;quot;注释去掉
#Include</description><html_content>&lt;p&gt;apache配置ssl的大致方法如下，具体的根据实际情况进行修改，仅供参考&lt;/p&gt;
&lt;h2&gt;修改httpd.conf的配置文件&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim $Apache_path/conf/httpd.conf
#将以下两行的&amp;quot;#&amp;quot;注释去掉
#Include conf/extra/httpd-vhosts.conf
#Include conf/extra/httpd-ssl.conf
修改后：
Include conf/extra/httpd-vhosts.conf
Include conf/extra/httpd-ssl.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h2&gt;配置虚拟主机文件&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim  $Apache_path/conf/httpd-ssl.conf(修改证书文件存放目录)
SSLCertificateFile &amp;quot;$Apache\_path/conf/ssl\_ca/server.crt&amp;quot;    #证书需要事先准备好
SSLCertificateKeyFile &amp;quot;$Apache\_path/conf/ssl\_ca/server.key&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置具体的访问配置文件&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim $Apache_path/conf/httpd-vhosts.conf
NameVirtualHost *:443
#(此处原本是80端口，使用SSL需修改成443，或者在http.conf内添加一下内容，使用时将注释&amp;quot;#&amp;quot;去掉)
##NameVirtualHost *:443
#Listen 443
#    ServerAdmin webmaster@dummy-host.example.com
    DocumentRoot &amp;quot;/var/www/test&amp;quot;
    ServerName www.test.com
    ServerAlias *.test.com
    ErrorLog &amp;quot;$ErrorLog_Path&amp;quot;
    CustomLog &amp;quot;$AccessLog_Path&amp;quot; common
            Options Indexes FollowSymLinks
        AllowOverride None
        Order allow,deny
        Allow from all
        ServerAdmin webmaster@dummy-host.example.com
    DocumentRoot &amp;quot;/var/www/test&amp;quot;
    ServerName www.test.com:443
    #ServerAlias www.dummy-host.example.com
    SSLEngine on
    SSLCertificateFile &amp;quot;/data/apache2/conf/ssl_ca/server.crt&amp;quot;
    SSLCertificateKeyFile &amp;quot;/data/apache2/conf/ssl_ca/server.key&amp;quot;
    ErrorLog &amp;quot;$ErrorLog_Path&amp;quot;
    CustomLog &amp;quot;$AccessLog_Path&amp;quot; common
            Options Indexes FollowSymLinks
        AllowOverride All
        Order allow,deny
        Allow from all
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>ftps安装配置</title><description>&lt;p&gt;ftps是一种多传输协议，可以说是加密版的FTP。当你在FTP服务器上上传下载文件的时候，你面临两个风险。第一个风险是在上载文件的时候为文件加密。第二个风险是，这些文件在你等待接收方下载的时候将停留在FTP服务器上，这时你如何保证这些文件的安全。当然你可以选择更优的方案，安全文件传输协议(SFTP)。今天这里呢不介绍sftp，这里来讲解一下ftps。&lt;/p&gt;
&lt;p&gt;FTPS是在安全套接层使用</description><html_content>&lt;p&gt;ftps是一种多传输协议，可以说是加密版的FTP。当你在FTP服务器上上传下载文件的时候，你面临两个风险。第一个风险是在上载文件的时候为文件加密。第二个风险是，这些文件在你等待接收方下载的时候将停留在FTP服务器上，这时你如何保证这些文件的安全。当然你可以选择更优的方案，安全文件传输协议(SFTP)。今天这里呢不介绍sftp，这里来讲解一下ftps。&lt;/p&gt;
&lt;p&gt;FTPS是在安全套接层使用标准的FTP协议和指令的一种增强型TFP协议，为FTP协议和数据通道增加了SSL安全功能。FTPS也称作“FTP-SSL”和“FTP-over-SSL”。SSL是一个在客户机和具有SSL功能的服务器之间的安全连接中对数据进行加密和解密的协议。
 &lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;1.安装vsftpd服务&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y vsftpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.关闭selinux和防火墙&lt;/p&gt;
&lt;p&gt;3.新建ftp账号&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;useradd -s /sbin/nologin -d /data/ftpstest vsftptest
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4.配置vsftpd&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.建立登录用户列表文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cd /etc/vsftpd
vim vsftp.user
#添加刚刚新建的ftp账号
vsftpjiuyun
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.生成证书&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mkdir /etc/vsftpd/ssl -p
mkdir /etc/vsftpd/ssl/private -p
ssl证书生成
openssl req -x509 -nodes -days 720 -newkey rsa:2048 -keyout /etc/vsftpd/ssl/private/vsftpd.key -out /etc/vsftpd/ssl/vsftpd.pem
Country Name (2 letter code) \[XX\]:CN    #国家
State or Province Name (full name) \[\]:Zhejiang   #省份
Locality Name (eg, city) \[Default City\]:Hangzhou    #城市
Organization Name (eg, company) \[Default Company Ltd\]:RD    #公司
Organizational Unit Name (eg, section) \[\]:  #直接回车
Common Name (eg, your name or your server's hostname) \[\]:rdtest.com     #主机名
Email Address \[\]:mjin@erongdu.com   #邮箱
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;3.修改vsftpd.conf配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim vsftpd.conf
#修改为
anonymous_enable=NO
listen=YES
#如果没有则添加如下内容
pam_service_name=vsftpd
userlist_enable=YES
chroot_local_user=YES
userlist_deny=NO
userlist_file=/etc/vsftpd/vsftp.user
tcp_wrappers=YES

ssl_enable=YES
allow_anon_ssl=NO
ssl_sslv2=YES
ssl_sslv3=YES
ssl_tlsv1=YES
require_ssl_reuse=NO
force_local_logins_ssl=YES
force_local_data_ssl=YES
rsa_cert_file=/etc/vsftpd/ssl/vsftpd.pem
rsa_private_key_file=/etc/vsftpd/ssl/private/vsftpd.key
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;4.启动vsftpd服务&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;systemctl enable vsftpd
systemctl start vsftpd
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成后使用刚刚创建的ftp账号进行连接测试&lt;/p&gt;</html_content></item><item><title>源码安装php</title><description>&lt;h2&gt;下载php源码&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://www.php.net/distributions/php-7.4.21.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装&lt;/h2&gt;
&lt;!--more--&gt;
&lt;h3&gt;安装依赖&lt;/h3&gt;
&lt;pre</description><html_content>&lt;h2&gt;下载php源码&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://www.php.net/distributions/php-7.4.21.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装&lt;/h2&gt;
&lt;!--more--&gt;
&lt;h3&gt;安装依赖&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y epel-release &amp;amp;&amp;amp; yum -y install gcc oniguruma-devel libzip-devel make gd-devel openssl-devel libicu-devel gcc-c++ sqlite-devel libjpeg-devel libpng-devel libxml2-devel bzip2-devel libcurl-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;解压并进入解压目录&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;tar zxvf php-7.4.21.tar.gz
cd php-7.4.21
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;编译安装&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;./configure  \
                --with-config-file-path=/etc/php7 \
                --with-fpm-user=nginx \
                --with-fpm-group=nginx \
                --enable-fpm \
                --enable-opcache \
                --enable-inline-optimization \
                --disable-debug \
                --disable-rpath \
                --enable-shared \
                -enable-mysqlnd \
                --with-mysqli=mysqlnd \
                --with-pdo-mysql=mysqlnd \
                --enable-mysqlnd-compression-support \
                --with-iconv-dir \
                --with-zlib \
                --enable-xml \
                --disable-rpath \
                --enable-bcmath \
                --enable-shmop \
                --enable-sysvsem \
                --enable-inline-optimization \
                --with-curl \
                --enable-mbregex \
                --enable-mbstring \
                --enable-intl \
                --enable-ftp \
                --enable-gd \
                --enable-gd-jis-conv \
                --with-jpeg   \
                --with-freetype  \
                --with-openssl \
                --with-mhash \
                --enable-pcntl \
                --enable-sockets \
                --with-xmlrpc \
                --with-zip \
                --enable-soap \
                --with-gettext \
                --disable-fileinfo \
                --with-pear \
                --enable-maintainer-zts \
                --without-gdbm  

make
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;拷贝配置文件&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cp php.ini-production /etc/php.ini
cd sapi/fpm
cp init.d.php-fpm /etc/init.d/php-fpm
chmod +x /etc/init.d/php-fpm 
chkconfig --add php-fpm
chkconfig php-fpm on
#进入安装目录操作
cp /etc/php-fpm.d/www.conf.default  php-fpm.d/www.conf
cp /etc/php-fpm.conf.default /etc/php-fpm.conf
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>nginx常用配置汇总</title><description>&lt;h2&gt;nginx的匹配规则&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;~      #波浪线表示执行一个正则匹配，区分大小写
~*    #表示执行一个正则匹配，不区分大小写
^~    #^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录
=      #进行普通字符精确匹配
@</description><html_content>&lt;h2&gt;nginx的匹配规则&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;~      #波浪线表示执行一个正则匹配，区分大小写
~*    #表示执行一个正则匹配，不区分大小写
^~    #^~表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录
=      #进行普通字符精确匹配
@     #&amp;quot;@&amp;quot; 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files


#举例： 匹配文件后缀名
~ *.(gif|jpg|jpeg|png|bmp|swf)$
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;nginx常用代理配置参数&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;location / {
    proxy_pass http://xxxx；
    proxy_redirect off;
    proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;nginx配置ws协议访问&lt;/h2&gt;
&lt;p&gt;在location配置段内填写如下参数&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;proxy_http_version 1.1;
proxy_set_header Upgrade $http_upgrade;
proxy_set_header Connection &amp;quot;upgrade&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;rewrite&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;location / {
    rewrite ^(.*) http://new.domain.com permanent;
    } 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;匹配url开头代理&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;location ~* (^/api){
    proxy_pass http://$ipnew:port;
    ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;根据各种请求参数匹配进行跳转&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;location ~* (^/api){

    #根据http_user_agent请求头类型跳转
    if ( $http_user_agent ~* &amp;quot;iPhone|Android&amp;quot; ) {
        rewrite (.*) http://www.xxx.com/mobile$1 permanent;
        break;
        }

    #根据http_referer跳转
    if ( $http_referer ~* &amp;quot;/phone/w/|/p2/&amp;quot; ) {
                proxy_pass proxy_pass http://$ipnew02:port;
                add_header Cache-Control no-store;
                break;
        }
    proxy_pass http://$ipnew:port;
    include $nginx_prefix/conf/proxy.conf;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;nginx多重条件匹配&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;匹配当请求是&amp;quot;POST&amp;quot;请求且是jpg结尾的文件时，返回503
set $flag 0;
if ( $request_method = &amp;quot;POST&amp;quot; ) {
    set $flag &amp;quot;${flag}1&amp;quot;;
}
if ( $url ~ \.jpg$ ) {
    set $flag &amp;quot;${flag}2&amp;quot;;
}
if ( $flag = &amp;quot;012&amp;quot; ) {
    return 503;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;nginx配置ssl证书&lt;/h2&gt;
&lt;p&gt;在具体配置段内添加&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ssl on; # 或者使用listen 443 ssl;
ssl_certificate ssl.crt;    #ssl证书具体位置
ssl_certificate_key ssl.key;
ssl_session_timeout 5m;
ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
ssl_protocols TLSv1 TLSv1.1 TLSv1.2;。
ssl_prefer_server_ciphers on;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;限制指定IP访问&lt;/h2&gt;
&lt;p&gt;具体配置如下&lt;br /&gt;
在nginx的代理配置文件中添加如下配置,返回状态码403&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;        set $http_status_num  0;
        if ($http_x_forwarded_for = '172.16.1.35') {
                set $http_status_num 1;
        }
        if ($http_x_forwarded_for = '172.16.1.142') {
                set $http_status_num 1;
        }

        if ($http_status_num != 1) {
                return 403;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h2&gt;Nginx常见问题—alias和root的区别&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#alias
server {
    listen 80;
    index index.html;
    location /request_path/code/ {
         alias  /local_path/code;
    }
}

#root
server {
    listen 80;
    index index.html;
    location /request_path/code/ {
         root /local_path/code;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面配置文件中，如果使用的是alias，那么实际请求路径为/local_path/code；如果使用的是root，实际请求路径为/local_path/code/request_path/code。也就是说root的请求路径是root+location的地址，而alias则是跳转到alias所指定的目录&lt;/p&gt;
&lt;h2&gt;nginx日志切割方法&lt;/h2&gt;
&lt;p&gt;新建nginx日志分割脚本&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim nginx_log_cut.sh
#!/bin/bash
Logs_PATH=/usr/local/nginx/logs/access
Yesterday=$(date -d &amp;quot;yesterday&amp;quot; +%Y%m%d)
mv ${Logs_PATH}/access.log ${Logs_PATH}/access_${Yesterday}.log
kill -USR1 $(cat /var/run/nginx.pid)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加计划任务,每天的0点执行分割&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;crontab -e
#添加
0 0 * * * /bin/bash /$scripts_path/nginx_log_cut.sh
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux添加常用yum源</title><description>&lt;h2&gt;添加epel源&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#yum 直接安装
yum install -y epel-release

#收到安装
rpm -vih</description><html_content>&lt;h2&gt;添加epel源&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#yum 直接安装
yum install -y epel-release

#收到安装
rpm -vih https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h2&gt;添加remi源&lt;/h2&gt;
&lt;p&gt;remi源里面几乎都是软件的最新稳定版&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://rpms.remirepo.net/enterprise/remi-release-7.rpm
rpm -Uvh remi-release-7.rpm
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>centos系统gcc多版本共存</title><description>&lt;h2&gt;说明&lt;/h2&gt;
&lt;p&gt;由于gcc编译安装非常费时，今天介绍一个gcc多版本共存的方案。需要某个版本的gcc就切换到某个版本&lt;/p&gt;
&lt;p&gt;首先安装centos的第三方库scl,scl可以在不覆盖原有系统软件的情况下安装新的软件包与系统自带软件包共存，只支持64位系统安装&lt;/p&gt;
&lt;h2&gt;查看当前系统gcc版本&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code</description><html_content>&lt;h2&gt;说明&lt;/h2&gt;
&lt;p&gt;由于gcc编译安装非常费时，今天介绍一个gcc多版本共存的方案。需要某个版本的gcc就切换到某个版本&lt;/p&gt;
&lt;p&gt;首先安装centos的第三方库scl,scl可以在不覆盖原有系统软件的情况下安装新的软件包与系统自带软件包共存，只支持64位系统安装&lt;/p&gt;
&lt;h2&gt;查看当前系统gcc版本&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;gcc --version
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装scl第三方源，并安装高版本gcc&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum -y install centos-release-scl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;1. 安装gcc7.3&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum -y install devtoolset-7-gcc devtoolset-7-gcc-c++ devtoolset-7-binutils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;2. 安装gcc8.3&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum -y install devtoolset-8-gcc devtoolset-8-gcc-c++ devtoolset-8-binutils
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;scl命令查看以安装gcc版本和版本切换&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;scl --list 
scl -l

#切换到gcc-7
scl enable devtoolset-7 bash

# 切换到gcc-8
scl enable devtoolset-8 bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;
scl命令切换gcc版本是临时生效，退出shell或重启系统会恢复原系统gcc版本
若要设置长期生效，可将命令加入环境变量&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;echo &amp;quot;scl enable devtoolset-7 bash&amp;quot; &amp;gt;&amp;gt; /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;以停止支持的4.8/4.9/5.2的安装&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# gcc 4.8
wget http://people.centos.org/tru/devtools-2/devtools-2.repo -O /etc/yum.repos.d/devtoolset-2.repo
yum -y install devtoolset-2-gcc devtoolset-2-gcc-c++ devtoolset-2-binutils


# gcc 4.9
wget https://copr.fedoraproject.org/coprs/rhscl/devtoolset-3/repo/epel-6/rhscl-devtoolset-3-epel-6.repo -O /etc/yum.repos.d/devtoolset-3.repo
yum -y install devtoolset-3-gcc devtoolset-3-gcc-c++ devtoolset-3-binutils

# gcc 5.2
wget https://copr.fedoraproject.org/coprs/hhorak/devtoolset-4-rebuild-bootstrap/repo/epel-6/hhorak-devtoolset-4-rebuild-bootstrap-epel-6.repo -O /etc/yum.repos.d/devtoolset-4.repo
yum install devtoolset-4-gcc devtoolset-4-gcc-c++ devtoolset-4-binutils -y
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>Ansys.Electronics.2021.R1.Linux64的安装破解</title><description>&lt;p&gt;&amp;emsp;&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2&gt;需要安装的依赖&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y giflib libtiff libXdamage libXfixes libXft libXmu libXp libXrender libXxf86vm</description><html_content>&lt;p&gt;&amp;emsp;&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2&gt;需要安装的依赖&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y giflib libtiff libXdamage libXfixes libXft libXmu libXp libXrender libXxf86vm mesa-dri-drivers mesa-libGL mesa-libGLU libpng12 libXScrnSaver
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装&lt;/h2&gt;
&lt;h3&gt;1.基础软件安装&lt;/h3&gt;
&lt;p&gt;Linux版安装需要桌面的支持&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;./install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;选择安装对应功能软件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意点：&lt;/strong&gt;
在选择lincense界面是选择'i have a lincense ...',点击下一步，浏览选择破解文件夹中的'ansyslmd.lic'文件&lt;/p&gt;
&lt;p&gt;安装完成后退出安装界面&lt;/p&gt;
&lt;h3&gt;破解文件拷贝&lt;/h3&gt;
&lt;p&gt;拷贝破解文件到对应目录&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#进入破解文件目录
\cp -r AnsysEM/* /opt/AnsysEM/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;启动软件&lt;/h3&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#设置环境变量
cat &amp;gt; env.source &amp;lt;&amp;lt;EOF
export ANSYSLIC_DIR=/opt/AnsysEM/shared_files/licensing
export ANSYSLMD_LCENSE_FILE=/opt/AnsysEM/shared_files/licensing/license_files/ansyslmd.lic
EOF

source env.source

cd /opt/AnsysEM/ANsysEM21.1/Linux64
./ansysedt
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;错误解决&lt;/h3&gt;
&lt;p&gt;libXss.so.1依赖&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y libXScrnSaver
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>搭建内网dns服务</title><description>&lt;h4&gt;安装&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#安装
yum install -y bind
firewall-cmd --permanent --add-service=dns
firewall-cmd --reload
# 开机自启
systemctl enable named
# 启动
systemctl</description><html_content>&lt;h4&gt;安装&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#安装
yum install -y bind
firewall-cmd --permanent --add-service=dns
firewall-cmd --reload
# 开机自启
systemctl enable named
# 启动
systemctl start named
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;配置&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;/etc/named.conf&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;options {
        # any表示本地所有网络接口上开启53端口
        listen-on port 53 { any; };
        listen-on-v6 port 53 { ::1; };
        directory       &amp;quot;/var/named&amp;quot;;
        dump-file       &amp;quot;/var/named/data/cache_dump.db&amp;quot;;
        statistics-file &amp;quot;/var/named/data/named_stats.txt&amp;quot;;
        memstatistics-file &amp;quot;/var/named/data/named_mem_stats.txt&amp;quot;;
        recursing-file  &amp;quot;/var/named/data/named.recursing&amp;quot;;
        secroots-file   &amp;quot;/var/named/data/named.secroots&amp;quot;;
        # 允许查询A记录的客户端列表，any表示所有
        allow-query     { any; };
        # 设置上级提供查询解析地址的dns
        forwarders      { 114.114.114.114; };

        recursion yes;

        dnssec-enable yes;
        # 关闭dns检测，使dns能够缓存外部信息到本机
        dnssec-validation no;

        /* Path to ISC DLV key */
        bindkeys-file &amp;quot;/etc/named.root.key&amp;quot;;

        managed-keys-directory &amp;quot;/var/named/dynamic&amp;quot;;

        pid-file &amp;quot;/run/named/named.pid&amp;quot;;
        session-keyfile &amp;quot;/run/named/session.key&amp;quot;;
};

logging {
        channel default_debug {
                file &amp;quot;data/named.run&amp;quot;;
                severity dynamic;
        };
};

zone &amp;quot;.&amp;quot; IN {
        type hint;
        file &amp;quot;named.ca&amp;quot;;
};

include &amp;quot;/etc/named.rfc1912.zones&amp;quot;;
include &amp;quot;/etc/named.root.key&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;/etc/named.rfc1912.zones&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;创建内网需要解析的域名&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 添加该段内容
zone &amp;quot;hehu.com&amp;quot; IN {
        # dns为master，即主dns
        type master;
        # hehu.com域名的解析文件
        file &amp;quot;hehu.com.zone&amp;quot;;
        allow-update { none; };
};

zone &amp;quot;localhost.localdomain&amp;quot; IN {
        type master;
        file &amp;quot;named.localhost&amp;quot;;
        allow-update { none; };
};

zone &amp;quot;localhost&amp;quot; IN {
        type master;
        file &amp;quot;named.localhost&amp;quot;;
        allow-update { none; };
};

zone &amp;quot;1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa&amp;quot; IN {
        type master;
        file &amp;quot;named.loopback&amp;quot;;
        allow-update { none; };
};

zone &amp;quot;1.0.0.127.in-addr.arpa&amp;quot; IN {
        type master;
        file &amp;quot;named.loopback&amp;quot;;
        allow-update { none; };
};

zone &amp;quot;0.in-addr.arpa&amp;quot; IN {
        type master;
        file &amp;quot;named.empty&amp;quot;;
        allow-update { none; };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;/var/named/hehu.com.zone&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cd /var/named
cp named.localhost hehu.com.zone
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux下安装配置nfs</title><description>&lt;p&gt;在我们使学习用k8s过程当中，pod容器中数据的持久化存储是经常被使用到的，也是需要掌握的。这里我们提供一种简单常用的持久化存储方案nfs，以方便我们学习。只有我们掌握了k8s的持久化存储，才能在生产环境更换更优的选择合适放持久化存储方案&lt;/p&gt;
&lt;p&gt;本文介绍centos7系统上搭建nfs系统。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h5&gt;nfs</description><html_content>&lt;p&gt;在我们使学习用k8s过程当中，pod容器中数据的持久化存储是经常被使用到的，也是需要掌握的。这里我们提供一种简单常用的持久化存储方案nfs，以方便我们学习。只有我们掌握了k8s的持久化存储，才能在生产环境更换更优的选择合适放持久化存储方案&lt;/p&gt;
&lt;p&gt;本文介绍centos7系统上搭建nfs系统。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h5&gt;nfs server端安装&lt;/h5&gt;
&lt;p&gt;nfs的安装很简单，直接yum安装即可，执行下面的安装命令&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y nfs-utils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;简单的一条命令。很快我们就完成了nfs的安装。下面我们来配置nfs系统。nfs的配置文件为/etc/exports.&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/exports
#格式: 共享目录 客户端(权限设置,映射关系、其他) 客户端和选项之间没有空格
/data/pv1 *(rw,no_root_squash,sync)

#创建共享目录
mkdir /data/pv1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动nfs server并查看配置是否生效&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;systemctl enable rpcbind
systemctl enable nfs-server

systemctl start rpcbind
systemctl start nfs-server
exportfs -r
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;客户端配置并使用&lt;/h5&gt;
&lt;p&gt;同样执行安装命令&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y nfs-utils
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看nfs 服务器设置共享目录&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;showmount -e 172.16.88.209      #此ip为nfs-server的服务器IP
#返回结果
Export list for 172.16.88.209:
/data/pv1 *
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行命令进行目录挂载&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#创建数据挂载目录
mkdir /data
# mount -t nfs $(nfs服务器的IP):/data/pv1 /data
mount -t nfs 172.16.88.209:/data/pv1 /data
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;nfs配置项注解&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;共享目录&lt;/li&gt;
&lt;li&gt;nfs共享给客户端使用的目录&lt;/li&gt;
&lt;li&gt;客户端&lt;/li&gt;
&lt;li&gt;指定主机IP：172.16.0.1&lt;/li&gt;
&lt;li&gt;指定子网所有主机：172.16.0.0/24&lt;/li&gt;
&lt;li&gt;指定域名： nfs.test.com、*.test.com&lt;/li&gt;
&lt;li&gt;所有主机：*&lt;/li&gt;
&lt;li&gt;权限设置&lt;/li&gt;
&lt;li&gt;只读权限：ro&lt;/li&gt;
&lt;li&gt;读写权限：rw&lt;/li&gt;
&lt;li&gt;属组映射&lt;/li&gt;
&lt;li&gt;all_squash：将远程访问的所有普通用户及所属组都映射为匿名用户或用户组（nfsnobody）；&lt;/li&gt;
&lt;li&gt;no_all_squash：与all_squash取反（默认设置）；&lt;/li&gt;
&lt;li&gt;root_squash：将root用户及所属组都映射为匿名用户或用户组（默认设置）；&lt;/li&gt;
&lt;li&gt;no_root_squash：与rootsquash取反；&lt;/li&gt;
&lt;li&gt;anonuid=xxx：将远程访问的所有用户都映射为匿名用户，并指定该用户为本地用户（UID=xxx）；&lt;/li&gt;
&lt;li&gt;anongid=xxx：将远程访问的所有用户组都映射为匿名用户组账户，并指定该匿名用户组账户为本地用户组账户（GID=xxx）；&lt;/li&gt;
&lt;li&gt;其他选项&lt;/li&gt;
&lt;li&gt;secure：限制客户端只能从小于1024的tcp/ip端口连接nfs服务器（默认设置）；&lt;/li&gt;
&lt;li&gt;insecure：允许客户端从大于1024的tcp/ip端口连接服务器；&lt;/li&gt;
&lt;li&gt;sync：将数据同步写入内存缓冲区与磁盘中，效率低，但可以保证数据的一致性；&lt;/li&gt;
&lt;li&gt;async：将数据先保存在内存缓冲区中，必要时才写入磁盘；&lt;/li&gt;
&lt;li&gt;wdelay：检查是否有相关的写操作，如果有则将这些写操作一起执行，这样可以提高效率（默认设置）；&lt;/li&gt;
&lt;li&gt;no_wdelay：若有写操作则立即执行，应与sync配合使用；&lt;/li&gt;
&lt;li&gt;subtree：若输出目录是一个子目录，则nfs服务器将检查其父目录的权限(默认设置)；&lt;/li&gt;
&lt;li&gt;no_subtree：即使输出目录是一个子目录，nfs服务器也不检查其父目录的权限，这样可以提高效率；&lt;/li&gt;
&lt;/ul&gt;</html_content></item><item><title>linux下mysql的安装(二进制源码安装)</title><description>&lt;p&gt;mysql的安装方法很多。这里向大家介绍一下本人常用的安装方式，通过下载编译好的文件进行安装&lt;/p&gt;
&lt;h2&gt;mysql下载地址&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code</description><html_content>&lt;p&gt;mysql的安装方法很多。这里向大家介绍一下本人常用的安装方式，通过下载编译好的文件进行安装&lt;/p&gt;
&lt;h2&gt;mysql下载地址&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;https://dev.mysql.com/downloads/mysql/5.6.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;mysql的安装&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建mysql用户和用户&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;groupadd mysql
useradd -g mysql -s /sbin/nologin mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;创建mysql安装目录&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mkdir /data/mysql/logs -p   #mysql日志存放目录
mkdr /data/mysql/tmp -p     #mysql临时文件存放目录
mkdir /data/mysql/data -p   #mysql数据存放目录
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;解压mysql文件并初始化安装&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#解压mysql二进制包并移动到安装目录/usr/local/mysql
tar zxvf mysql-5.6.25-linux-glibc2.5-x86_64.tar.gz
mv mysql-5.6.25-linux-glibc2.5-x86_64 /usr/local/mysql
\\cp -r my.cnf /etc/my.cnf
#对文件夹进行授权操作
chown -R mysql.mysql /data/mysql
#初始化mysql
/usr/local/mysql/scripts/mysql\_install\_db --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql/data --defaults-file=/etc/my.cnf
#mysql启动脚本并设置开机自启动
cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
chkconfig --add mysqld
chkconfig mysqld on
#创建mysql软链接，也可设置环境变量
ln -s /usr/local/mysql/bin/mysqldump /usr/bin/mysqldump
ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;mysql设置密码&lt;/h2&gt;
&lt;h3&gt;初次登录修改mysql@localhosts密码(mysql5.7以上)&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ALTER USER 'root'@'localhost' IDENTIFIED BY 'MyNewPass';
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;对于5.6的初始root密码除了上述方式也可使用下面的方式&lt;/h3&gt;
&lt;p&gt;初始安装完成后的mysql是没有密码的，可根据提示进行密码设置，也可以使用以下命令对mysql进行密码设置。&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#授权root账号通过localhost连接mysql
mysql -e &amp;quot;GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' IDENTIFIED BY 'xxxxx' WITH GRANT OPTION;&amp;quot;
flush privileges;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;如果是centos7则添加mysql启动脚本&lt;/h2&gt;
&lt;p&gt;1 创建mysqld.service文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /usr/lib/systemd/system/mysqld.service
[Unit]
Description=MySQLD
SourcePath=/etc/init.d/mysqld
 # 关机前操作
Before=shutdown.target
[Service]
# 此用户必须存在，即为启动mysql的用户
User=mysql 
Type=forking
ExecStart=/etc/init.d/mysqld start
ExecStop=/etc/init.d/mysqld stop
[Install]
WantedBy=multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2 重新加载一个服务的配置文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;root@localhost:~# systemctl daemon-reload
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3 使用systemctl启动服务&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;root@localhost:~# systemctl start mysqld.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql的安装很简单。到此安装工作就已经完成啦&lt;/p&gt;
&lt;p&gt;附上脚本mysql_install.sh&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#!/bin/bash
groupadd mysql
useradd -g mysql -s /sbin/nologin mysql
tar zxvf mysql-5.6.25-linux-glibc2.5-x86_64.tar.gz
mv mysql-5.6.25-linux-glibc2.5-x86_64 /usr/local/mysql
\\cp -r my.cnf /etc/my.cnf
mkdir -p /data/mysql/tmp
mkdir -p /data/mysql/logs 
chown -R mysql.mysql /data/mysql
/usr/local/mysql/scripts/mysql\_install\_db --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql/data --defaults-file=/etc/my.cnf
cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld
chkconfig --add mysqld
chkconfig mysqld on
ln -s /usr/local/mysql/bin/mysqldump /usr/bin/mysqldump
ln -s /usr/local/mysql/bin/mysql /usr/bin/mysql
#mysql -e &amp;quot;GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' IDENTIFIED BY '' WITH GRANT OPTION;&amp;quot;
#flush privileges;
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux下安装gitlab-ce</title><description>&lt;h2&gt;安装gitlab前最好先关闭防火墙并安装邮件服务&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;systemctl stop firewalld
yum install -y postfix
systemctl start</description><html_content>&lt;h2&gt;安装gitlab前最好先关闭防火墙并安装邮件服务&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;systemctl stop firewalld
yum install -y postfix
systemctl start postfix
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h2&gt;gitlab安装&lt;/h2&gt;
&lt;p&gt;gitlab安装，使用rpm包安装，版本是8.8.5，注意不同的版本对应的系统要求不一样，本人用的centos系统。这个版本要求7以上。否则安装报错&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;rpm -vih gitlab-ce-8.8.5-ce.1.el7.x86_64.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成以后，修改gitlab访问地址&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/gitlab/gitlab.rb
external_url 'http://gitlab.example.com'
#修改成你的真实访问地址
external_url 'http://gitlab.test.com'
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置邮件服务&lt;/h2&gt;
&lt;h3&gt;修改配置文件&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/gitlab/gitlab.rb
gitlab_rails['smtp_enable'] = true
gitlab_rails['smtp_address'] = &amp;quot;smtp.xxx.com&amp;quot;    #发送邮件服务器
gitlab_rails['smtp_port'] = 25
gitlab_rails['smtp_user_name'] = &amp;quot;gitlab@xxx.com&amp;quot;    #发送邮件邮箱
gitlab_rails['smtp_password'] = &amp;quot;password&amp;quot;        #密码
gitlab_rails['smtp_domain'] = &amp;quot;xxx.com&amp;quot;    #域名
gitlab_rails['smtp_authentication'] = &amp;quot;login&amp;quot;
gitlab_rails['smtp_enable_starttls_auto'] = true
gitlab_rails['smtp_tls'] = false
gitlab_rails['gitlab_email_from'] = 'gitlab@xxx.com'
gitlab_rails['smtp_openssl_verify_mode'] = 'none'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;配置生效&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;gitlab-ctl reconfigure
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;发送测试邮件测试是否正常&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#执行命令进入控制台
gitlab-rails console
#发送测试邮件
Notify.test_email('收件人', '主题', '正文').deliver_now
 ```
## 启动gitlab

```bash
gitlab-ctl start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;查看gitlab状态&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;gitlab-ctl status
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux升级内核到最新版本</title><description>&lt;h2&gt;CentOS7内核升级&lt;/h2&gt;
&lt;p&gt;红帽企业版 Linux 仓库网站&lt;code&gt;https://www.elrepo.org&lt;/code&gt;，主要提供各种硬件驱动（显卡、网卡、声卡等）和内核升级相关资源；兼容 CentOS7 内核升级。如下按照网站提示载入elrepo公钥及最新elrepo版本，然后按步骤升级内核（以安装长期支持版本 kernel-lt 为例）&lt;/p&gt;
&lt;pre</description><html_content>&lt;h2&gt;CentOS7内核升级&lt;/h2&gt;
&lt;p&gt;红帽企业版 Linux 仓库网站&lt;code&gt;https://www.elrepo.org&lt;/code&gt;，主要提供各种硬件驱动（显卡、网卡、声卡等）和内核升级相关资源；兼容 CentOS7 内核升级。如下按照网站提示载入elrepo公钥及最新elrepo版本，然后按步骤升级内核（以安装长期支持版本 kernel-lt 为例）&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 载入公钥
rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
# 安装ELRepo
rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm
# 载入elrepo-kernel元数据
yum --disablerepo=\* --enablerepo=elrepo-kernel repolist
# 查看可用的rpm包
yum --disablerepo=\* --enablerepo=elrepo-kernel list kernel*
# 安装长期支持版本的kernel
yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt.x86_64
# 删除旧版本工具包
yum remove kernel-tools-libs.x86_64 kernel-tools.x86_64 -y
# 安装新版本工具包
yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt-tools.x86_64

#查看默认启动顺序
awk -F\' '$1==&amp;quot;menuentry &amp;quot; {print $2}' /etc/grub2.cfg  
### 返回结果如下
CentOS Linux (4.4.183-1.el7.elrepo.x86_64) 7 (Core)  
CentOS Linux (3.10.0-327.10.1.el7.x86_64) 7 (Core)  
CentOS Linux (0-rescue-c52097a1078c403da03b8eddeac5080b) 7 (Core)

#默认启动的顺序是从0开始，新内核是从头插入（目前位置在0，而4.4.4的是在1），所以需要选择0。
grub2-set-default 0  
#重启并检查
reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Ubuntu16.04内核升级&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;打开 http://kernel.ubuntu.com/~kernel-ppa/mainline/ 并选择列表中选择你需要的版本（以4.16.3为例）。
接下来，根据你的系统架构下载 如下.deb 文件：
Build for amd64 succeeded (see BUILD.LOG.amd64):
  linux-headers-4.16.3-041603_4.16.3-041603.201804190730_all.deb
  linux-headers-4.16.3-041603-generic_4.16.3-041603.201804190730_amd64.deb
  linux-image-4.16.3-041603-generic_4.16.3-041603.201804190730_amd64.deb
#安装后重启即可
$ sudo dpkg -i *.deb
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>批量管理工具ansible使用</title><description>&lt;h3&gt;ansible的安装&lt;/h3&gt;
&lt;p&gt;yum安装方式&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y epel-release
yum install -y ansible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pip的安装方式&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code</description><html_content>&lt;h3&gt;ansible的安装&lt;/h3&gt;
&lt;p&gt;yum安装方式&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y epel-release
yum install -y ansible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;pip的安装方式&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;pip install ansible -i https://mirrors.aliyun.com/pypi/simple/
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;ansible定义管理节点(资产)和变量&lt;/h3&gt;
&lt;p&gt;一、 简单使用介绍
1. ansible管理被管理节点，如果不想设置被管理节点的登录信息，可以配置免秘钥登录&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ssh-keygen -t rsa -b 2048 -N '' -f ~/.ssh/id_rsa

# 将公钥分发到被管理节点
ssh-copy-id $IPs
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;基础使用&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 单节点列表，注意节点后面的逗号
ansible all -i 172.16.88.112, -m ping
ansible all -i 172.16.88.112,172.16.88.113 -m ping

#定义了节点信息的hosts文件
ansible all -i ./hosts -m ping
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;all&lt;/code&gt; 节点选择器，通常&lt;code&gt;-i&lt;/code&gt;参数给定节点信息，&lt;code&gt;all&lt;/code&gt;表示匹配所有的&lt;code&gt;-i&lt;/code&gt;指定的节点，也可以是文本内定义的某个分组名&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt;参数指定节点列表，可以是一个列表，也可以是一个文件名，如果是一个单节点列表，后面需要加上逗号&lt;code&gt;,&lt;/code&gt;否则执行会报错，如果没有指定&lt;code&gt;-i&lt;/code&gt;参数则使用默认文件&lt;code&gt;/etc/ansible/hosts&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-m&lt;/code&gt; 执行运行的模块&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-a&lt;/code&gt; 指定模块参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;二、 静态资产
    静态资产就是一个文本文件，定义资产信息，默认是&lt;code&gt;/etc/ansible/hosts&lt;/code&gt;,定义的节点可以是主机名或者主机IP，对不同功能节点服务器可以定义不同的分组，分组名用&lt;code&gt;[]&lt;/code&gt;括起，有利于后续操作时方便节点选择&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;资产定义和分组&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim test_hosts

# 定义web组的资产
[web]
172.16.88.112
172.16.88.11[5:9]   #表示115到119的ip段

# 定义db组的资产
[db]
172.16.88.113

# 将web组合db组的资产都嵌套到all
[all_hosts]
[all_hosts:children]  #:children是固定写法
web
db
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;列出定义的资产&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 列出所有资产
ansible all -i test_hosts --list-hosts

# 列出单个资产
ansible 172.16.88.113 -i test_hosts --list-hosts

# 使用*匹配
ansible 172.16.88.* -i test_hosts --list-hosts

# 并集
ansible 'web:db' -i test_hosts --list-hosts

# 交集
ansible 'web:&amp;amp;db' -i test_hosts --list-hosts

# 排除，哪个分组在前，以哪个分组为基准
ansible 'web:!db' -i test_hosts --list-hosts

# 列出db分组所有资产
ansible db -i test_hosts --list-hosts

# 列出all_hosts组的资产
ansible all_hosts -i test_hosts --list-hosts
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;三、 动态资产
待补充...&lt;/p&gt;
&lt;h4&gt;全局变量&lt;/h4&gt;
&lt;p&gt;执行ansible或者ansible-playbook时通过&lt;code&gt;-e&lt;/code&gt;参数指定的变量
传递形式
1. 普通key=value形式传递&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ansible  web -i test_hosts  -m  template -a &amp;quot;src=./test.j2 dest=/tmp/test&amp;quot; -e &amp;quot;var=world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;以yaml/json格式或者文本传递&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-yml"&gt;# json格式
cat a.json
{&amp;quot;var&amp;quot;:&amp;quot;word&amp;quot;}
ansible  web -i test_hosts  -m  debug -a &amp;quot;msg='this is a hello {{ var }}'&amp;quot; -e @a.json

## yaml格式
cat a.yaml
var: word

ansible  web -i test_hosts  -m  debug -a &amp;quot;msg='this is a hello {{ var }}'&amp;quot; -e @a.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;剧本变量&lt;/h4&gt;
&lt;p&gt;这种变量和playbook有关，常见的两种定义方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过playbook的vars属性定义&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 通过vars定义
- name: test playbook
  hosts: all
  vars:
    user: haha
    path: /home/data
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;通过playbook的vars_files指定一个变量文件，变量文件也是yaml格式文件&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 定义变量文件vars_file.yaml
user: haha
path: /home/data

# 指定vars_files
- name: test playbook
  hosts: all
  vars_files:
    - vars_file.yaml
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;playbook中使用剧本变量
直接使用双大括号将变量名括起来&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;- name: test playbook
  hosts: all
  vars:
    user: haha
    path: /home/data
  tasks:
    - name: tasks test {{ user }}
      user:
          # 这里需要注意字典引用变量需要加上双引号，否则会报错，区别于上面的字符串引用变量
        name: &amp;quot;{{ user }}&amp;quot;
        paths: &amp;quot;{{ path }}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;资产变量&lt;/h4&gt;
&lt;p&gt;前面我们介绍了资产的定义，如果要为某台服务器定义单独的变量，叫做资产变量，直接在资产的后面定义变量即可，多个以空格隔开&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主机变量
比如我们给前面定义的资产添加资产变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim test_hosts

# 定义web组的资产
[web]
172.16.88.112 port=22
...


# 资产变量的引用
ansible  web -i test_hosts  -m  debug -a &amp;quot;msg='port is {{ port }}'&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;主机组变量&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim test_hosts

# 定义web组的资产
[web]
172.16.88.112
172.16.88.11[5:9]   #表示115到119的ip段

# 定义web组的组变量[:vars]是固定写法
[web:vars]
port=22
...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;
当主机定义了主机变量和主机组变量的时候，主机变量优先级大于主机组变量优先级
3. 主机变量的继承&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim test_hosts
...
[all_hosts]
[all_hosts:children]  #:children是固定写法
web
db

#定义主机变量的继承
[all_hosts:vars]
port=33
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;Inventory内置变量&lt;/h4&gt;
&lt;p&gt;内置变量都是以&lt;code&gt;ansible_&lt;/code&gt;为前缀的
ansible_ssh_host    连接远程主机的主机名或IP
ansible_ssh_port    端口
ansible_ssh_user    用户
ansible_ssh_pass    密码，不安全，官方建议使用密钥或者--ask-pass
ansible_sudo_pass   sudo密码，不安全，官方建议--ask-sudo-pass
ansible_ssh_private_key_file ssh使用的私钥文件
ansible_python_interpreter  目标主机的python路径，使用当远程主机有多个python环境需要指定具体环境时使用&lt;/p&gt;
&lt;h4&gt;Facts变量&lt;/h4&gt;
&lt;p&gt;ansible内置变量，完全由setup模块去搜集完成，收集远程主机的各种信息
Facts变量的使用
1. 命令行使用&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 获取完整变量
ansible  web -i test_hosts  -m  setup

#过滤变量，filter模糊匹配
ansible  web -i test_hosts  -m  setup -a &amp;quot;filter=*default_ipv4*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;playbook使用
playbook会自动获取Facts变量，直接使用即可
如需关闭，在playbook中添加参数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;gather_facts: no
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;变量优先级&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优先级从高到低&lt;/strong&gt;
全局变量(-e指定参数)
playbook剧本变量(vars定义的变量)
资产变量&lt;/p&gt;
&lt;h3&gt;常用模块&lt;/h3&gt;
&lt;h4&gt;学会使用帮助命令&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 列出模块
ansible-doc -l

# 列出某个模板的使用方法
ansible-doc module_name     #详细
ansible-doc -s module_name  # 简洁
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;command模块&lt;/h4&gt;
&lt;p&gt;command模块是ansible的默认模块，不指定&lt;code&gt;-m&lt;/code&gt;参数是使用的就是command模块&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ansible db -i test_hosts -a &amp;quot;ip a&amp;quot;
ansible db -i test_hosts -m command -a &amp;quot;ip a&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;shell模块&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ansible -i test_hosts web -m shell -a &amp;quot;ps -ef|grep etcd&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;shell模块和command模块的区别&lt;/strong&gt;
command模块无法执行shell的内置命令和特性，比如管道等，shell模块可以&lt;/p&gt;
&lt;h4&gt;script模块&lt;/h4&gt;
&lt;p&gt;使管理节点上的脚本在远程被管理节点上执行&lt;/p&gt;
&lt;p&gt;在管理节点新建一个测试脚本然后通过ansible执行&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;echo 'ip a' &amp;gt; /tmp/test.sh
ansible web -i test_hosts  -m script -a &amp;quot;/tmp/test.sh&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;copy模块和fetch模块&lt;/h4&gt;
&lt;p&gt;copy模块用户管理节点和被管理节点之间的文件拷贝，用于将管理节点文件拷贝到被管理节点
fetch模块与copy模块功能相反，将被管理节点的文件拷贝到管理节点上&lt;/p&gt;
&lt;p&gt;copy常用参数解析:
|参数|解释|
| --- | --- |
| src | 指定拷贝文件的源地址 |
| dest | 指定拷贝文件的目标地址 |
| backup | 拷贝文件时若原始文件发生变化则对目标文件进行备份 |
| woner | 指定新拷贝文件的所有者 |
| group | 指定新拷贝文件的属组 |
| mode | 指定新拷贝文件的权限 |&lt;/p&gt;
&lt;p&gt;用法:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ansible web -i test_hosts  -m copy -a &amp;quot;src=./test.sh dest=/root/ backup=yes mode=755&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;fetch常用参数解析
|参数|解释|
| --- | --- |
| src | 指定远程主机上需要拷贝文件的地址 |
| dest | 指定拷贝文件到本地的地址 |
| flat | 允许覆盖 |&lt;/p&gt;
&lt;p&gt;用法:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ansible web -i test_hosts  -m fetch -a &amp;quot;src=/home/testans/.ssh dest=/tmp&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;package模块&lt;/h4&gt;
&lt;p&gt;用于包管理
|参数|解释|
| --- | --- |
| name | 要安装的软件包名，多个以逗号&lt;code&gt;,&lt;/code&gt;隔开 |
| state | 对当前指定的软件的操作,安装(present)/删除(absent) |
| use | 使用哪种包管理，yum/apt等，默认auto |&lt;/p&gt;
&lt;p&gt;用法:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 安装nginx
ansible web -i test_hosts  -m package -a &amp;quot;name=nginx state=present&amp;quot;

# 移除nginx
ansible web -i test_hosts  -m package -a &amp;quot;name=nginx state=absent&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;yum模块&lt;/h4&gt;
&lt;p&gt;在被管理节点上执行yum命令
|参数|解释|
| --- | --- |
| name | 要安装的软件包名，多个以逗号&lt;code&gt;,&lt;/code&gt;隔开 |
| state | 对当前指定的软件的操作 |&lt;/p&gt;
&lt;p&gt;state状态的支持的参数
|参数|解释|
| --- | --- |
| present | 确保安装，但不升级 |
| installed | 确保已经安装 |
| latest | 确保安装且升级到最新 |
| absent | 确认删除 |
| removed | 确认删除 |&lt;/p&gt;
&lt;p&gt;用法:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 安装nginx
ansible web -i test_hosts  -m yum -a &amp;quot;name=nginx state=present&amp;quot;
ansible web -i test_hosts  -m yum -a &amp;quot;name=nginx state=installed&amp;quot;
ansible web -i test_hosts  -m yum -a &amp;quot;name=nginx state=latest&amp;quot;

# 移除nginx
ansible web -i test_hosts  -m yum -a &amp;quot;name=nginx state=absent&amp;quot;
ansible web -i test_hosts  -m yum -a &amp;quot;name=nginx state=removed&amp;quot;

# 安装软件包组,软件包组以@开头
ansible web -i test_hosts  -m yum -a &amp;quot;name='@Development tools' state=present&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;systemd和service模块&lt;/h4&gt;
&lt;p&gt;centos6管理服务使用的是service模块，centos7以后使用的是systemd模块&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;service模块的用法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参数|解释|
| --- | --- |
| name | 服务名称 |
| enabled | 是否开机自启动,yes或者no |
| pattern | 定义一个模式，如果通过status指令来查看服务的状态时，没有响应，就会通过ps指令在进程中根据该模式进行查找，如果匹配到，则认为该服务依然在运行 |
| state | 执行的操作,启动(started)、停止(stopped)、重启(restarted)、重新加载(reloaded) |&lt;/p&gt;
&lt;p&gt;用法:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 启动nginx并设置开机自启
ansible web -i test_hosts  -m service -a &amp;quot;name=nginx state=started enabled=yes&amp;quot;

# 关闭nginx
ansible web -i test_hosts  -m systemd -a &amp;quot;name=nginx state=stopped&amp;quot;

# 重启nginx
ansible web -i test_hosts  -m systemd -a &amp;quot;name=nginx state=restarted&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;systemd模块的用法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;|参数|解释|
| --- | --- |
| daemon_reload | 重新载入systemd |
| name | 服务名称 |
| enabled | 是否开机自启动,yes或者no |
| state | 执行的操作,启动(started)、停止(stopped)、重启(restarted)、重新加载(reloaded) |
&lt;strong&gt;注意:&lt;/strong&gt;
state参数的&lt;code&gt;reloaded&lt;/code&gt;状态需要服务自身支持reload才能使用，比如nginx就支持&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 重新加载systemd，等价于systemd daemon_reload
ansible web -i test_hosts  -m systemd -a &amp;quot;daemon_reload=yes&amp;quot;

# 启动nginx并设置开机自启
ansible web -i test_hosts  -m systemd -a &amp;quot;name=nginx state=started enabled=yes&amp;quot;

# 关闭nginx
ansible web -i test_hosts  -m systemd -a &amp;quot;name=nginx state=stopped&amp;quot;

# 重启nginx
ansible web -i test_hosts  -m systemd -a &amp;quot;name=nginx state=restarted&amp;quot;

# 重新加载nginx
ansible web -i test_hosts  -m systemd -a &amp;quot;name=nginx state=reloaded&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;group和user模块&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;group模块使用&lt;/li&gt;
&lt;li&gt;|参数|解释|
| --- | --- |
| system | 是否为系统组，yes或no,默认no |
| name | 组名 |
| state | 创建(present)和删除(absent),默认present |&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 创建普通用户组group01
ansible web -i test_hosts  -m  group -a &amp;quot;name=group01&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;user模块使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;|参数|解释|
| --- | --- |
| name | 用户名 |
| group | 设置用户的主组 |
| groups | 将用户加入其它组，多个组以逗号隔开 |
| append | 与groups配合使用的参数，设置为yes的时候，不会把用户从其他已经加入的组中删除 |
| password | 用户密码，接收加密后的值，默认不设置密码 |
| update_password | 设置的密码不同于原始密码，则更新密码 |
| home | 指定用户家目录 |
| shell | 设置用户shell |
| commnet | 描述信息 |
| create_home | 创建用户时是否创建家目录，默认yes |
| system | 设置为yes时将创建为一个系统账号 |
| expires | 设置用户过期时间，值为时间戳 |
| generate_ssh_key | 设置为yes时为用户创建密钥，不会覆盖原有密钥 |
| ssh_key_type | 设置密钥类型，默认rsa |
| state | 添加用户(present)/删除用户(absent) |
| remove | 与state参数一起使用，删除一个用户管理的目录，比如家目录等 |&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 创建用户名设置密码
pass=$(echo &amp;quot;123456&amp;quot; |openssl passwd -1 -stdin)
ansible  web -i test_hosts  -m  user -a &amp;quot;name=testuser password=${pass}&amp;quot;

# 创建用户并创建密钥对，密钥对类型为ecdsa
ansible  web -i test_hosts  -m  user -a &amp;quot;name=testuser generate_ssh_key=yes ssh_key_type=ecdsa&amp;quot;

# 创建用户并设置有效期到某一天，并将改用户加入到某个组
ansible  web -i test_hosts  -m  user -a &amp;quot;name=testuser expires=$(date +%s -d 20210827) groups=docker&amp;quot;

# 创建用户并设置有效期到某一天，并将改用户加入到某个组，不改变原有组
ansible  web -i test_hosts  -m  user -a &amp;quot;name=testuser expires=$(date +%s -d 20210827) groups=docker append=yes&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;file模块&lt;/h4&gt;
&lt;p&gt;|参数|解释|
| --- | --- |
| path | 指定文件路径或目录 |
| owner | 属主 |
| group | 属组 |
| mode | 权限 |
| state | file/directory/link/hard/touch/absent |
| recurse | 递归设置文件属性，只对目录有效 |
| src | 当state=link时可指定该参数，表示被链接的源文件路径 |
| dest | 当state=link时可指定该参数，被链接的路径 |&lt;/p&gt;
&lt;p&gt;state参数解析
|参数|解释|
| --- | --- |
| directory | 目录不存在则创建 |
| file | 文件不存在则不会被创建，存在则返回文件信息 |
| link | 创建软链接 |
| hard | 创建硬链接 |
| touch | 如果文件不存在，则创建一个新文件，如果存在则更新最后修改时间 |
| absent | 删除目录、文件或取消链接 |&lt;/p&gt;
&lt;p&gt;用法:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 创建文件
ansible  web -i test_hosts  -m  file &amp;quot;path=/tmp/test.log state=touch&amp;quot;

# 创建软链接
ansible  web -i test_hosts  -m  file &amp;quot;state=link src=/usr/bin/vi dest=/tmp/vim&amp;quot;

# 取消软链接
ansible  web -i test_hosts  -m  file -a &amp;quot;path=/tmp/vim state=absent&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;cron模块&lt;/h4&gt;
&lt;p&gt;cron模块创建的计划任务是不可以使用&lt;code&gt;crontab -e&lt;/code&gt;命令去编辑，否则ansible无法在控制该任务&lt;/p&gt;
&lt;p&gt;|参数|解释|
| --- | --- |
| name | 任务名 |
| minute | 分钟，格式(0-59,&lt;em&gt;,&lt;/em&gt;/2)等，默认&lt;em&gt; |
| hour | 小时，格式(0-23,&lt;/em&gt;,&lt;em&gt;/2)等，默认&lt;/em&gt; |
| day | 天，格式(1-31,&lt;em&gt;,&lt;/em&gt;/2)等，默认&lt;em&gt; |
| month | 月，格式(1-12,&lt;/em&gt;,&lt;em&gt;/2)等，默认&lt;/em&gt; |
| weekday | 星期，格式(0-6,Sunday-Saturday,1,&lt;em&gt;)等，默认&lt;/em&gt; |
| job | 执行的任务 |
| state | 新增(present),删除(absent) |&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 创建一个每2分钟执行一次的计划任务
ansible  web -i test_hosts  -m  cron -a &amp;quot;name=testcron minute='*/2' job='ls /tmp' &amp;quot;

# 删除计划任务testcron
ansible  web -i test_hosts  -m  cron -a &amp;quot;name=testcron state=absent&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;debug模块&lt;/h4&gt;
&lt;p&gt;debug模块主要用来调试，打印变量结果等&lt;/p&gt;
&lt;p&gt;|参数|解释|
| --- | --- |
| var | 打印指定变量的值 |
| msg | 打印一段可以格式化的字符串 |&lt;/p&gt;
&lt;p&gt;用法:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-yml"&gt;# 打印role变量的值，-e指定一个变量role
ansible  web -i test_hosts  -m  debug -a &amp;quot;var=role&amp;quot; -e &amp;quot;role=test&amp;quot;

# 打印一串带变量的字符串,变量使用{{ xx }}括起
ansible  web -i test_hosts  -m  debug -a &amp;quot;msg='this is a {{ role }}'&amp;quot; -e &amp;quot;role=test&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;template模块&lt;/h4&gt;
&lt;p&gt;使用Jinjia2格式作为文件模板，用法和copy模块基本一样，差别是模板文件内存在变量替换&lt;/p&gt;
&lt;p&gt;|参数|解释|
| --- | --- |
| src | 指定模板文件路径 |
| dest | 指定被管理节点生成文件路径 |
| owner | 属主 |
| group | 属组 |
| mode | 权限 |
| backup | 创建一个包含时间戳的备份文件，yes/no |&lt;/p&gt;
&lt;p&gt;用法:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-yml"&gt;# 创建一个模板文件
vi test.j2
Hello {{ var }}

# 根据模板文件和传入变量生产文件
ansible  web -i test_hosts  -m  template -a &amp;quot;src=./test.j2 dest=/tmp/test&amp;quot; -e &amp;quot;var=world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;parted模块&lt;/h2&gt;
&lt;p&gt;parted模块用来对磁盘进行分区进行操作
|参数|解释|
| --- | --- |
| device | 待操作磁盘设备名称 |
| fs_type | 磁盘分区格式,默认null |
| label | |
| number | 分区号 |
| part_start | 分区开始位置 |
| part_end |  分区结束位置|
| part_type | 分区类型 extended, logical, primary，默认primary|
| state | 状态，present，absent |
| resize | 调整分区大小,默认false |
| unit | 分区默认单位，Choices: s, B, KB, KiB, MB, MiB, GB, GiB, TB, TiB, %, cyl, chs,compact.默认Kib |&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 给/dev/vdb磁盘分区
ansible -i test_hosts all -m parted -a &amp;quot;device=/dev/vdb number=1 state=present fs_type=ext4&amp;quot;

# 删除/dev/vdb磁盘分区
ansible -i test_hosts all -m parted -a &amp;quot;device=/dev/vdb number=1 state=absent &amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;lvg模块&lt;/h4&gt;
&lt;p&gt;lvg模块，卷组管理，创建、删除卷组以及动态改变卷组大小
|参数|解释|
| --- | --- |
| vg | 要创建的卷组名称 |
| pvs | 要加入到卷组的物理卷列表 |
| pesize | 指定pe大小，默认4M,默认单位M |
| state | 状态，present,absent |&lt;/p&gt;
&lt;p&gt;用法:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 将物理卷添加到卷组
ansible -i test_hosts all -m lvg -a &amp;quot;vg=centos-01 pvs=/dev/sdb1 state=present&amp;quot;

# 删除卷组
ansible -i test_hosts all -m lvg -a &amp;quot;vg=centos-01 state=absent&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;lvol模块&lt;/h4&gt;
&lt;p&gt;lvol模块，逻辑卷管理，创建删除逻辑卷&lt;/p&gt;
&lt;h4&gt;filesystem模块&lt;/h4&gt;
&lt;h4&gt;unarchive模块&lt;/h4&gt;
&lt;h4&gt;get_url模块&lt;/h4&gt;
&lt;h4&gt;stat模块&lt;/h4&gt;
&lt;h4&gt;replace模块&lt;/h4&gt;
&lt;h4&gt;lineinfile和blockinfile模块&lt;/h4&gt;
&lt;p&gt;lineinfile模块用正则匹配的方式对目标文件的一行内容修改删除，每次只修改一行内容
replace模块可以对目标文件匹配到的多行内容修改删除操作
blockinfile模块对文件进行一次性添加、修改、删除多行内容操作&lt;/p&gt;
&lt;p&gt;|参数|解释|
| --- | --- |
| path | 目标文件路径 |
| state | 替换(present)/删除(absent) |
| regexp | 正则匹配,当state=present时，仅最后一个匹配行有效 |
| line | 与state-present同时使用，要插入和修改的内容 |
| create | 文件不存在时是否创建yes/no |&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 删除
ansible  web -i test_hosts  -m  lineinfile -a &amp;quot;path=/etc/hosts regexp='^127' state=absent&amp;quot;

# 替换
ansible  web -i test_hosts  -m  lineinfile -a &amp;quot;path=/etc/selinux/config regexp='^SELINUX=' line='SELINUX=disabled' state=present
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>minio的安装</title><description>&lt;h4&gt;下载minio&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://dl.minio.io/server/minio/release/linux-amd64/minio
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;配置system启动文件&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code</description><html_content>&lt;h4&gt;下载minio&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://dl.minio.io/server/minio/release/linux-amd64/minio
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;配置system启动文件&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# cat /usr/lib/systemd/system/minio.service 
[Unit]
Description=Minio service
Documentation=https://docs.minio.io/

[Service]
WorkingDirectory=/usr/local/minio/
ExecStart=/usr/local/minio/run.sh

Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
# cat /usr/local/minio/run.sh 
#!/bin/bash
export MINIO_ACCESS_KEY=admin
export MINIO_SECRET_KEY=xxxxxxx
# 单个目录
/usr/local/minio/minio server  --address 0.0.0.0:9005  /data/minio
# 多个目录，必须大于等于4个
#/usr/local/minio/minio server  --address 0.0.0.0:9005  /data/minio/1 /data/minio/2 /data/minio/3 /data/minio/4
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>tomcat配置ssl访问</title><description>&lt;h2&gt;修改server.xml配置文件&lt;/h2&gt;
&lt;p&gt;1.打开ssl配置段,开启8443端口&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;&amp;lt;!--
    &amp;lt;Connector port=&amp;quot;8443&amp;quot;</description><html_content>&lt;h2&gt;修改server.xml配置文件&lt;/h2&gt;
&lt;p&gt;1.打开ssl配置段,开启8443端口&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;&amp;lt;!--
    &amp;lt;Connector port=&amp;quot;8443&amp;quot; protocol=&amp;quot;org.apache.coyote.http11.Http11Protocol&amp;quot;
               maxThreads=&amp;quot;150&amp;quot; SSLEnabled=&amp;quot;true&amp;quot; scheme=&amp;quot;https&amp;quot; secure=&amp;quot;true&amp;quot;
               clientAuth=&amp;quot;false&amp;quot; sslProtocol=&amp;quot;TLS&amp;quot; /&amp;gt;
 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;

&lt;p&gt;修改成&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;&amp;lt;pre class=&amp;quot;wp-block-code&amp;quot;&amp;gt;&amp;lt;code&amp;gt;&amp;lt;Connector port=&amp;quot;8443&amp;quot; protocol=&amp;quot;org.apache.coyote.http11.Http11Protocol&amp;quot;
               maxThreads=&amp;quot;150&amp;quot; SSLEnabled=&amp;quot;true&amp;quot; scheme=&amp;quot;https&amp;quot; secure=&amp;quot;true&amp;quot;
               keystoreFile=&amp;quot;conf/test.jks&amp;quot;     #keystoreFile配置证书,证书需要事先准备好
                keystorePass=&amp;quot;12345678&amp;quot;     #证书密码
                keystoreType=&amp;quot;JKS&amp;quot;  #证书类型

               clientAuth=&amp;quot;false&amp;quot; sslProtocol=&amp;quot;TLS&amp;quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改主端口配置段,添加redirectPort=”443”&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;&amp;lt;Connector port=&amp;quot;8080&amp;quot; protocol=&amp;quot;HTTP/1.1&amp;quot;
               connectionTimeout=&amp;quot;20000&amp;quot;
               acceptCount=&amp;quot;1500&amp;quot;
               enableLookups=&amp;quot;false&amp;quot;
               URIEncoding=&amp;quot;UTF-8&amp;quot;
               redirectPort=&amp;quot;8443&amp;quot;  #添加的参数
               useBodyEncodingForURI=&amp;quot;true&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置http跳转https&lt;/h2&gt;
&lt;p&gt;修改web.xml,添加如下配置&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;&amp;lt;login-config&amp;gt;
        &amp;lt;!-- Authorization setting for SSL --&amp;gt;
        &amp;lt;auth-method&amp;gt;CLIENT-CERT&amp;lt;/auth-method&amp;gt;
        &amp;lt;realm-name&amp;gt;Client Cert Users-only Area&amp;lt;/realm-name&amp;gt;
&amp;lt;/login-config&amp;gt;
&amp;lt;security-constraint&amp;gt;
        &amp;lt;!-- Authorization setting for SSL --&amp;gt;
        &amp;lt;web-resource-collection &amp;gt;
            &amp;lt;web-resource-name &amp;gt;SSL&amp;lt;/web-resource-name&amp;gt;
            &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
        &amp;lt;/web-resource-collection&amp;gt;
        &amp;lt;user-data-constraint&amp;gt;
            &amp;lt;transport-guarantee&amp;gt;CONFIDENTIAL&amp;lt;/transport-guarantee&amp;gt;
        &amp;lt;/user-data-constraint&amp;gt;
&amp;lt;/security-constraint&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>inotify-tools实时监控文件夹或文件变化</title><description>&lt;h2&gt;安装inotify-tools&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y inotify-tools
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写监控脚本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;监测到变化后需要执行的脚本
&lt;strong&gt;以文件变化自动提交gitlab为例&lt;/strong&gt;&lt;/li&gt;</description><html_content>&lt;h2&gt;安装inotify-tools&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y inotify-tools
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;编写监控脚本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;监测到变化后需要执行的脚本
&lt;strong&gt;以文件变化自动提交gitlab为例&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim auto-commit-git.sh
#!/bin/bash

DATE=`date +%Y-%m-%d`
FILE_HOME=/data/www/kode/data/User/root/home/note/
cd ${FILE_HOME} &amp;amp;&amp;amp; git add . &amp;amp;&amp;amp; git commit -m &amp;quot;${DATE}&amp;quot;;git push http://root:xxx@gitlab.xxx.com/root/note.git master
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;编写循环监控脚本&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim monitor_note.sh
#!/bin/sh

# 监视的文件或目录
filename=/data/www/kode/data/User/root/home/note

# 监视发现有增、删、改时执行的脚本
script=/data/entrypoint/scripts/auto-commit-git.sh

inotifywait -mrq --format '%e' --event create,delete,modify  $filename | while read event
  do
      case $event in MODIFY|CREATE|DELETE) bash $script ;;
      esac
  done
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;运行脚本监控目录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;chmod +x auto-commit-git.sh
chmod +x monitor_note.sh
nohup sh monitor_note.sh &amp;gt;/tmp/inotify.log 2&amp;gt;&amp;amp;1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;inotify-tools选项解析&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;@&amp;lt;file&amp;gt;     #排除不需要监视的文件，可以指定相对路径或绝对路径
--fromfile &amp;lt;file&amp;gt;   #从文件读取需要监视的文件或排除的文件，一个文件一行，排除的文件以@开头
-m|--monitor    #收到单个事件不退出，一直监视，默认：收到单个事件后立即退出
-d|--daemon     #跟--monitor一样，除了是在后台运行，需要指定--outfile把事情输出到一个文件。也意味着使用了--syslog
-o|--outfile &amp;lt;file&amp;gt;     #输出事件到&amp;lt;file&amp;gt;而不是stdout
-s|--syslog             #输出错误信息到syslog而不是stderr
-r|--recursive          #监控目录下所有子目录，创建新的子目录也会被监控
-q|--quiet              #不输出详细信息
--exclude &amp;lt;pattern&amp;gt;         #不处理正则表达式匹配到的文件的任何事件，大小写敏感
--excludei &amp;lt;pattern&amp;gt;        #不处理正则表达式匹配到的文件的任何事件，大小写敏感
 -t &amp;lt;seconds&amp;gt;, --timeout &amp;lt;seconds&amp;gt;      #设置超时时间，如果为0，则一直等待事件
 -e &amp;lt;event&amp;gt;, --event &amp;lt;event&amp;gt;        #指定监听的事件，可以多次指定，如果省略，则监听所有事件
 -c, --csv      #输出为csv格式
 --timefmt &amp;lt;fmt&amp;gt;        #指定时间格式，用于--format选项中的%T格式
 --format &amp;lt;fmt&amp;gt; 指定输出格式
     %w 表示发生事件的目录
     %f 表示发生事件的文件
     %e 表示发生的事件
     %Xe 事件以“X”分隔
     %T 使用由--timefmt定义的时间格式
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;inotify-tools事件选项解析&lt;/h2&gt;
&lt;p&gt;inotify-tools事件选项&lt;code&gt;--event&lt;/code&gt;可以监听的事件如下&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;access 读取文件或目录

modify 写文件或目录

attrib 更改文件或目录属性

close_write 文件在写后关闭

close_nowrite 文件在只读模式下被读后关闭

close  文件或目录被关闭

open   文件或目录被打开

moved_from  文件或者目录移出监视目录

moved_from  文件或目录从监视目录移出

move 文件或目录移动

create 创建文件或目录

delete 删除文件或目录

delete_self 删除后不再监听此文件或目录

unmount 文件系统取消挂载，此后不在监听该文件系统
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux经常使用的一些配置</title><description>&lt;h2&gt;centos7安装mysql客户端命令&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# mysql5.7
rpm -ivh https://repo.mysql.com//mysql57-community-release-el7-11.noarch.rpm
yum install -y</description><html_content>&lt;h2&gt;centos7安装mysql客户端命令&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# mysql5.7
rpm -ivh https://repo.mysql.com//mysql57-community-release-el7-11.noarch.rpm
yum install -y mysql-community-client

# mysql5.6
rpm -Uvh http://dev.mysql.com/get/mysql-community-release-el7-5.noarch.rpm
yum install -y mysql-community-client
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;生成root随机密码并保存到文件&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#!/bin/bash
echo &amp;quot;root&amp;quot;:\`date +%s | sha256sum | base64 | head -c 16 | tee /root/.passwd\`  | chpasswd
chattr +i /root/.passwd
chattr +i /root/.ssh/authorized_keys
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;date常用计算&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 日期，时间格式化
date '+%Y-%m-%d %H:%M:%S'
# 结果
# 2021-08-25 04:49:17


# 任意日期的前N天，后N天
date +%F -d '20210825 1 day'    #后面一天
date +%F -d '20210825 -1 day'   #前面一天

# 计算两个日期相差天数
d1=$(date +%s -d 20210820)
d2=$(date +%s -d 20210825)
echo $(((d2-d1)/86400))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;修改系统时区&lt;/h2&gt;
&lt;p&gt;修改时区为上海时区&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mv /etc/localtime{,.bak}
cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;yum 下载但不安装rpm依赖&lt;/h2&gt;
&lt;p&gt;有些时候，我们经常遇到通过yum来下载对应的rpm依赖包，而不在系统上进行安装，具体操作如下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.安装下载插件&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum -y install yum-plugin-downloadonly
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.使用命令，保存到/tmp目录&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum -y install --downloadonly --downloaddir=/tmp/
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;3.安装
注意不要指定具体的包名，否则还会从repo库寻找安装&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum localinstall *
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;jdk环境变量设置&lt;/h2&gt;
&lt;p&gt;windows:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#CLASSPATH
.;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar
#JAVA_HOME
#jdk安装路径
C:\Program Files\Java\jdk1.6.0_14(64位系统的64位版本)
C:\Program Files (x86)\Java\jdk1.6.0_14（64位系统的32位版本）
#PATH
;%JAVA_HOME%\bin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Linux:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/profile
#jdk安装路径
JAVA_HOME=/usr/java/jdk1.6.0_30/
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
PATH=$PATH:$JAVA_HOME/bin
export JAVA_HOME CLASSPATH PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;tomcat按天分割日志&lt;/h2&gt;
&lt;p&gt;一.安装cronolog分割软件&lt;/p&gt;
&lt;p&gt;```wp-block-preformatted bash
yum install -y cronolog&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;二.修改tomcat启动文件catalina.sh

```wp-block-preformatted bash
org.apache.catalina.startup.Bootstrap &amp;quot;$@&amp;quot; start \
      &amp;gt;&amp;gt; &amp;quot;$CATALINA_OUT&amp;quot; 2&amp;gt;&amp;amp;1 &amp;quot;&amp;amp;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改为&lt;/p&gt;
&lt;p&gt;```wp-block-preformatted bash
org.apache.catalina.startup.Bootstrap "$@" start 2&amp;gt;&amp;amp;1 \
        "|/usr/sbin/cronolog $CATALINA_BASE/logs/catalina.%Y-%m-%d.out" &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 "&amp;amp;"&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;## 普通用户设置开机自启(tomcat)
```bash
#配置开机自启
cat /etc/rc.local
/bin/bash /data/scripts/start_tomcat.sh
#脚本内容
cat /data/scripts/start_tomcat.sh
for i in /usr/local/tomcat_*
do
su - admin $i/bin/catalina.sh start
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;tab补全安装&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y bash-completion package
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux下redis集群数据在线迁移</title><description>&lt;h2&gt;迁移工具介绍&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;redis-migrate-tool-master.zip
#迁移工具地址:https://github.com/vipshop/redis-migrate-tool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;准备工作
-</description><html_content>&lt;h2&gt;迁移工具介绍&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;redis-migrate-tool-master.zip
#迁移工具地址:https://github.com/vipshop/redis-migrate-tool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;准备工作
- 1.在测试服务器上安装redis集群,具体安装步骤参见&lt;code&gt;linux下redis集群配置&lt;/code&gt;
- 2.向需要迁移的集群里插入部分数据
- 3.在接收迁移数据的集群查看是否能get到相关键值(很明显无法get到)&lt;/p&gt;
&lt;!--more--&gt;
&lt;h2&gt;安装迁移工具&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#安装依赖
yum install -y automake libtool autoconf bzip2
#安装迁移工具
unzip redis-migrate-tool-master.zip
cd redis-migrate-tool-master
autoreconf  -fvi
./configure
make
src/redis-migrate-tool -h
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;数据迁移&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#本环境测试的是redis cluster集群迁移到redis cluster集群
#新建配置文件rmt.conf
vim rmt.conf
[source]
type: redis cluster #集群类型 servers: – 172.16.88.174:6379 #集群节点之一

[target]
type: redis cluster #集群类型 servers: – 172.16.88.175:6379 #接收迁移数据集群节点之一

[common]
listen: 0.0.0.0:8888 #进程监听端口 

#运行迁移工具 
src/redis-migrate-tool -c rmt.conf -o log -d
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;验证&lt;/h2&gt;
&lt;p&gt;重复准备工作环境的第3点,再次在接收迁移数据的集群get对应的键值,可以get到
说明迁移成功&lt;/p&gt;</html_content></item><item><title>centos进入单用户模式修改密码</title><description>&lt;p&gt;centos进入单用户模式的方法在centos6和centos7下是有区别的，下面分开介绍两种系统进入单用户好修改密码的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;centos7&lt;/strong&gt;
- 重启系统，到内核选择界面按&lt;code&gt;e&lt;/code&gt;键
-</description><html_content>&lt;p&gt;centos进入单用户模式的方法在centos6和centos7下是有区别的，下面分开介绍两种系统进入单用户好修改密码的方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;centos7&lt;/strong&gt;
- 重启系统，到内核选择界面按&lt;code&gt;e&lt;/code&gt;键
- 找到&lt;code&gt;ro&lt;/code&gt;这一行，将其修改成&lt;code&gt;rw&lt;/code&gt;,并在&lt;code&gt;LANG=en_US.UTF-8&lt;/code&gt; 后面添加&lt;code&gt;init=/bin/sh&lt;/code&gt;
- 按键盘上的&lt;code&gt;ctrl+x&lt;/code&gt;进入单用户模式
- 使用&lt;code&gt;passwd&lt;/code&gt;命令修改密码
- 保存密码，执行&lt;code&gt;touch /.autorelabel&lt;/code&gt;然后在执行&lt;code&gt;exec /sbin/init&lt;/code&gt;()
- 重启生效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;centos6&lt;/strong&gt;
- 在系统启动读秒界面，按任意键终止读秒后按键盘&lt;code&gt;e&lt;/code&gt;键进入内核选择界面
- 通常选择第二项，也就是&lt;code&gt;kernel&lt;/code&gt;开头的那一行，按字母&lt;code&gt;e&lt;/code&gt;进入编辑模式
- 在最后面加上&lt;code&gt;1&lt;/code&gt;或者&lt;code&gt;single&lt;/code&gt;然后回车
- 按&lt;code&gt;b&lt;/code&gt;启动进入单用户模式
- 使用命令&lt;code&gt;passwd&lt;/code&gt;命令修改密码
- 重启生效&lt;/p&gt;</html_content></item><item><title>linux下mongodb数据库安装配置使用</title><description>&lt;h1&gt;mongodb的安装配置&lt;/h1&gt;
&lt;h2&gt;解压安装文件到安装目录&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;tar -C /usr/local mongodb-linux-x86_64-3.6.6.tgz 
mv /usr/local/mongodb-linux-x86_64-3.6.6</description><html_content>&lt;h1&gt;mongodb的安装配置&lt;/h1&gt;
&lt;h2&gt;解压安装文件到安装目录&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;tar -C /usr/local mongodb-linux-x86_64-3.6.6.tgz 
mv /usr/local/mongodb-linux-x86_64-3.6.6 /usr/local/mongodb
mkdir -p /data/mongodb/db
mkdir -p /data/mongodb/logs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;添加配置文件&lt;/h2&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cat  &amp;gt;&amp;gt;/etc/mongodb.conf &amp;lt;&amp;lt; EOF
# mongod.conf
# for documentation of all options, see:
# http://docs.mongodb.org/manual/reference/configuration-options/
# where to write logging data.
systemLog:
  destination: file
  logAppend: true
  path: /data/mongodb/logs/mongod.log    #设置日志目录
# Where and how to store data.
storage:
  dbPath: /data/mongodb/db    #设置数据目录
  journal:
    enabled: true
#  engine:
#  mmapv1:
#  wiredTiger:
# how the process runs
processManagement:
  fork: true  # fork and run in background
  pidFilePath: /data/mongodb/logs/mongod.pid  # location of pidfile
  timeZoneInfo: /usr/share/zoneinfo
# network interfaces
net:
  port: 27017
  bindIp: 127.0.0.1  # Listen to local interface only, comment to listen on all interfaces.
security:
  authorization: enabled
#operationProfiling:
#replication:
#sharding:
## Enterprise-Only Options
#auditLog:
#snmp:
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;启动mongo&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;/usr/local/mongodb/bin/mongod  -f /etc/mongodb.conf
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;登陆授权账户&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;/usr/local/mongodb/bin/mongo
#创建管理用户
&amp;gt;&amp;gt;use admin
&amp;gt;&amp;gt;db.createUser(
&amp;gt;&amp;gt;    {
&amp;gt;&amp;gt;      user: &amp;quot;admin&amp;quot;,
&amp;gt;&amp;gt;      pwd: &amp;quot;abcd1123&amp;quot;,
&amp;gt;&amp;gt;      roles: \[ { role: &amp;quot;root&amp;quot;, db: &amp;quot;admin&amp;quot; } \]
&amp;gt;&amp;gt;    }
&amp;gt;&amp;gt;  )
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;给非admin库授权&lt;/h2&gt;
&lt;p&gt;一.管理员账户登陆&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mongo mongodb://root@127.0.0.1:27017/admin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二.到需要授权的数据库下,使用use autest&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;use autest
db.createUser(
    {
      user: &amp;quot;dbtest&amp;quot;,
      pwd: &amp;quot;4321dbtest&amp;quot;,
      roles: \[ { role: &amp;quot;dbOwner&amp;quot;, db: &amp;quot;autest&amp;quot; } \]
    }
  )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;mongodb数据备份&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#!/bin/bash
datetime=\`date '+%Y%m%d'\`
echo $datetime
/usr/local/mongodb/bin/mongodump -o /data/mongoback/${datetime} 
cd /data/mongoback/
zip -9 -r -m ${datetime}.zip ${datetime}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;添加启动脚本&lt;/h2&gt;
&lt;p&gt;Mongo安装完成后一般都是通过命令行或脚本形式启动，下面提供了设置为服务的脚本，具体如下&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#!/bin/sh

### BEGIN INIT INFO
# Provides:     mongodb
# Required-Start:
# Required-Stop:
# Default-Start:        2 3 4 5
# Default-Stop:         0 1 6
# Short-Description: mongodb
# Description: mongo db server
### END INIT INFO

EXE_FILE=/usr/local/mongodb/bin/mongod
CONFIG_FILE=/etc/mongodb.conf

. /lib/lsb/init-functions
MONGOPID=\`ps -ef| grep mongod| grep -v grep| awk '{print $2}'\`
test -x $EXE_FILE || exit 0

case &amp;quot;$1&amp;quot; in
  start)
    ulimit -n 3000
    log\_begin\_msg &amp;quot;Starting MongoDB server&amp;quot;
    $EXE\_FILE --config $CONFIG\_FILE
    log\_end\_msg 0
    ;;
  stop)
    log\_begin\_msg &amp;quot;Stopping MongoDB server&amp;quot;
    if \[ ! -z &amp;quot;$MONGOPID&amp;quot; \]; then
        kill -15 $MONGOPID
    fi
    log\_end\_msg 0
    ;;
  status)
    ps -aux| grep mongod
    ;;
  *)
    log\_success\_msg &amp;quot;Usage: /etc/init.d/mongodb {start|stop|status}&amp;quot;
    exit 1
esac
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;mongodb简单的CRUD操作&lt;/h1&gt;
&lt;h2&gt;查看数据库&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;show dbs#显示系统所以库
show collections#显示当前库的所有集合
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mogno当中的集合也就是mysql当中的tables,数据保存在collections当中&lt;/p&gt;
&lt;h2&gt;插入数据&lt;/h2&gt;
&lt;p&gt;向user集合里面插入一条数据&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;db.users.insert({username:&amp;quot;smith&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;修改数据&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;db.users.update({username:&amp;quot;smith&amp;quot;},{$set:{country:&amp;quot;China&amp;quot;}})
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;删除数据&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;db.users.remove({username:&amp;quot;China&amp;quot;})
db.user.remove({})#干掉user集合内所有内容(清空集合)
db.user.drop()#干掉user集合(删除集合)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;查找数据&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;db.users.count()#查看集合内有多少条数据
db.users.find()
db.users.find({username:&amp;quot;smith&amp;quot;})
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux虚拟机kvm基础使用</title><description>&lt;h2&gt;kvm的安装配置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install kvm kmod-kvm qemu kvm-qemu-img virt-viewer virt-manager</description><html_content>&lt;h2&gt;kvm的安装配置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install kvm kmod-kvm qemu kvm-qemu-img virt-viewer virt-manager libvirt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;网卡配置&lt;/strong&gt;&lt;br /&gt;
- 1.安装桥接工具&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install bridge-utils tunctl
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.配置桥接&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cd /etc/sysconfig/network-scripts/

cp ifcfg-eth0 ifcfg-br0
#修改ifcg-eth0
vim ifcfg-eth0 
DEVICE=eth0
HWADDR=FC:AA:14:42:8A:4C
TYPE=Ethernet
UUID=9e1ebd3e-2606-417c-86d0-ce771d449e61
ONBOOT=yes
NM_CONTROLLED=yes
BRIDGE=br0

#修改ifcg-br0
vim ifcfg-br0 
DEVICE=br0
HWADDR=FC:AA:14:42:8A:4C
TYPE=Bridge
UUID=9e1ebd3e-2606-417c-86d0-ce771d449e61
ONBOOT=yes
NM_CONTROLLED=yes
BOOTPROTO=static
IPADDR=10.0.0.161
NETMASK=255.255.255.0
GATEWAY=10.0.0.1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;使用&lt;/h2&gt;
&lt;h3&gt;创建磁盘&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 创建磁盘
qemu-img create -f qcow2 /kvm/TEST-102.img 30G

#查看kvm磁盘格式
qemu-img info /kvm/TEST-102.img
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;调整默认网卡模式&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#vnc模式
virt-install --virt-type kvm --name TEST-102 --ram 4096  \
 --disk /data/KvmDisk/TEST-102.img,format=qcow2   --network network=default \
 --graphics vnc,listen=0.0.0.0,port=20000 --noautoconsole   \
 --os-type=linux --os-variant=rhel6   --cdrom=/data/iso/CentOS-6.5-x86_64-minimal.iso
#location模式
virt-install --name=TEST-101 --ram=4096 --vcpus=4 --os-type=linux \
--disk path=/data/KvmDisk/TEST-101.img,size=30,format=qcow2,bus=virtio,cache=writeback\
 --location=nfs://10.0.0.161:/data/CentosImg/ --network bridge=br0,model=virtio \
--mac=52:54:00:33:1F:6F --extra-args='console=ttyS'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;创建虚拟机&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;桥接模式
virt-install --name=TEST-102 \
--ram=4096 \
--vcpus=4 \
--os-type=linux \
--disk /kvm/TEST-102.img,size=20,format=qcow2,bus=virtio,cache=writeback \
--network bridge=br0,model=virtio \
--extra-args='console=ttyS0 ks=nfs:10.0.0.161:/centosinstall/ks.cfg' \
--location nfs:10.0.0.161:/centosinstall
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注释:&lt;/strong&gt;
--name 虚拟机名
--ram 内存大小
--vcpus cpu内核
--disk指定虚拟磁盘的位置,此种方式的磁盘格式是raw，不能使用快照功能,如需使用快照功能,磁盘必须是qcow2格式
qcow2格式磁盘需事先创建&lt;/p&gt;
&lt;p&gt;通过配置文件修改网卡模式&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-yaml"&gt;&amp;lt;interface type='network'&amp;gt;
      &amp;lt;mac address='52:54:00:9e:44:e0'/&amp;gt;
      &amp;lt;source network='default'/&amp;gt;
      &amp;lt;model type='virtio'/&amp;gt;
      &amp;lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&amp;gt;
&amp;lt;/interface&amp;gt;                         
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改为&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-yaml"&gt;&amp;lt;interface type='bridge'&amp;gt;
      &amp;lt;mac address='52:54:00:9e:44:e0'/&amp;gt;
      &amp;lt;source bridge='br0'/&amp;gt;
      &amp;lt;model type='virtio'/&amp;gt;
      &amp;lt;address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/&amp;gt;
&amp;lt;/interface&amp;gt;                         
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;虚拟机重命名&lt;/h3&gt;
&lt;p&gt;```wp-block-preformatted bash
virsh destroy server_monitor
cd /etc/libvirt/qemu
virsh dumpxml server_monitor &amp;gt; 192.16.1.185.xml
vim 192.16.1.185.xml&lt;/p&gt;
&lt;h1&gt;修改server_monitor为192.16.1.185&lt;/h1&gt;
&lt;p&gt;virsh undefine server_monitor
virsh define 192.16.1.185.xml
virsh start 
192.16.1.185&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;### 使用虚拟机
启动虚拟机

```bash
virsh start TEST-101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用配置文件启动虚拟机&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh create /etc/libvirt/qemu/TEST-101.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动网卡(启动默认的default网卡)&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh net-start default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;设置虚拟机开机自启动&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh autostart TEST-102
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;解除开机自启动&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh autostart --disable TEST-102
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;调整虚拟机配置&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh  edit TEST-101

#重启生效
virsh destroy TEST-101
virsh start TEST-101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关机&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh destroy TEST-101
#或者
virsh shutdown TEST-101(需虚拟机开启acpid服务)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除已有虚拟机&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh destroy TEST-101(关机)
virsh undefine TEST-101(删除)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;挂起&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh suspend TEST-101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恢复&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virs resume TEST-101
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;虚拟机迁移&lt;/h3&gt;
&lt;p&gt;迁移前需先关机&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh shutdown TEST-101
virsh dumpxml TEST-101 &amp;gt; /etc/libvirt/qemu/TEST-105.xml
virsh domblklist TEST-102 #查看磁盘文件位置
rsync -av /kvm/TEST-101.img /kvm/TEST-105.img
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;
远程迁移的话,将xml配置文件和img磁盘文件拷贝到相关目录下面,如果迁移到本机,则需要修改冲突的地方,比如:虚拟机名,磁盘路径等..&lt;/p&gt;
&lt;h3&gt;克隆虚拟机&lt;/h3&gt;
&lt;p&gt;克隆前需先关机&lt;br /&gt;
关于virsh shutdown TEST-101不起作用的说明：&lt;br /&gt;
原因：需借助虚拟机的acpid服务,所以前提是安装并开启acpid服务&lt;br /&gt;
登录虚拟机&lt;/p&gt;
&lt;p&gt;```wp-block-preformatted bash
virsh console TEST-101
yum install -y acpid
/etc/init.d/acpid start
退出连接(快捷键ctrl+])&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;克隆命令:

```bash
virt-clone --original TEST-101 --name TEST-105 --file /kvm/TEST-105.img
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;磁盘格式转换&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;qemu-img convert -f raw -O qcow2 /kvm/TEST-101.img /kvm/TEST-101.qcow2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用转换后的磁盘,需要修改虚拟机的配置文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh edit TEST-101
将type='raw'修改成type='qcow2'
将file='/kvm/TEST-101.img'修改成file='/kvm/TEST-101.qcow2'
重启虚拟机
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;快照&lt;/h3&gt;
&lt;p&gt;raw格式的磁盘无法使用快照功能,使用快照前需将磁盘转换成qcow2格式,方法见上&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh snapshot-create TEST-101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看快照&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh snapshot-list TEST-102
\[root@KVM-TEST ~\]# virsh snapshot-list TEST-102  
 Name                 Creation Time             State
 1389985501           2014-01-18 03:05:01 +0800 running
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;恢复快照&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh snapshot-revert TEST-102 1389985501
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除快照&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh snapshot-delete TEST-102 1389985501
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;磁盘扩容&lt;/h3&gt;
&lt;p&gt;raw格式磁盘扩容&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;qemu-img resize /kvm/TEST-101.img +10G
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看磁盘信息&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;qemu-img info /kvm/TEST-101.img
注：扩容后的磁盘在系统内是没有分区的,需要对其进行分区
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;增加磁盘&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;qemu-img create -f raw /kvm/TEST-101-01.img 20G
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改虚拟机配置文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh edit TEST-101
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加如下内容&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-yaml"&gt;&amp;lt;disk type='file' device='disk'&amp;gt;
      &amp;lt;driver name='qemu' type='raw' cache='writeback'/&amp;gt;
      &amp;lt;source file='/kvm/TEST-101-01.img'/&amp;gt;
      &amp;lt;target dev='vdb' bus='virtio'/&amp;gt;
      &amp;lt;address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/&amp;gt;
&amp;lt;/disk&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;重新虚拟机生效&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;
qcow2格式磁盘扩容同raw,需要注意的是&lt;br /&gt;
qemu-img resize 时提示'This image format does not support resize',则排查是否创建时添加参数'preallocation=metadata'&lt;br /&gt;
如果有此参数,则不能使用resize&lt;/p&gt;
&lt;h3&gt;查看网卡列表&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh domiflist TEST-102
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;增加网卡&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;1.临时增加网卡(重启失效)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh attach-interface TEST-101 --type bridge --source br0
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.保存到配置,重启就不会失效&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh dumpxml TEST-101 &amp;gt;/etc/libvirt/qemu/TEST-101.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以配置文件的方式重启&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;virsh create /etc/libvirt/qemu/TEST-101.xml
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;kvm重装系统&lt;/h3&gt;
&lt;p&gt;添加cdrom&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;&amp;lt;disk type='file' device='cdrom'&amp;gt;
      &amp;lt;source file='/var/lib/libvirt/images/ubuntu.iso'/&amp;gt; //光盘镜像路径
      &amp;lt;target dev='hdb' bus='ide'/&amp;gt;
&amp;lt;/disk&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改启动&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;&amp;lt;boot dev='cdrom'/&amp;gt;  // 光盘启动为首选启动项
&amp;lt;boot dev='hd'/&amp;gt;     // 硬盘启动为次要启动项
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保存后启动虚拟机，即从光盘开始启动&lt;/p&gt;</html_content></item><item><title>linux系统内网配置代理服务器实现上网</title><description>&lt;p&gt;现有一台局域网服务器A，只能内部网络访问，无法公网访问，另有一台局域网服务器B，可以进行公网访问，现要求服务器A通过服务器B进行数据传输等操作&lt;/p&gt;
&lt;p&gt;系统:ubuntu&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;apt-get update
apt-get install</description><html_content>&lt;p&gt;现有一台局域网服务器A，只能内部网络访问，无法公网访问，另有一台局域网服务器B，可以进行公网访问，现要求服务器A通过服务器B进行数据传输等操作&lt;/p&gt;
&lt;p&gt;系统:ubuntu&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;apt-get update
apt-get install tinyproxy
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h2&gt;修改配置文件&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/tinyproxy.conf
Port 8888#设置代理端口,可自己设置
ALlow127.0.0.1#允许连接的IP,设置任何IP连接，注释掉Allow行即可

注意:以根用户启动时，在初始化完成后切换 uid/gid 为 nobody/nogroup
·Port 默认监听端口为 8888(该端口无需用 root 权限绑定)
·默认在所在网卡上监听
·Logfile (必须) 日志文件, 默认 / usr/var/log/tinyproxy/tinyproxy.log，在 LogFile 文件不存在时会警告，不会运行失败。
·Pidfile (必须)pid 文件, 默认 / usr/var/run/tinyproxy/tinyproxy.pid，在 PidFile 文件不存在时会运行失败。
·StartServers 初始启动的代理服务器子进程 (默认是 10 个)
·Allow 允许使用 tinyproxy 进行 HTTP 代理的 IP 地址。默认是 127.0.0.1，如果想要公开 tinyproxy 代理服务器，则把 Allow 一行注释掉
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;代理的启动/重启/停止&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#启动
service tinyproxy start
#重启
service tinyproxy restart
#停止
service tinyproxy stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;连接测试&lt;/h2&gt;
&lt;p&gt;在服务器A输入&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;curl -x : www.baidu.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置ubuntu代理&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/profile
export http_proxy=http://服务器B:代理端口
export https_proxy=http://服务器B:代理端口 
source /etc/profile
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>nginx源码安装</title><description>&lt;h2&gt;nginx的官网下载&lt;/h2&gt;
&lt;p&gt;到nginx的官方下载站点&lt;code&gt;http://nginx.org/en/download.html&lt;/code&gt;下载想要安装的nginx版本&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget</description><html_content>&lt;h2&gt;nginx的官网下载&lt;/h2&gt;
&lt;p&gt;到nginx的官方下载站点&lt;code&gt;http://nginx.org/en/download.html&lt;/code&gt;下载想要安装的nginx版本&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget http://nginx.org/download/nginx-1.16.1.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h2&gt;安装ngninx&lt;/h2&gt;
&lt;h3&gt;解压下载文件&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;tar zxvf nginx-1.16.1.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;隐藏server信息(可选)&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vi src/http/ngx_http_header_filter_module.c ## 49-50行

内容：
static char ngx_http_server_string[] = &amp;quot;Server: nginx&amp;quot; CRLF;
static char ngx_http_server_full_string[] = &amp;quot;Server: &amp;quot; NGINX_VER CRLF;

更改为：
static char ngx_http_server_string[] = &amp;quot;Server: web-server&amp;quot; CRLF;
static char ngx_http_server_full_string[] = &amp;quot;Server:web-server &amp;quot; CRLF;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然如果只是隐藏nginx的版本号可以在nginx.conf配置&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;server_tokens off
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;进入解压目录执行编译安装&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cd nginx-1.16.1

#编译
./configure --prefix=/usr/local/nginx \
--conf-path=/etc/nginx/nginx.conf \
--modules-path=/etc/nginx/ \
--sbin-path=/usr/sbin/nginx \
--user=nginx --group=nginx \
--with-http_ssl_module \
--with-http_realip_module \
--with-http_addition_module \
--with-http_image_filter_module \
--with-http_sub_module \
--with-http_dav_module \
--with-http_flv_module \
--with-http_mp4_module \
--with-http_gzip_static_module \
--with-http_random_index_module \
--with-http_secure_link_module \
--with-http_degradation_module \
--with-http_stub_status_module \
--with-debug \
--with-http_realip_module \
--with-stream \
--with-stream_ssl_preread_module

#安装
make
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置优化nginx.conf&lt;/h2&gt;
&lt;p&gt;默认的nginx.conf文件很简单，许多参数需要自己配置，下面附上一个工作中长用的配置文件&lt;/p&gt;
&lt;p&gt;```wp-block-preformatted bash
user  www  www;
worker_processes  auto;
worker_cpu_affinity  auto;
worker_rlimit_nofile    65536;
pid/var/run/nginx.pid;
events
{
useepoll;
worker_connections65536;
}
http
{
    includemime.types;
    default_typeapplication/octet-stream;
    charset  utf-8;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;server_names_hash_bucket_size 128;
client_header_buffer_size 4k;
large_client_header_buffers 4 32k;
client_max_body_size 8m;

open_file_cache max=65536 inactive=20s;
open_file_cache_valid 30s;
open_file_cache_min_uses 1;

sendfile on;
tcp_nopush on;
keepalive_timeout 60;
tcp_nodelay on;
server_tokens off;
port_in_redirect off;

#fastcgi
fastcgi_connect_timeout300;
fastcgi_send_timeout 300;
fastcgi_read_timeout 300;
fastcgi_buffer_size 64k;
fastcgi_buffers4 64k;
fastcgi_busy_buffers_size 128k;
fastcgi_temp_file_write_size 128k;

#open gzip
gzip on;
gzip_vary on;
gzip_min_length1k;
gzip_buffers 4 16k;
gzip_http_version 1.0;
gzip_comp_level2;
gzip_typestext/plainapplication/x-javascript text/css application/xml;
gzip_disable &amp;quot;MSIE \[1-6\]\\.(?!.*SV1)&amp;quot;;

#Proxy
proxy_connect_timeout600;
proxy_read_timeout600;
proxy_send_timeout600;
proxy_buffer_size16k;
proxy_buffers432k;
proxy_busy_buffers_size64k;
proxy_temp_file_write_size64k;

#Log format
log_format  access  '$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; '
              '$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; '
              '&amp;quot;$http_user_agent&amp;quot; $http_x_forwarded_for';
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;server
    {
        listen 80 default;
        server_name _;
        return 403;
    }
    include vhosts/*.conf;
}
```&lt;/p&gt;</html_content></item><item><title>编写shell脚本常用的一些用法</title><description>&lt;h1&gt;shell脚本常用判断&lt;/h1&gt;
&lt;h2&gt;shell变量&lt;/h2&gt;
&lt;h4&gt;变量的赋值&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 赋值语句&lt;code&gt;=&lt;/code&gt;左右不能有空格&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 直接赋值：
name=&amp;quot;test&amp;quot;

# 语句赋值
for</description><html_content>&lt;h1&gt;shell脚本常用判断&lt;/h1&gt;
&lt;h2&gt;shell变量&lt;/h2&gt;
&lt;h4&gt;变量的赋值&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 赋值语句&lt;code&gt;=&lt;/code&gt;左右不能有空格&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 直接赋值：
name=&amp;quot;test&amp;quot;

# 语句赋值
for i in `ls`   #将ls的结果作为变量值
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;变量的使用&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;echo $name
echo ${name}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;变量的高级用法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当变量没有声明时，直接使用赋予默认值,语法&lt;code&gt;${var=Default}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 当name变量没有声明时，name变量的默认值是test
echo ${name=&amp;quot;test&amp;quot;}     
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;当变量没有声明或者申明的变量为空字符串时，赋予默认值,语法&lt;code&gt;${var:=Default}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;name=&amp;quot;&amp;quot;
# 此时name变量的在值为空字符串，name变量的默认值是test
echo ${name:=&amp;quot;test&amp;quot;} 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;数字运算&lt;/h2&gt;
&lt;p&gt;数字运算的两个变量必须是数字或者数字字符串，数字运算采用的语法是&lt;code&gt;$((num1 + num2))&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;数字运算符&lt;/h4&gt;
&lt;p&gt;| 符号 | 解释 | 举例 |
| ----------- | ----------- | ----------- |
| + | 加  | $((num1 + num2)) |
| - | 减 | $((num1 - num2)) |
| * |  乘 | $((num1 * num2)) |
| / | 除 | $((num1 / num2)) |
| % | 求余 | $((num1 % num2)) |
| ** | 乘方 | $((num1 ** num2)) |&lt;/p&gt;
&lt;p&gt;对于复杂运算，可以 通过括号来区分先后顺序&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 举例： 先进行num1和num2相加，在与num3相乘
$(((num1 + num2) * num3))
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;字符串&lt;/h2&gt;
&lt;p&gt;字符串的定义可以使用单引号，也可以使用双引号来定义
&lt;strong&gt;两者的区别在于&lt;/strong&gt;
    单引号字符串中引用的变量或者符合不会被解析或者转义
    双引号字符串中引用则会解析或者转义&lt;/p&gt;
&lt;h4&gt;字符串定义&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#!/bin/bash
#定义一个变量
name=&amp;quot;test string&amp;quot;

#${name}原样输出，没有变成${name}的变量值
test_string1='this is a ${name}'    
echo ${test_string1}

#${name}输出${name}的变量值
test_string2=&amp;quot;this is a ${name}&amp;quot;
echo ${test_string2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;字符串连接&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#将上面定义的两个字符串变量test_string1和test_string2连接起来输出

echo ${test_string1} ${test_string2}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;字符串长度&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#计算变量${test_string1}的长度
echo ${#test_string1}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;截取字符串&lt;/h4&gt;
&lt;h5&gt;普通截取&lt;/h5&gt;
&lt;p&gt;字符串截取下标索引从0开始&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#显示完整的字符串
echo ${test_string1}

#字符串从下标为2的位置开始输出
echo ${test_string1:2}

#字符串从下标为2的位置开始输出，并且输出长度为5
echo ${test_string1:2:5}

#从字符串从下标为-2的位置开始输出
echo ${tset_string1:(-2)}

#从字符串从下标为-2的位置开始输出，并且输出长度为5
echo ${tset_string1:(-2):5}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;字符串匹配截取&lt;/h5&gt;
&lt;p&gt;分两种
1. 从开头开始匹配，左到右
    语法:
    echo ${var#正则表达式}  截取第一个匹配到表达式后面的字符串
    echo ${var##正则表达式}  截取最后一个匹配到表达式后面的字符串&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从结尾开始匹配，从右到左
    echo ${var%正则表达式}  截取从右到左第一个匹配到表达式前面的字符串
    echo ${var%%正则表达式}  截取从右到左最后一个匹配到表达式前面的字符串&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#定义一个路径变量
test_path=/usr/local/src/sa/local/sb/src

#从左向右匹配截取
echo ${test_path#*/local}
#输出结果: /src/sa/local/sb/src


echo ${test_path##*/local}
#输出结果: sb/src



#从右向左匹配截取

echo ${test_path%/local*}
#输出结果: /usr/local/src/sa

echo ${test_path%%/local*}
#输出结果: /usr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;匹配截取的一个高级用法，用来快速截取路径和文件名&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;test_file=/var/www/html/index.html

#获取文件名
echo ${test_file##*/}

#获取文件路径
echo ${test_file%/*}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;字符串替换&lt;/h4&gt;
&lt;p&gt;字符串内置替换功能
语法：
${变量/查找正则表单/替换值} 一个"/"表示替换第一个，"//"表示替换所有&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;test_path=&amp;quot;/home/work/home/.vimrc&amp;quot;

echo ${test_path/.vimrc/.vimbashrc}
输出结果: /home/work/home/.vimbashrc

echo ${test_path/home/usr}
输出结果: /usr/work/home/.vimrc

echo ${test_path//home/usr}
输出结果: /usr/work/usr/.vimrc
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;逻辑判断&lt;/h2&gt;
&lt;p&gt;| 符号 | 解释 |
| ----------- | ----------- |
|[] |中括号一般是比较|
|() |小括号一般是判断|&lt;/p&gt;
&lt;h4&gt;字符串比较&lt;/h4&gt;
&lt;p&gt;| 符号 | 解释 |
| ----------- | ----------- |
|=|判断两个字符串是否相等|
|!=|判断两个字符串不相等|
|-n|判断字符串长度是否大于0|
|-z|判断字符串长度是否为0|
|&amp;gt;,\&amp;lt;|字符串比较大小(使用时需要加上转义字符'\')|&lt;/p&gt;
&lt;h4&gt;数字比较&lt;/h4&gt;
&lt;p&gt;| 符号 |解释 |
| ----------- | ----------- | 
| -eq | 等于 | 
|-ne |不等于 |
|-lt |小于 |
|-gt |大于 |
|-le |小于或等于 |
|-ge |大于或等于| &lt;/p&gt;
&lt;h4&gt;文件的判断&lt;/h4&gt;
&lt;p&gt;| 符号 |解释 | 
| ----------- | ----------- |
| –b  | 当file存在并且是块文件时返回真 |
| -c  | 当file存在并且是字符文件时返回真 |
| -d  | 当pathname存在并且是一个目录时返回真 |
| -e  | 当pathname指定的文件或目录存在时返回真 |
| -f  | 当file存在并且是正规文件时返回真 |
| -g  | 当由pathname指定的文件或目录存在并且设置了SGID位时返回为真 |
| -h  | 当file存在并且是符号链接文件时返回真，该选项在一些老系统上无效 |
| -k  | 当由pathname指定的文件或目录存在并且设置了“粘滞”位时返回真 |
| -p  | 当file存在并且是命令管道时返回为真 |
| -r  | 当由pathname指定的文件或目录存在并且可读时返回为真 |
| -s  | 当file存在文件大小大于0时返回真 |
| -u  | 当由pathname指定的文件或目录存在并且设置了SUID位时返回真 |
| -w  | 当由pathname指定的文件或目录存在并且可执行时返回真。一个目录为了它的内容被访问必然是可执行的。 |
| -o  | 当由pathname指定的文件或目录存在并且被子当前进程的有效用户ID所指定的用户拥有时返回真 |&lt;/p&gt;
&lt;h4&gt;复杂逻辑判断&lt;/h4&gt;
&lt;p&gt;|符号|解释|
| ----------- | ----------- |
|-a |双方都成立（and）|
|-o |单方成立（or）|
|!|非|&lt;/p&gt;
&lt;h4&gt;while循环&lt;/h4&gt;</html_content></item><item><title>centos下在线扩容lvm分区</title><description>&lt;h2&gt;lvm磁盘扩容大致步骤&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;查看并确认分区和新磁盘信息&lt;/li&gt;
&lt;li&gt;对新磁盘进行分区&lt;/li&gt;
&lt;li&gt;创建物理卷(pvdisplay查看物理卷)并将其加入需要扩容的卷组，也称逻辑卷(vgdisplay查看卷组名)&lt;/li&gt;
&lt;li&gt;卷组扩容&lt;/li&gt;
&lt;li&gt;调整分区大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;查看现有磁盘分区信息和新增磁盘信息&lt;/h2&gt;
&lt;pre</description><html_content>&lt;h2&gt;lvm磁盘扩容大致步骤&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;查看并确认分区和新磁盘信息&lt;/li&gt;
&lt;li&gt;对新磁盘进行分区&lt;/li&gt;
&lt;li&gt;创建物理卷(pvdisplay查看物理卷)并将其加入需要扩容的卷组，也称逻辑卷(vgdisplay查看卷组名)&lt;/li&gt;
&lt;li&gt;卷组扩容&lt;/li&gt;
&lt;li&gt;调整分区大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;查看现有磁盘分区信息和新增磁盘信息&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;df -h
fdisk -l
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;对新磁盘进行分区&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;fdisk /dev/sdb
n
p
1


t   
8e  #lvm格式
w   #退出保存

#格式化磁盘,具体根据磁盘分区格式决定。这里以ext4格式为例
mkfs.ext4 /dev/sdb1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;将物理卷加入卷组&lt;/h2&gt;
&lt;p&gt;将刚刚创建的新的磁盘分区创建为物理卷&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;pvcreate /dev/sdb1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;查看物理卷信息&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;pvdisplay
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;查看当前系统卷组信息，确定物理卷需要加入的卷组名&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vgdisplay
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;将pv加入vg&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;加入现有的lvm分区vg当中&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#假设`vgdisplay`显示的VGName名为centos
vgextend centos /dev/sdb1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;创建新的vg&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vgcreate lvm_data /dev/sdb1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;卷组扩容&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;现有的lvm扩容&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;lvextend -l +100%FREE /dev/mapper/centos-root
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;新创建vg创建逻辑卷&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;lvcreate -l +100%FREE -n lvmdata_1 lvm_data
mkfs.ext4 /dev/mapper/lvm_data-lvmdata_1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;查看磁盘格式并调整分区大小&lt;/h2&gt;
&lt;p&gt;改步骤对扩容lvm方式执行，对于新建lvm分区的忽略这一步&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;blkid

#ext4格式的话执行
 resize2fs /dev/mapper/centos-root
#xfs格式的话执行
xfs_growfs /dev/mapper/centos-root
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;查看扩容后分区容量是否改变&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;df -h
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;删除物理卷，逻辑卷&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;## 将已加入的物理卷移除卷组
vgreduce centos /dev/sdb1

#卷组缩减
lvreduce -L 10G /dev/mapper/centos-root

#分区缩小
resize2fs /dev/mapper/centos-root 10G

## 移除卷组上的PE,通过pvdisplay可以查看具体使用信息
pvmove /dev/sdb1
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>ldap安装、备份恢复以及密码管理</title><description>&lt;h1&gt;ldap安装&lt;/h1&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;start.sh
#!/bin/bash</description><html_content>&lt;h1&gt;ldap安装&lt;/h1&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;start.sh
#!/bin/bash -e
SERVICE=ldap-service
HOST_NAME=ldap-server
LDAP_DOMAIN=eryajf.net
LDAP_DC=eryajf
LDAP_DC_ORG=net
NETWORK_ADAPTER=eth0
PASSWORD=123456
OPENLDAP=&amp;quot;1.5.0&amp;quot;
PHPLDAPADMIN=&amp;quot;0.9.0&amp;quot;
HTTPS_PORT=88
OPENLDAP_PORT=389
docker run \
    -p ${OPENLDAP_PORT}:389 \
    --name ${SERVICE} \
    --hostname ${HOST_NAME} \
    --env LDAP_ORGANISATION=&amp;quot;WPT-Group&amp;quot; \
    --env LDAP_DOMAIN=${LDAP_DOMAIN} \
    --env LDAP_ADMIN_PASSWORD=${PASSWORD} \
    --detach osixia/openldap:${OPENLDAP}
docker run \
    -p ${HTTPS_PORT}:80 \
    --name ${SERVICE}-admin \
    --hostname ${HOST_NAME}-admin \
    --link ${SERVICE}:${HOST_NAME} \
    --env PHPLDAPADMIN_LDAP_HOSTS=${HOST_NAME} \
    --env PHPLDAPADMIN_HTTPS=false \
    --detach \
    osixia/phpldapadmin:${PHPLDAPADMIN}
sleep 1
echo &amp;quot;-----------------------------------&amp;quot;
PHPLDAP_IP=$(docker inspect -f &amp;quot;{{ .NetworkSettings.IPAddress }}&amp;quot; ${SERVICE})
docker exec ${SERVICE} ldapsearch -x -H ldap://${PHPLDAP_IP}:389 -b &amp;quot;dc=${LDAP_DC},dc=${LDAP_DC_ORG}&amp;quot; -D &amp;quot;cn=admin,dc=${LDAP_DC},dc=${LDAP_DC_ORG}&amp;quot; -w ${PASSWORD}
echo &amp;quot;-----------------------------------&amp;quot;
PUB_IP=$(ifconfig ${NETWORK_ADAPTER} |grep &amp;quot;inet&amp;quot;|awk '{print $2}')
echo &amp;quot;Go to: https://${PUB_IP}:${HTTPS_PORT}&amp;quot;
echo &amp;quot;Login DN: cn=admin,dc=${LDAP_DC},dc=${LDAP_DC_ORG}&amp;quot;
echo &amp;quot;Password: ${PASSWORD}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;创建两个基本组织People和Group&lt;/h1&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker exec -it ldap-service bash
root@ldap-server:/# cat &amp;lt;&amp;lt; EOF | ldapadd -x -D &amp;quot;cn=admin,dc=eryajf,dc=net&amp;quot; -w 123456
dn: ou=People,dc=eryajf,dc=net
objectClass: organizationalUnit
ou: people

dn: ou=Group,dc=eryajf,dc=net
objectClass: organizationalUnit
ou: group
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;创建用户&lt;/h1&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 用户一
cat &amp;lt;&amp;lt; EOF | ldapadd -x -D cn=admin,dc=eryajf,dc=net -w 123456
dn: uid=liqilong,ou=People,dc=eryajf,dc=net
uid: liqilong
cn: liqilong
sn: liqilong
displayName: liqilong
objectClass: posixAccount
objectClass: top
objectClass: person
objectClass: shadowAccount
objectClass: inetOrgPerson
gecos: System Manager
loginShell: /bin/bash
homeDirectory: /home/liqilong
userPassword: liqilong
uidNumber: 1000
gidNumber: 1009
mobile: 15638888888
mail: liqilong@eryajf.net
postalAddress: Hangzhou
EOF


# 用户二
cat &amp;lt;&amp;lt; EOF | ldapadd -x -D cn=admin,dc=eryajf,dc=net -w 123456
dn: uid=zhangsan,ou=People,dc=eryajf,dc=net
uid: zhangsan
cn: zhangsan
sn: zhangsan
displayName: zhangsan
objectClass: posixAccount
objectClass: top
objectClass: person
objectClass: shadowAccount
objectClass: inetOrgPerson
gecos: System Manager
loginShell: /bin/bash
homeDirectory: /home/zhangsan
userPassword: zhangsan
uidNumber: 1000
gidNumber: 1009
mobile: 15638888888
mail: zhangsan@eryajf.net
postalAddress: Hangzhou
EOF

# 用户三
cat &amp;lt;&amp;lt; EOF | ldapadd -x -D cn=admin,dc=eryajf,dc=net -w 123456
dn: uid=zhaosi,ou=People,dc=eryajf,dc=net
uid: zhaosi
cn: zhaosi
sn: zhaosi
displayName: zhaosi
objectClass: posixAccount
objectClass: top
objectClass: person
objectClass: shadowAccount
objectClass: inetOrgPerson
gecos: System Manager
loginShell: /bin/bash
homeDirectory: /home/zhaosi
userPassword: zhaosi
uidNumber: 1000
gidNumber: 1009
mobile: 15638888888
mail: zhaosi@eryajf.net
postalAddress: Hangzhou
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;创建用户组&lt;/h1&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cat &amp;lt;&amp;lt; EOF | ldapadd -x -D cn=admin,dc=eryajf,dc=net -w 123456
dn: cn=ops,ou=Group,dc=eryajf,dc=net
cn: ops
gidNumber: 66
objectClass: top
objectClass: posixGroup

dn: cn=dev,ou=Group,dc=eryajf,dc=net
cn: dev
gidNumber: 66
objectClass: top
objectClass: posixGroup

dn: cn=jenkins,ou=Group,dc=eryajf,dc=net
cn: jenkins
gidNumber: 66
objectClass: top
objectClass: posixGroup
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;用户 分组(将用户添加到不同的组)&lt;/h1&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 把用于加入某一个组
cat &amp;lt;&amp;lt; EOF | ldapmodify -x -D cn=admin,dc=eryajf,dc=net -w 123456
dn: cn=ops,ou=Group,dc=eryajf,dc=net
changetype: modify
add: memberuid
memberuid: liqilong

dn: cn=ops,ou=Group,dc=eryajf,dc=net
changetype: modify
add: memberuid
memberuid: zhaosi
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;数据备份&lt;/h1&gt;
&lt;h3&gt;备份&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 数据备份到/data/ldap/bak目录

mkdir /data/ldap/bak
docker exec -it ldap-service /bin/bash -c 'slapcat -v -l ldap_backup.ldif'
docker cp ldap-service:/ldap_backup.ldif  /data/ldap/bak
docker exec -it ldap-service /bin/bash -c 'rm -f /ldap_backup.ldif'
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;对备份文件进行处理(删除一些不必要的时间状态数据)&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 新建一个文件
cat &amp;gt; openldap-backup.synax &amp;lt;&amp;lt; EOF
/^creatorsName: /d
/^modifiersName: /d
/^modifyTimestamp: /d
/^structuralobjectClass: /d
/^createTimestamp: /d
/^entryUUID: /d
/^entryCSN: /d
EOF

# 根据新建文件处理备份文件后生成新的文件
cat ldap_backup.ldif | sed -f openldap-backup.synax &amp;gt; new.ldif
[root@ops-eryajf-test-2 bak]$cat ldap_backup.ldif | wc -l
178
[root@ops-eryajf-test-2 bak]$cat new.ldif | wc -l
118
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;恢复&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker cp new.ldif ldap-service:/
docker  exec -it ldap-service /bin/bash -c 'ldapadd -H ldap://192.168.10.114 -x -D &amp;quot;cn=admin,dc=dc=eryajf,dc=net&amp;quot; -f /new.ldif -w 123456'
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;恢复报错解决&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;## 报错一
ldapadd -x -D &amp;quot;cn=admin,dc=eryajf,dc=net&amp;quot; -w 123465 -f new.ldif
adding new entry &amp;quot;dc=eryajf,dc=net&amp;quot;
ldap_add: Constraint violation (19)
    additional info: structuralObjectClass: no user modification allowed
### 解决方法，过滤掉一些系统规则即可
cat &amp;gt;slapcat.regex &amp;lt;&amp;lt;EOF
/^creatorsName: /d
/^createTimestamp: /d
/^modifiersName: /d
/^modifyTimestamp: /d
/^structuralObjectClass: /d
/^entryUUID: /d
/^entryCSN: /d
EOF 

cat new.ldif | sed -f slapcat.regex &amp;gt; neww.ldif

## 报错二
ldapadd -x -D &amp;quot;cn=admin,dc=eryajf,dc=net&amp;quot; -w 123465 -f neww.ldif
adding new entry &amp;quot;dc=eryajf,dc=net&amp;quot;
ldap_add: Already exists (68)

### 解决方法
删除已经存在的条目段
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;配置self-service-password实现ldap用户自行修改和重置密码&lt;/h1&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker run -p 80:80 \
    --restart always \
    -v /home/dev/ssp.conf.php:/var/www/conf/config.inc.local.php \
    -it ltbproject/self-service-password:latest
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置&lt;/h2&gt;
&lt;p&gt;默认配置在容器内的/var/www/conf/config.inc.php,其中包含了config.inc.local.php配置项，我们只需要修改config.inc.php来进行覆盖即可&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;## ssp.conf.php
&amp;lt;?php // My SSP configuration
$keyphrase = &amp;quot;mysecret&amp;quot;;
$debug = false;
$ldap_url = &amp;quot;ldap://192.168.248.128:389&amp;quot;;
$ldap_starttls = false;
$ldap_binddn = &amp;quot;cn=admin,dc=hehutek,dc=com&amp;quot;;
$ldap_bindpw = '123456';
$ldap_base = &amp;quot;dc=hehutek,dc=com&amp;quot;;
$ldap_login_attribute = &amp;quot;uid&amp;quot;;
$ldap_fullname_attribute = &amp;quot;cn&amp;quot;;
$ldap_filter = &amp;quot;(&amp;amp;(objectClass=person)($ldap_login_attribute={login}))&amp;quot;;
$ldap_use_exop_passwd = false;
$ldap_use_ppolicy_control = false;
$use_sms = false;
$use_questions = false;
$mail_address_use_ldap = true;
$mail_from = &amp;quot;j99d99@163.com&amp;quot;;
$mail_from_name = &amp;quot;Self Service Password&amp;quot;;
$mail_signature = &amp;quot;&amp;quot;;
$notify_on_change = false;
$mail_sendmailpath = '/usr/sbin/sendmail';
$mail_protocol = 'smtp';
$mail_smtp_debug = 0;
$mail_debug_format = 'error_log';
$mail_smtp_host = 'smtp.163.com';
$mail_smtp_auth = true;
$mail_smtp_user = 'j99d99';
$mail_smtp_pass = 'YPHDGPCTWPTNEAUF';
$mail_smtp_port = 25;
$mail_smtp_timeout = 30;
$mail_smtp_keepalive = false;
$mail_smtp_secure = 'tls';
$mail_smtp_autotls = true;
$mail_smtp_options = array();
$mail_contenttype = 'text/plain';
$mail_wordwrap = 0;
$mail_charset = 'utf-8';
$mail_priority = 3;
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux安装新字体</title><description>&lt;p&gt;查看系统字体&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#安装字体查看命令 
yum install -y fontconfig mkfontscale
fc-list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看系统是否安装中文字体&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code</description><html_content>&lt;p&gt;查看系统字体&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#安装字体查看命令 
yum install -y fontconfig mkfontscale
fc-list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看系统是否安装中文字体&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;fc-list :lang=zh #返回结果为空，表示没有中文字体
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装中文字体&lt;/p&gt;
&lt;p&gt;准备需要安装的中文字体,可在windows系统上复制中文字体，windows下的路径C:\Windows\Fonts&lt;/p&gt;
&lt;p&gt;将字体上传到服务器的/usr/share/fonts目录下，比如"宋体 常规"字体simsun.ttc&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cd /usr/share/fonts/
mkfontscale
mkfontdir
fc-cache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;字体安装完成进行验证&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;fc-list :lang=zh #返回结果不为空了
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux桌面配置novnc通过web访问</title><description>&lt;h2&gt;vnc安装配置&lt;/h2&gt;
&lt;h3&gt;vnc安装&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#ubuntu
sudo apt install xserver-xorg-core tigervnc-standalone-server tigervnc-common tigervnc-xorg-extension</description><html_content>&lt;h2&gt;vnc安装配置&lt;/h2&gt;
&lt;h3&gt;vnc安装&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#ubuntu
sudo apt install xserver-xorg-core tigervnc-standalone-server tigervnc-common tigervnc-xorg-extension tigervnc-viewer
#centos
yum install -y tigervnc-server tigervnc
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h3&gt;启动&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#启动
vncserver :1
#结束
vncserver -kill :1
#查看
vncerver -list
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;novnc安装配置&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;git clone https://github.com/novnc/noVNC.git
cd noVNC/utils
./novnc_proxy --vnc localhost:5901  #vnc的连接端口

#访问:
http://$ip:6080/vnc.html
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>rabbitmq-server集群搭建以及基础配置</title><description>&lt;h2&gt;服务器信息如下:&lt;/h2&gt;
&lt;p&gt;|hosts|ip|
|----|----|
|    rabbitmq01 | 192.168.122.29 |
|    rabbitmq02 | 192.168.122.192 |
|    rabbitmq03 | 192.168.122.210 |&lt;/p&gt;
&lt;h2&gt;软件版本:&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code</description><html_content>&lt;h2&gt;服务器信息如下:&lt;/h2&gt;
&lt;p&gt;|hosts|ip|
|----|----|
|    rabbitmq01 | 192.168.122.29 |
|    rabbitmq02 | 192.168.122.192 |
|    rabbitmq03 | 192.168.122.210 |&lt;/p&gt;
&lt;h2&gt;软件版本:&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;    epel-release-latest-6.noarch.rpm
    rabbitmq-server-3.3.4-1.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置hosts&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[root@rabbitmq01 ~]# vim /etc/hosts
#设置与各系统的主机名一致,避免后面出现不必要的问题
192.168.122.29 rabbitmq01
192.168.122.192 rabbitmq02
192.168.122.210 rabbitmq03
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h2&gt;一.安装epel源&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#在集群各节点都操作,已rabbitmq01为例
[root@rabbitmq01 ~]# rpm -vih epel-release-latest-6.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二.安装erlang&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#在集群各节点都操作,已rabbitmq01为例
[root@rabbitmq01 ~]# yum install -y erlang
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;三.安装rabbitma-server&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#在集群各节点都操作,已rabbitmq01为例
[root@rabbitmq01 ~]# rpm -vih rabbitmq-server-3.3.4-1.noarch.rpm
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;四.修改数据和日志目录&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#在集群各节点都操作,已rabbitmq01为例
[root@rabbitmq01 ~]# vim /etc/rabbitmq/rabbitmq-env.conf
#指定数据存放目录
RABBITMQ_MNESIA_BASE=/data/rabbitmq/mnesia
#指定日志目录
RABBITMQ_LOG_BASE=/data/weblogs/rabbitmq
[root@rabbitmq01 ~]# mkdir -p /data/rabbitmq    #创建数据目录
[root@rabbitmq01 ~]# mkdir -p /data/weblogs/rabbitmq    #创建日志目录
[root@rabbitmq01 ~]# chown -R rabbitmq:rabbitmq /data/weblogs/rabbitmq/
[root@rabbitmq01 ~]# chown -R rabbitmq:rabbitmq /data/rabbitmq/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;五.安装rabbit的web管理界面插件&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#在集群各节点都操作,已rabbitmq01为例
[root@rabbitmq01 ~]# rabbitmq-plugins list  #查看web管理界面插件是否安装
[ ] amqp_client                       3.3.4
[ ] cowboy                            0.5.0-rmq3.3.4-git4b93c2d
[ ] eldap                             3.3.4-gite309de4
[ ] mochiweb                          2.7.0-rmq3.3.4-git680dba8
[ ] rabbitmq_amqp1_0                  3.3.4
[ ] rabbitmq_auth_backend_ldap        3.3.4
[ ] rabbitmq_auth_mechanism_ssl       3.3.4
[ ] rabbitmq_consistent_hash_exchange 3.3.4
[ ] rabbitmq_federation               3.3.4
[ ] rabbitmq_federation_management    3.3.4
[ ] rabbitmq_management               3.3.4
[ ] rabbitmq_management_agent         3.3.4
[ ] rabbitmq_management_visualiser    3.3.4
[ ] rabbitmq_mqtt                     3.3.4
[ ] rabbitmq_shovel                   3.3.4
[ ] rabbitmq_shovel_management        3.3.4
[ ] rabbitmq_stomp                    3.3.4
[ ] rabbitmq_test                     3.3.4
[ ] rabbitmq_tracing                  3.3.4
[ ] rabbitmq_web_dispatch             3.3.4
[ ] rabbitmq_web_stomp                3.3.4
[ ] rabbitmq_web_stomp_examples       3.3.4
[ ] sockjs                            0.3.4-rmq3.3.4-git3132eb9
[ ] webmachine                        1.10.3-rmq3.3.4-gite9359c7
#安装web管理界面插件
[root@rabbitmq01 ~]# rabbitmq-plugins enable rabbitmq_management
The following plugins have been enabled:
  mochiweb
  webmachine
  rabbitmq_web_dispatch
  amqp_client
  rabbitmq_management_agent
  rabbitmq_management
Plugin configuration has changed. Restart RabbitMQ for changes to take effect.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;配置rabbitmq远程web访问&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#在集群各节点都操作,已rabbitmq01为例
#拷贝rabbit配置文件到/etc/rabbitmq目录
[root@rabbitmq01 ~]# cp /usr/share/doc/rabbitmq-server-3.3.4/rabbitmq.config.example /etc/rabbitmq/rabbitmq.config
[root@rabbitmq01 ~]# vim /etc/rabbitmq/rabbitmq.config
...
[
 {rabbit,
  [%%
  {loopback_users, []}  #开启远程访问，默认账户guest,密码guest
  ]}
].
#启动服务
[root@rabbitmq01 ~]# service rabbitmq-server start
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;六.设置节点cookie，保证服务器直接cookie一致&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;rabbitmq启动后会在/var/lib/rabbitmq/目录下生成.erlang.cookie文件，集群节点的此文件需保持一致
在rabitmq01上
[root@rabbitmq01 ~]# service rabbitmq-server stop

在rabitmq02上
[root@rabbitmq02 ~]# service rabbitmq-server stop

在rabitmq03上
[root@rabbitmq03 ~]# service rabbitmq-server stop

在rabitmq01上
[root@rabbitmq01 ~]# cd /var/lib/rabbitmq/
[root@rabbitmq01 rabbitmq]# scp .erlang.cookie  root@rabbitmq02:/var/lib/rabbitmq/
拷贝cookie文件到rabbitmq02
[root@rabbitmq01 rabbitmq]# scp .erlang.cookie  root@rabbitmq03:/var/lib/rabbitmq/
拷贝cookie文件到rabbitmq03
修改属主
chown -R rabbitmq. /var/lib/rabbitmq/.erlang.cookie


使用如下命令启动rabbitmq
在rabitmq01上
[root@rabbitmq01 ~]# rabbitmq-server -detached

在rabitmq02上
[root@rabbitmq02 ~]# rabbitmq-server -detached

在rabitmq03上
[root@rabbitmq03 ~]# rabbitmq-server -detached
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;七.创建集群&lt;/h2&gt;
&lt;p&gt;将rabbitmq02与rabbitmq01组建集群&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#在rabitmq01上
#查看状态,此时显示只有rabbitmq01一个节点
[root@rabbitmq01 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@rabbitmq01 ...
[{nodes,[{disc,[rabbit@rabbitmq01]}]},
 {running_nodes,[rabbit@rabbitmq01]},
 {cluster_name,&amp;lt;&amp;lt;&amp;quot;rabbit@rabbitmq01&amp;quot;&amp;gt;&amp;gt;},
 {partitions,[]}]
...done.
#在rabitmq02上
#停止集群服务
[root@rabbitmq02 ~]# rabbitmqctl stop_app
Stopping node rabbit@rabbitmq02 ...
...done.
#将rabbitmq02加入到rabbitmq01集群，默认是disc磁盘节点，加--ram参数指定为内存节点
[root@rabbitmq02 ~]# rabbitmqctl join_cluster rabbit@rabbitmq01
Clustering node rabbit@rabbitmq02 with rabbit@rabbitmq01 ...
...done.
#启动集群服务
[root@rabbitmq02 ~]# rabbitmqctl start_app
Starting node rabbit@rabbitmq02 ...
...done.

#在rabbitmq01上
#查看状态，对比加入前有区别，发现此时多了一个rabbitmq02节点
[root@rabbitmq01 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@rabbitmq01 ...
[{nodes,[{disc,[rabbit@rabbitmq01,rabbit@rabbitmq02]}]},
 {running_nodes,[rabbit@rabbitmq02,rabbit@rabbitmq01]},
 {cluster_name,&amp;lt;&amp;lt;&amp;quot;rabbit@rabbitmq01&amp;quot;&amp;gt;&amp;gt;},
 {partitions,[]}]
...done.

#将rabbitmq03加入到rabbitmq01集群节点
#在rabbitmq03上
#停止集群服务
[root@rabbitmq03 ~]# rabbitmqctl stop_app
Stopping node rabbit@rabbitmq03 ...
...done.

#加入到rabbitmq01的集群节点，会自动与rabbitmq02节点组件成集群
[root@rabbitmq03 ~]# rabbitmqctl join_cluster rabbit@rabbitmq01
Clustering node rabbit@rabbitmq03 with rabbit@rabbitmq01 ...
...done.

#启动集群服务
[root@rabbitmq03 ~]# rabbitmqctl start_app
Starting node rabbit@rabbitmq03 ...
...done.

#在rabbitmq01上
#查看状态，对比加入前有区别，发现此时节点数为rabbitmq02,rabbitmq03也成了集群
[root@rabbitmq01 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@rabbitmq01 ...
[{nodes,[{disc,[rabbit@rabbitmq01,rabbit@rabbitmq02,rabbit@rabbitmq03]}]},
 {running_nodes,[rabbit@rabbitmq03,rabbit@rabbitmq02,rabbit@rabbitmq01]},
 {cluster_name,&amp;lt;&amp;lt;&amp;quot;rabbit@rabbitmq01&amp;quot;&amp;gt;&amp;gt;},
 {partitions,[]}]
...done.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;八.移除集群节点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;移除当前节点&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#在rabbitmq01上，查看删除节点前集群状态
[root@rabbitmq01 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@rabbitmq01 ...
[{nodes,[{disc,[rabbit@rabbitmq01,rabbit@rabbitmq02,rabbit@rabbitmq03]}]},
 {running_nodes,[rabbit@rabbitmq03,rabbit@rabbitmq02,rabbit@rabbitmq01]},
 {cluster_name,&amp;lt;&amp;lt;&amp;quot;rabbit@rabbitmq01&amp;quot;&amp;gt;&amp;gt;},
 {partitions,[]}]
...done.

#将集群节点rabbitmq03上移除rabbitmq03节点
#关闭集群节点
[root@rabbitmq03 ~]# rabbitmqctl stop_app
Stopping node rabbit@rabbitmq03 ...
...done.
#移除集群
[root@rabbitmq03 ~]# rabbitmqctl reset
Resetting node rabbit@rabbitmq03 ...
...done.

#在rabbitmq01上查看，发现集群状态显示已经没有rabbitmq03节点，说明已经删除
[root@rabbitmq01 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@rabbitmq01 ...
[{nodes,[{disc,[rabbit@rabbitmq01,rabbit@rabbitmq02]}]},
 {running_nodes,[rabbit@rabbitmq02,rabbit@rabbitmq01]},
 {cluster_name,&amp;lt;&amp;lt;&amp;quot;rabbit@rabbitmq01&amp;quot;&amp;gt;&amp;gt;},
 {partitions,[]}]
...done.
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;移除远程节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;前提是远程节点以下线
例在rabbitmq02远程下线rabbitmq01&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#关闭rabbitmq01,模拟rabbitmq01已经下线
[root@rabbitmq01 ~]# rabbitmqctl stop_app

#在rabbitmq02上
[root@rabbitmq02 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@rabbitmq02 ...
[{nodes,[{disc,[rabbit@rabbitmq01,rabbit@rabbitmq02]}]},
 {running_nodes,[rabbit@rabbitmq02]},
 {cluster_name,&amp;lt;&amp;lt;&amp;quot;rabbit@rabbitmq01&amp;quot;&amp;gt;&amp;gt;},
 {partitions,[]}]
...done.

#在rabbitmq02上
#移除远程节点前，先查看下当前集群状态
[root@rabbitmq02 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@rabbitmq02 ...
[{nodes,[{disc,[rabbit@rabbitmq01,rabbit@rabbitmq02]}]},  #节点信息显示rabbitmq01仍在集群当中
 {running_nodes,[rabbit@rabbitmq02]},   #因集群节点rabbitmq已经下线，所以运行节点只有rabbitmq02一个
 {cluster_name,&amp;lt;&amp;lt;&amp;quot;rabbit@rabbitmq01&amp;quot;&amp;gt;&amp;gt;},
 {partitions,[]}]
...done.

#移除rabbitmq01节点
[root@rabbitmq02 ~]# rabbitmqctl forget_cluster_node rabbit@rabbitmq01
Removing node rabbit@rabbitmq01 from cluster ...
...done.

#移除远程节点后，查看下当前集群状态
[root@rabbitmq02 ~]# rabbitmqctl cluster_status                       
[root@rabbitmq02 ~]# rabbitmqctl cluster_status                       
Cluster status of node rabbit@rabbitmq02 ...
[{nodes,[{disc,[rabbit@rabbitmq02]}]},  #节点信息显示只有rabbitmq02一个节点了
 {running_nodes,[rabbit@rabbitmq02]},
 {cluster_name,&amp;lt;&amp;lt;&amp;quot;rabbit@rabbitmq01&amp;quot;&amp;gt;&amp;gt;},
 {partitions,[]}]
...done.

#移除rabbitmq01后，下次启动rabbitmq01时有报错，解决如下
[root@rabbitmq01 ~]# rabbitmqctl start_app
Starting node rabbit@rabbit1 ...
Error: inconsistent_cluster: Node rabbit@rabbitmq01 thinks it's clustered with node rabbit@rabbitmq02, but rabbit@rabbit2 disagrees
[root@rabbitmq01 ~]# rabbitmqctl reset
Resetting node rabbit@rabbit1 ...done.
[root@rabbitmq01 ~]# rabbitmqctl start_app
Starting node rabbit@mcnulty ...
...done.

#还有一种报错，将节点移除集群后，无法启动。,需要删除/data/rabbitmq/下的数据目录才行
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;九.修改集群节点类型disc为ram类型&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[root@rabbitmq02 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@rabbitmq02 ...
[{nodes,[{disc,[rabbit@rabbitmq01,rabbit@rabbitmq02]}]},
 {running_nodes,[rabbit@rabbitmq01,rabbit@rabbitmq02]},
 {cluster_name,&amp;lt;&amp;lt;&amp;quot;rabbit@rabbitmq01&amp;quot;&amp;gt;&amp;gt;},
 {partitions,[]}]
...done.
[root@rabbitmq02 ~]# rabbitmqctl stop_app
Stopping node rabbit@rabbitmq02 ...
...done.
#修改为ram节点
[root@rabbitmq02 ~]# rabbitmqctl change_cluster_node_type ram
Turning rabbit@rabbitmq02 into a ram node ...
...done.
[root@rabbitmq02 ~]# rabbitmqctl start_app
Starting node rabbit@rabbitmq02 ...
...done.
[root@rabbitmq02 ~]# rabbitmqctl cluster_status
Cluster status of node rabbit@rabbitmq02 ...
[{nodes,[{disc,[rabbit@rabbitmq01]},{ram,[rabbit@rabbitmq02]}]},
 {running_nodes,[rabbit@rabbitmq01,rabbit@rabbitmq02]},
 {cluster_name,&amp;lt;&amp;lt;&amp;quot;rabbit@rabbitmq01&amp;quot;&amp;gt;&amp;gt;},
 {partitions,[]}]
...done.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;十.常用命令&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;启动集群节点
rabbitmqctl start_app
关闭集群节点
rabbitmqctl stop_app
查看集群状态
rabbitmqctl cluster_status

#关闭当前集群节点
rabbitmqctl stop
#启动当前集群节点
rabbitmq-server -detached

#添加用户，#rabbitmqctl add_userrabbitmqctl add_user admin admin@123                                                                            
# 设置用户角色 
# rabbitmqctl set_user_tags admin administrator 
#授权用户权限
rabbitmqctl set_permissions -p / admin &amp;quot;.*&amp;quot; &amp;quot;.*&amp;quot; &amp;quot;.*&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;十一.集群数据测试&lt;/h2&gt;
&lt;p&gt;第一步 在rabbitmq03上编写测试脚本&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[root@rabbitmq03 ~]# vim rabbitmq_test.py 
#!/usr/bin/env python
import os
import pika
xx=raw_input(&amp;quot;Please:&amp;quot;)
connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.122.210'))
channel = connection.channel()
channel.queue_declare(queue='HHello')
channel.basic_publish(exchange='', routing_key='HHello', body=xx)
print &amp;quot; [x] Sent 'Hello World!'&amp;quot;
connection.close()

#插入两台测试数据，此时消息未被处理
[root@rabbitmq03 ~]# python rabbitmq_test.py 
Please:xxx
 [x] Sent 'Hello World!'
[root@rabbitmq03 ~]# python rabbitmq_test.py 
Please:ccc
 [x] Sent 'Hello World!'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二步,在rabbitmq02上，查看消息队列信息&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[root@rabbitmq02 ~]# rabbitmqctl list_queues
Listing queues ...
HHello  2   #显示有两台未处理的消息
...done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第三步,在rabbitmq01上，编写处理消息脚本&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[root@rabbitmq01 ~]# vim rabbitmq_recive.py 
import pika

connection = pika.BlockingConnection(pika.ConnectionParameters('192.168.122.29'))
channel = connection.channel()
channel.queue_declare(queue='HHello')


def callback(ch, method, properties, body):
    print &amp;quot; [x] Received %r&amp;quot; % (body,)

channel.basic_consume(callback, queue='HHello', no_ack=True)

print ' [*] Waiting for messages. To exit press CTRL+C'
channel.start_consuming()
[root@rabbitmq01 ~]# python rabbitmq_recive.py  #开启处理程序
 [*] Waiting for messages. To exit press CTRL+C
 [x] Received 'xxx'   #处理两台消息
 [x] Received 'ccc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第四步,在rabbitmq02上查看刚刚的消息是否被处理&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[root@rabbitmq02 ~]# rabbitmqctl list_queues
Listing queues ...
HHello  0   #此时显示消息数为0，说明消息已经被处理
...done.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过以上测试可以从不同的3台节点看到数据的互通，测试了集群&lt;/p&gt;</html_content></item><item><title>openvpn_docker</title><description>&lt;hr /&gt;
&lt;p&gt;title: openvpn+frp实现无固定IP的vpn搭建
tags: 
  - linux
category:
  - linux
top: false
hidden: false&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;openVPN&lt;/h1&gt;
&lt;h2&gt;生成配置文件&lt;/h2&gt;
&lt;p&gt;docker run -v /data/OpenVPN/:/etc/openvpn --rm</description><html_content>&lt;hr /&gt;
&lt;p&gt;title: openvpn+frp实现无固定IP的vpn搭建
tags: 
  - linux
category:
  - linux
top: false
hidden: false&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;openVPN&lt;/h1&gt;
&lt;h2&gt;生成配置文件&lt;/h2&gt;
&lt;p&gt;docker run -v /data/OpenVPN/:/etc/openvpn --rm kylemanna/openvpn:2.4 ovpn_genconfig -u tcp://192.168.10.114&lt;/p&gt;
&lt;h2&gt;生成秘钥文件&lt;/h2&gt;
&lt;p&gt;docker run -v /data/OpenVPN/:/etc/openvpn --rm -it kylemanna/openvpn:2.4 ovpn_initpki&lt;/p&gt;
&lt;h2&gt;生成客户端证书,hehuvpntest为自定义的用户名证书，nopass 创建无密码用户&lt;/h2&gt;
&lt;p&gt;docker run -v /data/OpenVPN/:/etc/openvpn --rm -it kylemanna/openvpn:2.4 easyrsa build-client-full hehuvpntest nopass&lt;/p&gt;
&lt;h2&gt;导出证书&lt;/h2&gt;
&lt;p&gt;docker run -v /data/OpenVPN/:/etc/openvpn --rm kylemanna/openvpn:2.4 ovpn_getclient hehuvpntest &amp;gt; /tmp/conf/hehuvpntest.ovpn&lt;/p&gt;
&lt;h2&gt;启动OpenVPN服务&lt;/h2&gt;
&lt;p&gt;docker run --name openvpn --restart=always -v /data/OpenVPN/:/etc/openvpn -d -p 1194:1194 --cap-add=NET_ADMIN kylemanna/openvpn:2.4&lt;/p&gt;
&lt;h2&gt;添加用户&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#!/bin/bash
read -p &amp;quot;please your username: &amp;quot; NAME
docker run -v /data/OpenVPN/:/etc/openvpn --rm -it kylemanna/openvpn:2.4 easyrsa build-client-full $NAME nopass
docker run -v /data/OpenVPN/:/etc/openvpn --rm kylemanna/openvpn:2.4 ovpn_getclient $NAME &amp;gt; /tmp/conf/&amp;quot;$NAME&amp;quot;.ovpn
docker restart openvpn
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;删除用户&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#!/bin/bash
read -p &amp;quot;Delete username: &amp;quot; DNAME
docker run -v /data/OpenVPN/:/etc/openvpn --rm -it kylemanna/openvpn:2.4 easyrsa revoke $DNAME
docker run -v /data/OpenVPN/:/etc/openvpn --rm -it kylemanna/openvpn:2.4 easyrsa gen-crl
docker run -v /data/OpenVPN/:/etc/openvpn --rm -it kylemanna/openvpn:2.4 rm -f /etc/openvpn/pki/reqs/&amp;quot;$DNAME&amp;quot;.req
docker run -v /data/OpenVPN/:/etc/openvpn --rm -it kylemanna/openvpn:2.4 rm -f /etc/openvpn/pki/private/&amp;quot;$DNAME&amp;quot;.key
docker run -v /data/OpenVPN/:/etc/openvpn --rm -it kylemanna/openvpn:2.4 rm -f /etc/openvpn/pki/issued/&amp;quot;$DNAME&amp;quot;.crt
docker restart openvpn
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;frp server端配置&lt;/h1&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[common]
bind_port = 7000
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置systemd&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[Unit]
Description = frp server
After = network.target syslog.target
Wants = network.target

[Service]
Type = simple
# 启动frps的命令，需修改为您的frps的安装路径
ExecStart = /usr/local/frp/frps -c /usr/local/frp/frps.ini

[Install]
WantedBy = multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;frp client配置&lt;/h1&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[common]
server_addr = 121.37.216.82
server_port = 7000

[OpenVPN]
type = tcp
local_ip = 192.168.10.114
local_port = 1194
remote_port = 6000
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;配置systemd&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[Unit]
Description = frp server
After = network.target syslog.target
Wants = network.target

[Service]
Type = simple
# 启动frpc的命令，需修改为您的frpc的安装路径
ExecStart = /usr/local/frp/frpc -c /usr/local/frp/frpc.ini

[Install]
WantedBy = multi-user.target
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;测试连接&lt;/h1&gt;</html_content></item><item><title>如何修改linux的默认系统编码</title><description>&lt;h2&gt;查看系统默认编码&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;echo $LANG en_US.UTF-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code</description><html_content>&lt;h2&gt;查看系统默认编码&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;echo $LANG en_US.UTF-8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;locale
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;修改系统默认编码&lt;/h2&gt;
&lt;p&gt;第一种方法:修改il8n文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/sysconfig/i18n 
#LANG=&amp;quot;en\_US.UTF-8&amp;quot; 
LANG=&amp;quot;zh\_CN.gbk&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一种方法:修改profile文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/profile
#添加内容 
export LC\_ALL=&amp;quot;zh\_CN.GBK&amp;quot; export LANG=&amp;quot;zh_CN.GBK&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;立即生效配置&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;source /etc/profile
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>使用Xtrabackup备份恢复mysql</title><description>&lt;h4&gt;安装Xtrabackup&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;# 安装Percona的repository
yum install -y</description><html_content>&lt;h4&gt;安装Xtrabackup&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;# 安装Percona的repository
yum install -y http://www.percona.com/downloads/percona-release/redhat/0.1-4/percona-release-0.1-4.noarch.rpm
#安装xtrabackup
yum install percona-xtrabackup-24 -y
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h4&gt;建立并授权数据库备份账号&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;mysql&amp;gt; CREATE USER 'bkpuser'@'localhost' IDENTIFIED BY 's3cret';
mysql&amp;gt; GRANT RELOAD, LOCK TABLES, PROCESS, REPLICATION CLIENT ON *.* TO
       'bkpuser'@'localhost';
mysql&amp;gt; FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;配置备份存放位置&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;vim /etc/my.cnf
[xtrabackup]
target_dir = /data/backups/mysql/ #或者在命令行指定参数--target-dir=/data/backups/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;完全备份&lt;/h4&gt;
&lt;p&gt;全量备份&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;xtrabackup --user=bkpuser --password=s3cret --backup --target-dir=/data/backups/
#将数据备份到/data/backups,如果目录不存在将创建,如果目录存在且不是空目录,则会备份失败
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全量备份的数据恢复&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;1.准备恢复文件
xtrabackup --prepare --target-dir=/data/backups/
#过程不能中断，中断会无法保证恢复数据有效性
2.恢复备份
#恢复前关闭MySQL服务，并保证恢复的目录是空的
xtrabackup --copy-back --target-dir=/data/backups/
或者
rsync -avrP /data/backups/ /var/lib/mysql/
chown -R mysql:mysql /var/lib/mysql
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;增量备份&lt;/h4&gt;
&lt;h5&gt;先做全量备份&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;xtrabackup --user=bkpuser --password=s3cret --backup --target-dir=/data/backups/base
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;基于全量备份做增量备份&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt; xtrabackup --user=bkpuser --password=s3cret --backup --target-dir=/data/backups/inc1 --incremental-basedir=/data/backups/base
 xtrabackup --backup --target-dir=/data/backups/inc2 --incremental-basedir=/data/backups/inc1
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;增量备份的数据恢复&lt;/h4&gt;
&lt;h5&gt;准备数据&lt;/h5&gt;
&lt;p&gt;a.准备全量备份的数据&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;xtrabackup --prepare --apply-log-only --target-dir=/data/backups/base
#--apply-log-only是必须的，放在回滚，导致备份不可用
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;b.准备增量备份的数据&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;xtrabackup --prepare --apply-log-only --target-dir=/data/backups/base --incremental-dir=/data/backups/inc1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;c.以此类推，准备最后一个增量备份数据(注意最后一个增量文件可以不需要 参数--apply-log-only )&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;xtrabackup --prepare --target-dir=/data/backups/base --incremental-dir=/data/backups/inc2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.恢复备份&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;#恢复前关闭MySQL服务，并保证恢复的目录是空的
xtrabackup --copy-back --target-dir=/data/backups/
或者直接拷贝
rsync -avrP /data/backup/ /var/lib/mysql/
chown -R mysql:mysql /var/lib/mysql
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>linux下静默方式安装oracle 19c</title><description>&lt;h1&gt;安装前准备工作&lt;/h1&gt;
&lt;h2&gt;一、安装相关依赖包&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum -y install binutils compat-libstdc++-33 elfutils-libelf elfutils-libelf-devel elfutils-libelf-devel-static</description><html_content>&lt;h1&gt;安装前准备工作&lt;/h1&gt;
&lt;h2&gt;一、安装相关依赖包&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum -y install binutils compat-libstdc++-33 elfutils-libelf elfutils-libelf-devel elfutils-libelf-devel-static gcc gcc-c++ glibc glibc-common glibc-devel glibc-headers kernel-headers ksh libaio libaio-devel libgcc libgomp libstdc++ libstdc++-devel make sysstat unixODBC unixODBC-devel

yum -y install compat-libcap1 compat-libstdc++-33 gcc gcc-c++ glibc-devel ksh libaio-devel libaio-devel sysstat elfutils-libelf-devel fontconfig-devel libxcb smartmontools libX11 libXau libXtst libXrender libXrender-devel
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、修改内核参数&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;（root身份，没有的自行添加）
vi /etc/sysctl.conf
kernel.shmall = 2097152    //表示系统一次可以使用的共享内存总量(以页为单位)。缺省值就是2097152，通常不需要修改
kernel.shmmax = 2147483648    //定义了共享内存段的最大尺寸(以字节为单位)。缺省为32M，对于oracle来说，该缺省值太低了，通常将其设置为2G=2147483648/1024/1024/1024
kernel.shmmni = 4096   //用于设置系统范围内共享内存段的最大数量。该参数的默认值是4096 。通常不需要更改
kernel.sem = 250 32000 100 128    //表示设置的信号量
fs.file-max = 65536    //表示文件句柄的最大数量。文件句柄表示在Linux系统中可以打 开的文件数量。其实是由&amp;quot;fs.file-max = 512 * PROCESSES&amp;quot;得到的，我们指定PROCESSES的值为128，即为&amp;quot;fs.file-max =512 *128&amp;quot;。
fs.aio-max-nr = 1048576    //同时可以拥有的的异步IO请求数目。
net.ipv4.ip_local_port_range = 1024 65000    //应用程序可使用的Ipv4端口范围。
net.core.rmem_default = 262144    //默认的接收窗口大小
net.core.rmem_max = 4194304      //接收窗口的最大大小
net.core.wmem_default = 262144   //默认的发送窗口大小
net.core.wmem_max = 1048586    //发送窗口的最大大小

实例：
fs.aio-max-nr = 1048576
fs.file-max = 6815744
kernel.shmall = 2097152
kernel.shmmax = 536870912
kernel.shmmni = 4096
kernel.sem = 250 32000 100 128
net.ipv4.ip_local_port_range = 9000 65500
net.core.rmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 1048586
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使修改生效&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sysctl -p   //使修改立即生效
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;sysctl -p报错处理 &lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;error: &amp;quot;net.bridge.bridge-nf-call-ip6tables&amp;quot; is an unknown key  
error: &amp;quot;net.bridge.bridge-nf-call-iptables&amp;quot; is an unknown key  
error: &amp;quot;net.bridge.bridge-nf-call-arptables&amp;quot; is an unknown key

modprobe bridge  
lsmod | grep bridge
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;为oracle用户设置shell限制&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#vi /etc/security/limits.conf   添加以下内容
oracle           soft    nproc   2047
oracle           hard    nproc   16384
oracle           soft    nofile  1024
oracle           hard    nofile  65536

#vi /etc/pam.d/login     添加以下内容
session    required     pam_limits.so

关闭selinux
#vi /etc/selinux/config 修改为disabled
SELINUX=disabled

临时关闭命令
setenforce 0
 ```

编辑/etc/profile，添加如下内容
```bash
#vi /etc/profile
if [ $USER = &amp;quot;oracle&amp;quot; ]; then
        if [ $SHELL = &amp;quot;/bin/ksh&amp;quot; ]; then
     ulimit -p 16384
              ulimit -n 65536
        else
     ulimit -u 16384 -n 65536
        fi
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编辑/etc/csh.login,添加如下内容&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#vi /etc/csh.login
if ( $USER == &amp;quot;oracle&amp;quot; ) then
        limit maxproc 16384
        limit descriptors 65536
endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注：内核参数并非必须修改，可以根据自己实际情况而定。  以上为安装oracle的前置工作&lt;/p&gt;
&lt;h1&gt;安装oracle&lt;/h1&gt;
&lt;h2&gt;创建需要的目录&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;groupadd oinstall
groupadd oradba
useradd -g oinstall -G oradba oracle
id oracle   //查看账户是否建立完成
mkdir -p /opt/oracle
mkdir /opt/oracle/19c
chown -R oracle:oinstall /opt/oracle
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;添加oracle环境变量&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#vi /etc/profile
export ORACLE_BASE=/opt/oracle
export ORACLE_HOME=/opt/oracle/19c
export ORACLE_SID=orcl
export PATH=$PATH:$ORACLE_HOME/bin
#export ORACLE_HOSTNAME=oracledb
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:$ORACLE_HOME/rdbms/lib:$ORACLE_HOME/network/lib:/lib:/usr/lib
export CLASSPATH=$ORACLE_HOME/jlib:$ORACLE_HOME/rdbms/jlib:$ORACLE_HOME/network/jlib

#source /etc/profile
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;设置&lt;code&gt;db_install.rsp&lt;/code&gt;安装文件&lt;/h2&gt;
&lt;p&gt;编辑oracle应答文件db_install.rsp，文件存在解压目录的install/response目录下（最好将文件解压到oracle家目录/home/oracle/app下）&lt;/p&gt;
&lt;p&gt;解压安装文件
 &lt;code&gt;bash
 su - oracle
 mkdir app
 mv LINUX.X64_193000_db_home.zip app
 cd /home/oralce/app
 unzip LINUX.X64_193000_db_home.zip&lt;/code&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#vi db_install.rsp
oracle.install.option=INSTALL_DB_SWONLY
ORACLE_HOSTNAME=localhost
UNIX_GROUP_NAME=oinstall
INVENTORY_LOCATION=/opt/oracle/oraInventory
SELECTED\_LANGUAGES=en,zh_CN
ORACLE_HOME=/opt/oracle/19c
ORACLE_BASE=/opt/oracle
oracle.install.db.InstallEdition=EE
oracle.install.db.OSDBA_GROUP=oradba
oracle.install.db.OSOPER_GROUP=oradba
oracle.install.db.OSBACKUPDBA_GROUP=oradba
oracle.install.db.OSDGDBA_GROUP=oradba
oracle.install.db.OSKMDBA_GROUP=oradba
oracle.install.db.OSRACDBA_GROUP=oradba
oracle.install.db.rootconfig.executeRootScript=false

#su oracle
$./runInstaller  -silent  -responseFile /home/oracle/app/install/response/db_install.rsp -ignorePrereq
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当出现下面提示时，脚本执行正常完成&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;The following configuration scripts need to be executed as the &amp;quot;root&amp;quot; user. 
 #!/bin/sh 
 #Root scripts to run

/opt/oracle/oraInventory/orainstRoot.sh
/opt/oracle/19c/root.sh
To execute the configuration scripts:
         1. Open a terminal window 
         2. Log in as &amp;quot;root&amp;quot; 
         3. Run the scripts 
         4. Return to this window and hit &amp;quot;Enter&amp;quot; key to continue 

Successfully Setup Software.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;系统初始化&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;su root
$ORACLE_BASE/oraInventory/orainstRoot.sh
$ORACLE_HOME/root.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装网络监听器&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;su oracle
$ORACLE_HOME/bin/netca /silent /responseFile /home/oracle/app/assistants/netca/netca.rsp
查看监听器状态
$ORACLE_HOME/bin/lsnrctl status
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;安装数据库实例&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;编辑response目录下的assistants/dbca/dbca.rsp文件
#vi dbca.rsp
gdbName=orcl    //全局数据库的名字=SID+主机域名
sid=orcl            //对应的实例名字
databaseConfigType=SI
templateName=General_Purpose.dbc    //建库用的模板文件
sysPassword=xxxx        //SYS用户初始密码
systemPassword=xxxx     //SYSTEM用户初始密码
emConfiguration=NONE
dbsnmpPassword=xxxx //snmp密码
datafileDestination=/opt/oracle/oradata         //数据文件存放目录
recoveryAreaDestination=/opt/oracle/flash_recovery_area //恢复数据文件存放目录
storageType=FS  
characterSet=ZHS16GBK
nationalCharacterSet=AL16UTF16
sampleSchema=true
totalMemory=2048



保存完毕后切换到oracle身份
su oracle
$ORACLE_HOME/bin/dbca -silent -responseFile /home/oracle/app/assistants/dbca/dbca.rsp


## ORACLE的启动和关闭

```bash
su oracle

监听器的启动
$ORACLE_HOME/bin/lsnrctl start
监听器的状态查看
$ORACLE_HOME/bin/lsnrctl status

启动oracle实例
sqlplus sys as sysdba
输入密码后进入
SQL&amp;gt;startup   //启动数据库命令
或者使用命令启动
$ORACLE_HOME/bin/dbstart

关闭数据库实例
SQL&amp;gt;shutdown immediate
或者使用命令关闭
$ORACLE_HOME/bin/dbstart

关闭监听
$lsnrctl stop
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;将oracle作为服务&lt;/h2&gt;
&lt;p&gt;在root登录下&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vi /etc/init.d/oracle  复制以下文本后保存

#!/bin/sh

# chkconfig: 35 80 10 
# description: Oracle auto start-stop script.

# 
# Set ORACLE\_HOME to be equivalent to the $ORACLE\_HOME
# from which you wish to execute dbstart and dbshut;
# 
# Set ORACLE_OWNER to the user id of the owner of the
# Oracle database in ORACLE_HOME.
ORACLE_HOME=/opt/oracle/19c
ORACLE_OWNER=oracle 
if [ ! -f $ORACLE_HOME/bin/dbstart ]
then 
    echo &amp;quot;Oracle startup: cannot start&amp;quot;
    exit
fi 
case &amp;quot;$1&amp;quot; in
'start') 
# Start the Oracle databases: 
echo &amp;quot;Starting Oracle Databases ... &amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Starting Oracle Databases as part of system up.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
su - $ORACLE_OWNER -c &amp;quot;$ORACLE_HOME/bin/dbstart&amp;quot; &amp;gt;&amp;gt;/var/log/oracle
echo &amp;quot;Done&amp;quot; 

# Start the Listener: 
echo &amp;quot;Starting Oracle Listeners ... &amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Starting Oracle Listeners as part of system up.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
su - $ORACLE_OWNER -c &amp;quot;$ORACLE_HOME/bin/lsnrctl start&amp;quot; &amp;gt;&amp;gt;/var/log/oracle
echo &amp;quot;Done.&amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Finished.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
touch /var/lock/subsys/oracle
;;

'stop') 
# Stop the Oracle Listener: 
echo &amp;quot;Stoping Oracle Listeners ... &amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Stoping Oracle Listener as part of system down.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
su - $ORACLE_OWNER -c &amp;quot;$ORACLE_HOME/bin/lsnrctl stop&amp;quot; &amp;gt;&amp;gt;/var/log/oracle
echo &amp;quot;Done.&amp;quot; 
rm -f /var/lock/subsys/oracle

# Stop the Oracle Database: 
echo &amp;quot;Stoping Oracle Databases ... &amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Stoping Oracle Databases as part of system down.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
su - $ORACLE_OWNER -c &amp;quot;$ORACLE_HOME/bin/dbshut&amp;quot; &amp;gt;&amp;gt;/var/log/oracle
echo &amp;quot;Done.&amp;quot;
echo &amp;quot;&amp;quot; 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
date +&amp;quot; %T %a %D : Finished.&amp;quot; &amp;gt;&amp;gt; /var/log/oracle 
echo &amp;quot;-------------------------------------------------&amp;quot; &amp;gt;&amp;gt; /var/log/oracle
;;

'restart')
$0 stop
$0 start
;;
esac





chmod +x /etc/init.d/oracle
chkconfig --level 35 oracle on
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;错误解决&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Solution for [INS-08101] Unexpected error ‘supportedOSCheck’ while Oracle 19C Installation
解决办法:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#添加环境变量
export CV_ASSUME_DISTID=OEL8.1
#或者直接修改文件内容
cat $ORACLE_HOME/cv/admin/cvu_config | grep -i CV_ASSUME_DISTID
#CV_ASSUME_DISTID=OEL5
CV_ASSUME_DISTID=OEL8.1
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>Docker Compose的安装和常用操作</title><description>&lt;h4&gt;docker compose&lt;/h4&gt;
&lt;p&gt;Docker Compose是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。使用 compose，我们可以通过 YAML 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。&lt;/p&gt;</description><html_content>&lt;h4&gt;docker compose&lt;/h4&gt;
&lt;p&gt;Docker Compose是 docker 提供的一个命令行工具，用来定义和运行由多个容器组成的应用。使用 compose，我们可以通过 YAML 文件声明式的定义应用程序的各个服务，并由单个命令完成应用的创建和启动。&lt;/p&gt;</html_content></item><item><title>linux设置普通用户使用docker命令</title><description>&lt;ol&gt;
&lt;li&gt;创建普通用户test&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;useradd test
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;创建docker用户组，并将新建的用户加入docker用户组&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code</description><html_content>&lt;ol&gt;
&lt;li&gt;创建普通用户test&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;useradd test
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;创建docker用户组，并将新建的用户加入docker用户组&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;groupadd docker
groups
usermod -a -G docker test
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;重启docker服务生效&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>docker教程之-docker swarm常用操作</title><description>&lt;p&gt;docker service 命令用来管理docker swarm集群中的服务，该命令只能运行在管理节点上,是docker swarm的命令行工具&lt;/p&gt;
&lt;p&gt;docker service 常用命令&lt;/p&gt;
&lt;p&gt;创建服务&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker service</description><html_content>&lt;p&gt;docker service 命令用来管理docker swarm集群中的服务，该命令只能运行在管理节点上,是docker swarm的命令行工具&lt;/p&gt;
&lt;p&gt;docker service 常用命令&lt;/p&gt;
&lt;p&gt;创建服务&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker service create --name nginx --replicas 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更新服务&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#格式
#docker service update --image 镜像地址 $server_name
docker service  update --with-registry-auth --image nginx:1.19.1 nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看服务&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker service ls
#搜索某个服务
docker service ps nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;扩展伸缩服务，即对服务运行数量进行调整&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker service scale nginx=4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除服务&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker service rm nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;显示详细信息&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker service inspect nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看某个服务的日志&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker service logs nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker stack常用命令&lt;/p&gt;
&lt;p&gt;上面介绍了docker swarm的命令行管理方式，而docker stack命令可以用来通过yaml格式文件创建应用，通常编排好一个yaml格式的文件后，可以通过以下命令创建&lt;/p&gt;
&lt;p&gt;通过yaml文件创建更新应用&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker stack deploy -c docker-stack.yml nginx 
#如果是私有仓库，需要加上参数--with-registry-auth才会下载镜像
docker stack deploy -c docker-stack.yml --with-registry-auth nginx 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看swarm集群当前跑了多少个stack(个人理解它类似于k8s里的命名空间)his &lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker stack ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;列出nginx这个stack中的服务&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker stack services nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看nginx这个stack中的任务&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker stack ps nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;删除&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker stack rm nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除nginx这个&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker stack down nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker-stack.yml样例&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-yaml"&gt;version:'3.4'
services:
  #服务名
  redis:
    image: redis:4.0.14-alpine
    command: redis-server --appendonly yes --requirepass &amp;quot;123456&amp;quot;
    ports:
      - 8080:80
    volumes:
      - &amp;quot;/data/redis:/data/redis&amp;quot;
    environment:
      APP： test
    deploy:
      #用户可以指定副本数量。默认也是这个值，可以省略
      mode: replicated
      replicas: 2
      #更新策略
      update_config:
        #每组容器更新之间的延迟时间
        delay: 10
      #重启策略
      restart_policy:
        #重启条件
        condition: on-failure
      #根据节点标识绑定节点
      placement:
        constraints: [node.role == manager]
    networks:
      - multihost

networks:
  multihost:
    driver: overlay

volumes:
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>docker教程之-Dockerfile书写</title><description>&lt;p&gt;Dockerfile是可以被docker程序解释的脚本。由一条条命令组合而成。我们可以通过编写Dockerfile文件将应用根据自己的需求打包成docker镜像。也可以避免重复去修改镜像。&lt;/p&gt;
&lt;p&gt;Dockerfile文件开头的D必须大写，在构建docker镜像的时候，通常寻找当前目录下的Dockerfile文件&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;Dockerfile</description><html_content>&lt;p&gt;Dockerfile是可以被docker程序解释的脚本。由一条条命令组合而成。我们可以通过编写Dockerfile文件将应用根据自己的需求打包成docker镜像。也可以避免重复去修改镜像。&lt;/p&gt;
&lt;p&gt;Dockerfile文件开头的D必须大写，在构建docker镜像的时候，通常寻找当前目录下的Dockerfile文件&lt;/p&gt;
&lt;!--more--&gt;

&lt;p&gt;Dockerfile 常用命令介绍&lt;/p&gt;
&lt;p&gt;在编写Dockerfile的时候，Dockerfile的命令总是大写。下面来看看常用的Dockerfile命令吧&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FORM&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;每个Dockerfile文件的开头都是FORM命令，后面跟着一个基础镜像，表示该Dockerfile文件基于这个基础镜像来进行构建&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MAINTAINER&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;镜像维护者的基础信息&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WORKDIR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;指定工作目录，注意区分绝对路径和相对路径&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ENV和ARG&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;设置容器的环境变量，格式为key=value,当有多个变量时使用空格隔开&lt;/p&gt;
&lt;p&gt;ARG构建参数，在构建docker镜像时使用的环境变量，后续容器运行时不存在这些环境变量。这和ENV有区别&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RUN&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行命令，一个Dockerfile可以有多个RUN，按照定义顺序执行。根据Dockerfile的构建规则，每执行一条命令，镜像就会多一层。会导致镜像臃肿。所以使用RUN命令的时候最好是多条能一起执行的语句都放在一个RUN命令内执行掉。RUN有两种运行格式，一种shell方式，一种参数列表方式.&lt;/p&gt;
&lt;p&gt;shell格式&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;RUN echo 'This is a test ..'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;exec格式,可执行文件需要是具体路径,使用双引号&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;RUN [&amp;quot;/usr/bin/echo&amp;quot;,&amp;quot;this is a test&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;COPY和ADD&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;COPY的时候有几种注意情况&lt;/p&gt;
&lt;p&gt;当目标路径看不出是目录还是还是文件的时候，会根据原路径文件或目录名的属性自动拷贝并重命名&lt;/p&gt;
&lt;p&gt;例如下面的&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;COPY dir /mydir
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当dir为文件时，mydir也是文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当dir为目录时，mydir是目录，相当于拷贝dir为mydir&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;区别于上面的命令，当目录路径是目录的时候，如果该目录不存在会先在容器内新建该文件夹，然后如果是文件则将文件拷贝到该目录，如果是目录则将目录里的内容拷贝到mydir文件夹内。&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;COPY dir /mydir/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ADD的使用和COPY一样，不过功能跟强大一些。与COPY相同的请参考COPY使用，这里介绍增加的功能。主要有两个不同点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果拷贝的是一个压缩文件，ADD命令会将其拷贝并解压到目标目录&lt;/li&gt;
&lt;li&gt;如果拷贝的文件是一个url的连接形式，ADD命令会自动从该url将文件下载后解压到目标目录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，当只是想单纯的拷贝一个文件或者压缩包的时候，建议使用COPY命令。如果拷贝后需要解压建议使用ADD命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CMD&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;一个Dockerfile文件中，只能有一个CMD命令，如果有多个，最后一个有效。CMD主要用来提供容器启动执行命令提供默认值。可以包含可执行文件，也可以省略，当省略可执行文件的时候，必须制定ENTRYPOINT命令&lt;/p&gt;
&lt;p&gt;CMD 有三种运行格式，shell格式，exec格式和参数列表格式。使用exec格式，容器内启动的任务进程pid为1。当使用参数列表格式时，必须指定ENTRYPOINT命令&lt;/p&gt;
&lt;p&gt;为ENTRYPOINT命令提供默认参数&lt;/p&gt;
&lt;p&gt;CMD ["param1","param2"]
另外两种使用方式分别是 exec 模式和 shell 模式：
CMD ["executable","param1","param2"]    // 这是 exec 模式的写法，注意需要使用双引号。
CMD command param1 param2&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ENTRYPOINT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CMD和ENTRYPOINT两者的目的一样，都是用来指定容器启动程序及参数的。如果指定了ENTRYPOINT命令，则CMD参数就不在是容器启动命令了。此时CMD的内容将作为参数传递给ENTRYPOINT命令。&lt;/p&gt;
&lt;p&gt;ENTRYPOINT两种使用方式分别是 exec 模式和 shell 模式：
ENTRYPOINT ["executable","param1","param2"]    // 这是 exec 模式的写法，注意需要使用双引号。
ENTRYPOINT command param1 param2&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;指定 ENTRYPOINT  指令为 exec 模式时，命令行上指定的参数会作为参数添加到 ENTRYPOINT 指定命令的参数列表中&lt;/li&gt;
&lt;li&gt;由 CMD 指令指定默认的可选参数，当命令行没有指定参数时使用该默认参数&lt;/li&gt;
&lt;li&gt;指定 ENTRYPOINT  指令为 shell 模式时，会完全忽略命令行参数&lt;/li&gt;
&lt;li&gt;需要覆盖默认的 ENTRYPOINT 指令时，在启动容器的时候使用--entrypoint参数来指定覆盖命令&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是几个Dockerfile样例&lt;/p&gt;
&lt;p&gt;nginx源码编译安装Dockerfile&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;FROM centos
MAINTAINER chognlai
COPY nginx-1.19.1.tar.gz /tmp
RUN tar -xvf /tmp/nginx-1.19.1.tar.gz -C /tmp/ \
        &amp;amp;&amp;amp; cd /tmp/nginx-1.19.1 \
        &amp;amp;&amp;amp; yum install -y gcc-c++ gd-devel pcre-devel openssl-devel make \
        &amp;amp;&amp;amp; useradd nginx -s /sbin/nologin \
        &amp;amp;&amp;amp; ./configure --prefix=/usr/local/nginx \
        --conf-path=/etc/nginx/nginx.conf \
        --modules-path=/etc/nginx/  \
        --sbin-path=/usr/sbin/nginx \
        --user=nginx --group=nginx \
        --with-http_ssl_module \
        --with-http_realip_module \
        --with-http_addition_module \
        --with-http_image_filter_module \
        --with-http_sub_module \
        --with-http_dav_module \
        --with-http_flv_module \
        --with-http_mp4_module \
        --with-http_gzip_static_module  \
        --with-http_random_index_module \
        --with-http_secure_link_module \
        --with-http_degradation_module  \
        --with-http_stub_status_module \
        --with-debug \
        --with-http_realip_module  \
        --with-stream \
        --with-stream_ssl_preread_module \
        &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install

#优化后的nginx.conf文件
COPY nginx.conf /etc/nginx/
EXPOSE 80 443
VOLUME /etc/nginx/vhosts

CMD [&amp;quot;nginx&amp;quot;,&amp;quot;-g&amp;quot;,&amp;quot;daemon off;&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mysql&lt;/p&gt;
&lt;p&gt;基于官方镜像修改后的Dockerfile&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;FROM mysql:5.7.30
MAINTAINER chonglai
COPY my.cnf /etc/mysql/my.cnf

VOLUME /var/lib/mysql
EXPOSE 3306

CMD [&amp;quot;mysqld&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;nginx+php&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;FROM centos:7
MAINTAINER chognlai

RUN yum install -y wget epel-release &amp;amp;&amp;amp; \
        wget https://rpms.remirepo.net/enterprise/remi-release-7.rpm \
        &amp;amp;&amp;amp; rpm -vih remi-release-7.rpm \
        &amp;amp;&amp;amp; yum install -y php74-php-fpm php74-php-gd php74-php-mbstring


COPY nginx-1.19.1.tar.gz /tmp
RUN tar -xvf /tmp/nginx-1.19.1.tar.gz -C /tmp/ \
        &amp;amp;&amp;amp; cd /tmp/nginx-1.19.1 \
        &amp;amp;&amp;amp; yum install -y gcc-c++ gd-devel pcre-devel openssl-devel make \
        &amp;amp;&amp;amp; useradd nginx -s /sbin/nologin \
        &amp;amp;&amp;amp; ./configure --prefix=/usr/local/nginx \
        --conf-path=/etc/nginx/nginx.conf \
        --modules-path=/etc/nginx/  \
        --sbin-path=/usr/sbin/nginx \
        --user=nginx --group=nginx \
        --with-http_ssl_module \
        --with-http_realip_module \
        --with-http_addition_module \
        --with-http_image_filter_module \
        --with-http_sub_module \
        --with-http_dav_module \
        --with-http_flv_module \
        --with-http_mp4_module \
        --with-http_gzip_static_module  \
        --with-http_random_index_module \
        --with-http_secure_link_module \
        --with-http_degradation_module  \
        --with-http_stub_status_module \
        --with-debug \
        --with-http_realip_module  \
        --with-stream \
        --with-stream_ssl_preread_module \
        &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install

COPY nginx.conf /etc/nginx/
EXPOSE 80 443
VOLUME /etc/nginx/vhosts

CMD /opt/remi/php74/root/sbin/php-fpm &amp;amp;&amp;amp; nginx -g &amp;quot;daemon off;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Dockerfile的构建命令如下：&lt;/p&gt;
&lt;p&gt;docker build -t name:tag .&lt;/p&gt;</html_content></item><item><title>构建nginx+php-fpm的docker镜像</title><description>&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;
    此Dockerfile整合了nginx和php-fpm环境&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code class="language-yaml"&gt;FROM centos:7
MAINTAINER chognlai

RUN yum install -y wget epel-release</description><html_content>&lt;p&gt;&lt;strong&gt;说明&lt;/strong&gt;
    此Dockerfile整合了nginx和php-fpm环境&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code class="language-yaml"&gt;FROM centos:7
MAINTAINER chognlai

RUN yum install -y wget epel-release &amp;amp;&amp;amp; \
        wget https://rpms.remirepo.net/enterprise/remi-release-7.rpm \
        &amp;amp;&amp;amp; rpm -vih remi-release-7.rpm \
        &amp;amp;&amp;amp; yum install -y php74-php-fpm php74-php-gd php74-php-mbstring


COPY nginx-1.19.1.tar.gz /tmp
RUN tar -xvf /tmp/nginx-1.19.1.tar.gz -C /tmp/ \
        &amp;amp;&amp;amp; cd /tmp/nginx-1.19.1 \
        &amp;amp;&amp;amp; yum install -y gcc-c++ gd-devel pcre-devel openssl-devel make \
        &amp;amp;&amp;amp; useradd nginx -s /sbin/nologin \
        &amp;amp;&amp;amp; ./configure --prefix=/usr/local/nginx \
        --conf-path=/etc/nginx/nginx.conf \
        --modules-path=/etc/nginx/  \
        --sbin-path=/usr/sbin/nginx \
        --user=nginx --group=nginx \
        --with-http_ssl_module \
        --with-http_realip_module \
        --with-http_addition_module \
        --with-http_image_filter_module \
        --with-http_sub_module \
        --with-http_dav_module \
        --with-http_flv_module \
        --with-http_mp4_module \
        --with-http_gzip_static_module  \
        --with-http_random_index_module \
        --with-http_secure_link_module \
        --with-http_degradation_module  \
        --with-http_stub_status_module \
        --with-debug \
        --with-http_realip_module  \
        --with-stream \
        --with-stream_ssl_preread_module \
        &amp;amp;&amp;amp; make &amp;amp;&amp;amp; make install

COPY nginx.conf /etc/nginx/
EXPOSE 80 443
VOLUME /etc/nginx/vhosts

CMD /opt/remi/php74/root/sbin/php-fpm &amp;amp;&amp;amp; nginx -g &amp;quot;daemon off;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>docker容器常用操作</title><description>&lt;h4&gt;docker容器操作常用命令&lt;/h4&gt;
&lt;h4&gt;创建并启动一个容器&lt;/h4&gt;
&lt;p&gt;启动容器有两种方式，一种是以交互式启动，即启动后就直接进入到容器内部进行交互操作，还有一种就是以守护进程(后台运行)启动。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;创建容器命令
docker run [OPTIONS] 镜像名:标签名</description><html_content>&lt;h4&gt;docker容器操作常用命令&lt;/h4&gt;
&lt;h4&gt;创建并启动一个容器&lt;/h4&gt;
&lt;p&gt;启动容器有两种方式，一种是以交互式启动，即启动后就直接进入到容器内部进行交互操作，还有一种就是以守护进程(后台运行)启动。&lt;/p&gt;
&lt;!--more--&gt;
&lt;p&gt;创建容器命令
docker run [OPTIONS] 镜像名:标签名 命令&lt;/p&gt;
&lt;p&gt;[OPTIONS]常用参数说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-i 交互式运行容器(创建后马上启动容器并进入容器),通常与-t同时使用&lt;/li&gt;
&lt;li&gt;-t 启动后会进入容器命令行,通常与-i同时使用&lt;/li&gt;
&lt;li&gt;--name 为创建的容器指定一个名称&lt;/li&gt;
&lt;li&gt;-d 创建一个守护式容器在后台运行并返回容器ID&lt;/li&gt;
&lt;li&gt;-v 表示目录映射,格式为：-v 宿主机目录:容器目录&lt;/li&gt;
&lt;li&gt;-p 表示端口映射,格式为: -p 宿主机端口:容器端口&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;容器需要一个保持前台运行的进程。可以在启动容器的时候指定前台运行的命令，不指定则默认运行镜像内的命令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建交互式容器&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker run -it --name=dockertest centos:7 /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;特殊使用&lt;/strong&gt;,交互式启动时加上--rm参数后，容器运行一次就结束并删除容器。通常用来测试某条命令在容器内执行结果时使用&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker run -it  --rm --name=dockertest centos:7 ip addr
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;strong&gt;创建守护式容器&lt;/strong&gt;&lt;/h5&gt;
&lt;p&gt;守护式容器,俗称后台运行的容器，通常加上--restart=always参数，如果容器退出了会自动重启&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker  run -d --name=mycentos --restart=always centos:7
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;&lt;/h5&gt;
&lt;h4&gt;宿主机与容器文件拷贝&lt;/h4&gt;
&lt;p&gt;通过docker cp 命令可以将宿主机文件拷贝到容器内,也可以将容器内文件拷贝到宿主机&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;宿主机拷贝到容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker cp 宿主机文件或目录 容器名称:容器文件或目录
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;容器文件拷贝到宿主机&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker cp 容器名称:容器文件或目录 宿主机文件或目录
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;数据目录挂载&lt;/h4&gt;
&lt;p&gt;在创建容器的时候,将宿主机目录与容器目录进行映射,这样就可以 通过修改宿主机某个目录的文件从而去影响容器,挂载目录使用-v参数&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker run -d -v 宿主机绝对路径目录：容器内目录 --name=容器名 镜像名
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例:
创建容器时将宿主机目录/opt 挂载到容器目录/opt&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker run -d -v /opt:/opt --name=mycentos centos:7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目录挂载只读权限&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker run -d -v 宿主机绝对路径目录:容器内目录:ro --name=容器名 镜像名
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;端口映射&lt;/h4&gt;
&lt;p&gt;在创建容器的时候，经常需要将容器内部的应用端口暴露出来供外部访问。通常使用-p参数来映射端口,如果有多个端口需要映射，就多次使用-p参数即可。如果宿主机映射端口不指定的话，将随机映射一个端口&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#基本语法:
docker run -d -p 宿主机IP:宿主机端口:容器端口/协议类型(tcp/udp)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;几个举例&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#将容器的22端口映射到本机的2222端口
docker run -d -p 2222:22 --name=mycentos centos:7
#映射端口时也可以绑定本机IP，将容器22端口映射到本机2222端口并绑定127.0.0.1
docker run -d -p 127.0.0.1:2222:22 --name=mycentos centos:7
#映射时指定端口协议
docker run -d -p 2222:22/tcp --name=mycentos centos:7
#随机映射端口
docker run -d -p 127.0.0.1::22 --name=mycentos centos:7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看容器映射了哪些端口&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#查看上述举例的映射端口
docker port mycentos 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;启动与停止已存在的容器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;启动容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker start 容器名称|容器ID
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;启动所有容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker start `docker ps -a -q`
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;正常停止正在运行的docker容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker stop 容器名称|容器ID
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;强行停止正在运行的容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker  kill 容器名称|容器ID
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;停止所有在运行的容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker stop `docker ps -a -q`
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;查看容器&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker ps 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;CONTAINER ID 容器ID&lt;/li&gt;
&lt;li&gt;IMAGE 镜像&lt;/li&gt;
&lt;li&gt;COMMAND 初始命令&lt;/li&gt;
&lt;li&gt;CREATED 创建日期&lt;/li&gt;
&lt;li&gt;STATUS  容器状态&lt;/li&gt;
&lt;li&gt;PORTS  端口号&lt;/li&gt;
&lt;li&gt;NAMES 容器名字&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;查看所有容器,包括已退出的容器&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker ps -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看最后一次运行的容器&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker ps -l
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看停止的容器&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker ps -f status=exited
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;删除容器&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;删除指定容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker  rm 容器名称|容器ID
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;删除所有容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker rm `docker ps -a -q`
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;删除所有不在运行的容器&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker rm `docker ps -a -q -f status=exited`
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;进入容器&lt;/h4&gt;
&lt;p&gt;进入启动的容器有好几种方式，下面介绍两种常见的方法&lt;/p&gt;
&lt;p&gt;第一种：docker exec命令&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker exec -it 容器名称|容器ID /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过docker exec登录的容器的退出,输入"exit"退出不停止容器&lt;/p&gt;
&lt;p&gt;第二种：nsenter命令&lt;/p&gt;
&lt;p&gt;nsenter命令通过容器的pid进入容器。该命令不是系统自带的，需要安装，具体安装也很简单，直接yum安装即可&lt;/p&gt;
&lt;p&gt;安装nsenter&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;yum install -y util-linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进入容器&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#查看容器pid
docker inspect -f &amp;quot;{{.State.Pid}}&amp;quot; mycentos
#进入容器,shell可以指定shell,不指定默认使用的是/bin/bash.
nsenter -t Pid -m -u -i -n -p /bin/sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;查看容器内部细节&lt;/h4&gt;
&lt;p&gt;查看容器的详细信息，可以通过docker inspect命令查看。不带参数则显示所有的信息&lt;/p&gt;
&lt;p&gt;docker inspect 参数 容器名|容器ID&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#查看容器IP地址
docker inspect --format='{{.NetworkSettings.IPAddress}}' mycentos
#查看容器Pid
docker inspect -f &amp;quot;{{.State.Pid}}&amp;quot; mycentos
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>docker教程之-docker swarm集群管理</title><description>&lt;h5&gt;创建集群&lt;/h5&gt;
&lt;p&gt;安装docker&lt;/p&gt;
&lt;p&gt;配置host以及免秘钥登录&lt;/p&gt;
&lt;p&gt;创建管理集群&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code&gt;#docker swarm init --advertise-addr &amp;lt;Master_ip&amp;gt;:&amp;lt;Master_port&amp;gt;
docker swarm init</description><html_content>&lt;h5&gt;创建集群&lt;/h5&gt;
&lt;p&gt;安装docker&lt;/p&gt;
&lt;p&gt;配置host以及免秘钥登录&lt;/p&gt;
&lt;p&gt;创建管理集群&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code&gt;#docker swarm init --advertise-addr &amp;lt;Master_ip&amp;gt;:&amp;lt;Master_port&amp;gt;
docker swarm init --advertise-addr 172.16.88.202:2377
#查看详解
docker info
#查看节点
docker node ls
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加节点到集群&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;#在节点集群执行
#docker swarm join --token &amp;lt;Token&amp;gt; &amp;lt;Master_ip&amp;gt;:&amp;lt;Master_port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;提升node为manage&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker node promote &amp;lt;Slave_IP&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;降级manage为node&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker node demote &amp;lt;Slave_IP&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;master不参与工作&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;docker node update --availability drain &amp;lt;Master_ip&amp;gt;:&amp;lt;Master_port&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;移除集群&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;#在node节点操作
docker swarm leave
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;​   &lt;/p&gt;
&lt;p&gt;docker允许同时存在本地运行和集群运行，启动容器的语法相同，区别在于&lt;/p&gt;
&lt;p&gt;docker run运行的容器是本地运行&lt;/p&gt;
&lt;p&gt;docker service 运行的容器是集群方式运行&lt;/p&gt;</html_content></item><item><title>docker命令安装常用服务</title><description>&lt;h2&gt;nginx的安装&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#下载nginx初始配置文件
wget http://download.izcat.com/file/nginx-docker.tar.gz
tar zxvf nginx-docker.tar.gz -C /etc/
sh</description><html_content>&lt;h2&gt;nginx的安装&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#下载nginx初始配置文件
wget http://download.izcat.com/file/nginx-docker.tar.gz
tar zxvf nginx-docker.tar.gz -C /etc/
sh /etc/nginx-start.sh

# nginx-start.sh
docker run -d --name nginx --restart=always \
        -v /etc/nginx/:/etc/nginx/ \
        -p 80:80 -p 443:443 \
        nginx:1.21
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;mongodb的安装&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-shell"&gt;docker run -e MONGO_INITDB_ROOT_USERNAME=$admin \
    -e MONGO_INITDB_ROOT_PASSWORD=$password \
    --name jifen-mongo -v /data/mongo/db:/data/db \
    --restart=always \
    -p 27017:27017 \
    -d mongo
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>centos系统安装docker</title><description>&lt;h3&gt;docker的安装&lt;/h3&gt;
&lt;h4&gt;docker概述&lt;/h4&gt;
&lt;p&gt;Docker是一个用于开发，交付和运行应用程序的开放平台。Docker使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助Docker，您可以以与管理应用程序相同的方式来管理基础架构。通过利用Docker的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。&lt;/p&gt;
&lt;!--</description><html_content>&lt;h3&gt;docker的安装&lt;/h3&gt;
&lt;h4&gt;docker概述&lt;/h4&gt;
&lt;p&gt;Docker是一个用于开发，交付和运行应用程序的开放平台。Docker使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助Docker，您可以以与管理应用程序相同的方式来管理基础架构。通过利用Docker的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h4&gt;docker安装&lt;/h4&gt;
&lt;h5&gt;移除旧版本&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;安装docker依赖&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y yum-utils \
  device-mapper-persistent-data \
  lvm2
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;添加docker稳定yum源&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum-config-manager \
    --add-repo \
    https://download.docker.com/linux/centos/docker-ce.repo
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;安装docker&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install -y docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装指定版本docker使用如下命令&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;yum install docker-ce-&amp;lt;VERSION_STRING&amp;gt; docker-ce-cli-&amp;lt;VERSION_STRING&amp;gt; containerd.io
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;配置docker镜像加速和私有仓库(非必须)&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mkdir /etc/docker
cat &amp;lt;&amp;lt; EOF &amp;gt; /etc/docker/daemon.json
{
    &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://k9e55i4n.mirror.aliyuncs.com&amp;quot;],
    #private repository
    #&amp;quot;insecure-registries&amp;quot;: [&amp;quot;127.0.0.1:5000&amp;quot;],
    &amp;quot;log-driver&amp;quot;: &amp;quot;json-file&amp;quot;,
    &amp;quot;log-opts&amp;quot;:{
    &amp;quot;max-size&amp;quot;: &amp;quot;10m&amp;quot;,
    &amp;quot;max-file&amp;quot;: &amp;quot;10&amp;quot;
    },
    &amp;quot;bip&amp;quot;:&amp;quot;172.20.0.1/16&amp;quot;,
    &amp;quot;data-root&amp;quot;: &amp;quot;/data/docker&amp;quot;
}
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;设置docker开机自启动&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;systemctl daemon-reload
systemctl enable docker
systemctl start docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;若要修改docker驱动为systemd&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /usr/lib/systemd/system/docker.service
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd
#或者执行
sed -i '/ExecStart/ s/$/ --exec-opt native.cgroupdriver=systemd/' /usr/lib/systemd/system/docker.service

#重启docker服务
systemctl daemon-reload
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>docker镜像常用操作</title><description>&lt;h3&gt;Docker镜像管理&lt;/h3&gt;
&lt;p&gt;docker镜像包含启动容器需要的文件系统和数据。镜像主要用于创建并启动容器。&lt;/p&gt;
&lt;p&gt;docker默认镜像在国外，国内下载很慢，我们可以通过配置国内镜像进行加速。&lt;/p&gt;
&lt;h4&gt;配置docker镜像加速&lt;/h4&gt;
&lt;!--more--&gt;
&lt;p&gt;很多时候由于国内访问国外镜像站速度比较慢，可以尝试使用镜像加速器
可以地址有
ustc:  </description><html_content>&lt;h3&gt;Docker镜像管理&lt;/h3&gt;
&lt;p&gt;docker镜像包含启动容器需要的文件系统和数据。镜像主要用于创建并启动容器。&lt;/p&gt;
&lt;p&gt;docker默认镜像在国外，国内下载很慢，我们可以通过配置国内镜像进行加速。&lt;/p&gt;
&lt;h4&gt;配置docker镜像加速&lt;/h4&gt;
&lt;!--more--&gt;
&lt;p&gt;很多时候由于国内访问国外镜像站速度比较慢，可以尝试使用镜像加速器
可以地址有
ustc:   https://docker.mirrors.ustc.edu.cn
aliyun: https://w57n2hu2.mirror.aliyuncs.com&lt;/p&gt;
&lt;p&gt;修改docker配置文件/etc/docker/daemon.json添加内容如下&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/docker/daemon.json

{
    &amp;quot;registry-mirros&amp;quot;: [&amp;quot;https://w57n2hu2.mirror.aliyuncs.com&amp;quot;]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改成功后重启docker服务&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;重载配置文件
systemctl daemon-reload
重启docker
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;登录docker私有镜像仓库&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#docker login  仓库地址
#比如登录阿里云私有仓库，然后按提示输入用户名密码即可登录
docker login registry.cn-hangzhou.aliyuncs.com

#或者直接将用户名密码放在命令中
docker login --username=&amp;quot;$user&amp;quot; -p $passwd registry.cn-hangzhou.aliyuncs.com
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;docker验证配置，解决x509 insecure registry验证配置&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;vim /etc/docker/daemon.json
{
    #添加如下这行
    &amp;quot;insecure-registries&amp;quot; : [&amp;quot;192.168.1.100:5000&amp;quot;]
}

#重启docker服务生效
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker镜像操作通过docker命令管理，下面介绍一下与镜像相关的命令&lt;/p&gt;
&lt;h4&gt;搜索镜像&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;docker search&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意下面两个是有区别的。第一个搜索指定版本的nginx,第二个不带版本号,搜索默认版本latest&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker search nginx:1.16.1
docker search nginx
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回结果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NAME 仓库名称&lt;/li&gt;
&lt;li&gt;DESCRIPTION 镜像描述&lt;/li&gt;
&lt;li&gt;STARS 关注度,反应一个镜像的欢迎程度&lt;/li&gt;
&lt;li&gt;OFFICIAL 是否官方&lt;/li&gt;
&lt;li&gt;AUTOMATED 自动构建，表示该镜像由Docker Hub自动构建流程创建&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OPTION选项说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-s 列出关注数大于指定值的镜像&lt;/li&gt;
&lt;li&gt;--no-trunc 显示完整的镜像描述DESCRIPTION&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;下载镜像&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;docker pull&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从docker仓库下载镜像到本地。基本语法&lt;/p&gt;
&lt;p&gt;docker pull 仓库地址/镜像空间/镜像名称:tag号&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker pull nginx
#127.0.0.1:5000表示私有仓库地址
docker pull 127.0.0.1:5000/test/centos:7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;镜像默认存储位置/var/lib/docker&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区分同一仓库下的不同镜像,docker提供了标签(TAG)功能,这种机制使得同一仓库可以存储多个镜像&lt;/li&gt;
&lt;li&gt;拉取镜像，可以使用仓库名加上一个冒号和标签(REPOSITORY:TAG)来指定仓库中某一具体的镜像,如果未指定镜像的标签，将下载lastest最新版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;查看本地镜像&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;docker images&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;返回结果参数解析&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;REPOSITORY 镜像所在仓库的名称&lt;/li&gt;
&lt;li&gt;TAG 镜像标签(一般是版本号)&lt;/li&gt;
&lt;li&gt;IMAGE ID 镜像ID&lt;/li&gt;
&lt;li&gt;CREATED 镜像创建时间&lt;/li&gt;
&lt;li&gt;SIZE 镜像大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;导出本地镜像&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;docker save&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候需要备份或者导出一个镜像，这时我们可以通过docker save命令&lt;/p&gt;
&lt;p&gt;使用语法&lt;/p&gt;
&lt;p&gt;REPOSITORY和TAG为查看本地镜像(docker images)时显示的值&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker save REPOSITORY:TAG &amp;gt; images.tar.gz
#或者使用-o参数输出
docker save REPOSITORY:TAG -o images.tar.gz
#例：
docker save alpine:3.11 &amp;gt; /tmp/alpine-3.11.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;将镜像导入本地&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;docker load&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在我们将上文导出的镜像导入另外一台服务器，怎么导入呢？其实也很简单,将镜像文件上传到新服务器的/tmp目录下，然后导入，导入命令如下。&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker load &amp;lt; /tmp/alpine-3.11.tar.gz
#也可以使用-i参数
docker load -i /tmp/alpine-3.11.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;删除镜像&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;docker rmi&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker rmi alpine:3.11
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要注意删除镜像时确保镜像没用被容器使用，如果被使用了。需要先删除容器，可以通过命令查看后删除&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#查看alpine镜像是否被使用
docker ps -a|grep alpine
#删除被使用的容器，CONTAINER ID为容器ID，NAMES为容器名称
docker rm 容器ID/容器名称
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;给镜像打tag&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#具体格式
docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG]


#给nginx版本号为1.16.1的镜像打成nginx_test:1.16.1
docker tag nginx:1.16.1 nginx_test:1.16.1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上就是dockers镜像的一些常见操作了。包括镜像加速，搜索、下载、查看、导出、导入和删除操作。&lt;/p&gt;</html_content></item><item><title>ubuntu系统安装docker</title><description>&lt;h3&gt;docker的安装&lt;/h3&gt;
&lt;h4&gt;docker概述&lt;/h4&gt;
&lt;p&gt;Docker是一个用于开发，交付和运行应用程序的开放平台。Docker使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助Docker，您可以以与管理应用程序相同的方式来管理基础架构。通过利用Docker的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。&lt;/p&gt;
&lt;!--</description><html_content>&lt;h3&gt;docker的安装&lt;/h3&gt;
&lt;h4&gt;docker概述&lt;/h4&gt;
&lt;p&gt;Docker是一个用于开发，交付和运行应用程序的开放平台。Docker使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助Docker，您可以以与管理应用程序相同的方式来管理基础架构。通过利用Docker的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。&lt;/p&gt;
&lt;!--more--&gt;
&lt;h4&gt;docker安装&lt;/h4&gt;
&lt;h5&gt;移除旧版本&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sudo apt-get remove docker docker-engine docker.io containerd runc
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;安装docker依赖&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sudo apt-get update
sudo apt-get install \
    apt-transport-https \
    ca-certificates \
    curl \
    gnupg \
    lsb-release
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;添加docker稳定yum源&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

echo \
  &amp;quot;deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) stable&amp;quot; | sudo tee /etc/apt/sources.list.d/docker.list &amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;安装docker&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sudo apt-get update
sudo apt-get install docker-ce docker-ce-cli containerd.io
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装指定版本docker使用如下命令&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sudo apt-get install docker-ce=&amp;lt;VERSION_STRING&amp;gt; docker-ce-cli=&amp;lt;VERSION_STRING&amp;gt; containerd.io
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;配置docker镜像加速和私有仓库(非必须)&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mkdir /etc/docker
cat &amp;lt;&amp;lt; EOF &amp;gt; /etc/docker/daemon.json
{
    &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://k9e55i4n.mirror.aliyuncs.com&amp;quot;],
    #private repository
    #&amp;quot;insecure-registries&amp;quot;: [&amp;quot;127.0.0.1:5000&amp;quot;],
    &amp;quot;log-driver&amp;quot;: &amp;quot;json-file&amp;quot;,
    &amp;quot;log-opts&amp;quot;:{
    &amp;quot;max-size&amp;quot;: &amp;quot;10m&amp;quot;,
    &amp;quot;max-file&amp;quot;: &amp;quot;10&amp;quot;
    },
    &amp;quot;bip&amp;quot;:&amp;quot;172.20.0.1/16&amp;quot;,
    &amp;quot;data-root&amp;quot;: &amp;quot;/data/docker&amp;quot;
}
EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;设置docker开机自启动&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;systemctl daemon-reload
systemctl enable docker
systemctl start docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;若要修改docker驱动为systemd&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /usr/lib/systemd/system/docker.service
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock --exec-opt native.cgroupdriver=systemd
#或者执行
sed -i '/ExecStart/ s/$/ --exec-opt native.cgroupdriver=systemd/' /usr/lib/systemd/system/docker.service

#重启docker服务
systemctl daemon-reload
systemctl restart docker
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>运维监控-prometheus的安装搭建</title><description>&lt;h2&gt;特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基于时间序列模型的监控&lt;/li&gt;
&lt;li&gt;基于K/V键值对的数据模型(格式简单，速度快，执行简单)&lt;/li&gt;
&lt;li&gt;采样数据查询基于数学运算公式&lt;/li&gt;
&lt;li&gt;基于http</description><html_content>&lt;h2&gt;特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基于时间序列模型的监控&lt;/li&gt;
&lt;li&gt;基于K/V键值对的数据模型(格式简单，速度快，执行简单)&lt;/li&gt;
&lt;li&gt;采样数据查询基于数学运算公式&lt;/li&gt;
&lt;li&gt;基于http pull/push两种对应的数据采集传输方式&lt;/li&gt;
&lt;li&gt;push方法非常灵活&lt;/li&gt;
&lt;li&gt;自带图形调试&lt;/li&gt;
&lt;/ul&gt;
&lt;!--more--&gt;
&lt;h2&gt;Prometheus下载地址&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;https://prometheus.io/download/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;监控的常用分类&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;监控分类&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务监控
    用户访问Qps(每秒访问请求量),DAU日活，访问状态，业务接口，产品转化率，充值额度，用户投诉等&lt;/li&gt;
&lt;li&gt;系统监控
    与操作系统相关的基本监控项 cpu/内存/硬盘/IO/TCP连接/流量等&lt;/li&gt;
&lt;li&gt;网络监控
    对网络状态的监控，比如丢包率，延迟等&lt;/li&gt;
&lt;li&gt;日志监控
    单独设计和搭建&lt;/li&gt;
&lt;li&gt;程序监控
    一般需开发人员配合，程序中嵌入各种接口，直接获取数据或者特定的日志格式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;metrics的主要类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;gauges 
    最简单的度量指标，只有一个简单的返回值，或者瞬时状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;counters
    计数器，从数据0开始累积计算，理想状态下只能是永远增长或保持不变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;histograms
    统计数据的分布情况&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;常用函数&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;{} 用来过滤&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;‘&amp;gt;’ ,&amp;gt;= 用来比较，也是过滤&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;increase()
    用来针对counter类型这种持续增长的数值，截取其中一段时间的增量总量
    比如: 截取cpu总使用时间在1分钟内的总的增量  increase(node_cpu[1m])&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;rate()
    专门配合counter类型数据使用的函数，按照设置一个时间段，取counter在这个时间段中的平均每秒的增量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sum()
    把所有结果集进行加合，
    比如，计算cpu使用率的时候，sum计算出来的结果是所有服务器的结果，不区分单台服务器，显然不是合理的结果&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;topk()
    topk(3,count_netstat_wait_connections)
    根据给定的数字，取数值最高&amp;gt;=x的数值,一般用来做瞬时告警&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;count()
    把数值符合条件的输出数目进行加合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;by (instance)
    与sum配合使用是，按照某种标签进行加合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;prometheus服务端安装&lt;/h2&gt;
&lt;p&gt;Prometheus主监控服务程序&lt;/p&gt;
&lt;h3&gt;下载&lt;/h3&gt;
&lt;p&gt;prometheus安装非常简单，下载后解压缩即可直接启动运行&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget wget https://github.com/prometheus/prometheus/releases/download/v2.33.4/prometheus-2.33.4.linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装并配置systemctl启动&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#创建prometheus用户
useradd -M -r -s /bin/false prometheus

#创建配置文件目录和数据存储目录
mkdir /etc/prometheus /var/lib/prometheus

#解压并拷贝文件到对应目录
tar zxvf prometheus-2.28.1.linux-amd64.tar.gz

cp prometheus-2.28.1.linux-amd64/{prometheus,promtool} /usr/local/bin/
cp -r prometheus-2.28.1.linux-amd64/{consoles,console_libraries} /etc/prometheus/
cp prometheus-2.28.1.linux-amd64/prometheus.yml /etc/prometheus/prometheus.yml

chown prometheus:prometheus /usr/local/bin/{prometheus,promtool}
chown -R prometheus:prometheus /etc/prometheus
chown prometheus:prometheus /var/lib/prometheus

#创建service启动文件
cat &amp;gt; /etc/systemd/system/prometheus.service &amp;lt;&amp;lt;EOF

[Unit]
Description=Prometheus Time Series Collection and Processing Server
Wants=network-online.target
After=network-online.target

[Service]
User=prometheus
Group=prometheus
Type=simple
ExecStart=/usr/local/bin/prometheus \
    --config.file /etc/prometheus/prometheus.yml \
    --storage.tsdb.path /var/lib/prometheus/ \
    --storage.tsdb.retention=15d \
    --web.console.templates=/etc/prometheus/consoles \
    --web.console.libraries=/etc/prometheus/console_libraries \
    --query.timeout=2m \
    --query.max-concurrency=20 \
    --web.read-timeout=5m \
    --web.max-connections=512 
Restart=on-failure

[Install]
WantedBy=multi-user.target

EOF

#启动服务并设置开机自启
systemctl daemon-reload
systemctl enable prometheus
systemctl start prometheus
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动时设置的一些参数
- --web.read-timeout=5m
    请求链接的最大等待时间，防止太多的空闲链接占用资源
- --web.max-connections=512
    最大链接数
- --storage.tsdb.retention=15d
    prometheus开始采集的数据会保存在内存和硬盘中，如果不设置期限，硬盘盒内存吃不消。太短历史数据又会没有，需要合理设置&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;--storage.tsdb.path="/data"
    存储数据路径&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;query.timeout=2m&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;query.max-concurrency=20
    这两个选项是对用户执行prometheus查询时的优化设置
    防止太多的用户同时查询，也防止单个用户执行过大的查询而一直不退出&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;node_exporter的安装&lt;/h2&gt;
&lt;p&gt;node_exporter 节点基础监控程序&lt;/p&gt;
&lt;h3&gt;下载&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://github.com/prometheus/node_exporter/releases/download/v1.3.1/node_exporter-1.3.1.linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装并配置systemctl启动&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;useradd -M -r -s /bin/false node_exporter

tar zxvf node_exporter-1.3.1.linux-amd64.tar.gz

cp node_exporter-1.3.1.linux-amd64/node_exporter /usr/local/bin/
chown node_exporter:node_exporter /usr/local/bin/node_exporter

cat &amp;gt; /etc/systemd/system/node_exporter.service &amp;lt;&amp;lt;EOF
[Unit]
Description=Prometheus Node Exporter
Wants=network-online.target
After=network-online.target

[Service]
User=node_exporter
Group=node_exporter
Type=simple
ExecStart=/usr/local/bin/node_exporter
Restart=on-failure

[Install]
WantedBy=multi-user.target

EOF

#启动服务并设置开机自启
systemctl daemon-reload
systemctl enable node_exporter
systemctl start node_exporter
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;添加prometheus的target监控&lt;/h3&gt;
&lt;p&gt;修改prometheus的配置文件，两种方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.静态加载配置文件，修改后需要重启prometheus服务&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/prometheus/prometheus.yml
scrape_configs:
    #静态添加node_exporter
  - job_name: 'Linux'
    static_configs:
    #注意在prometheus主机上也应配置node_exporter的9100端口而不少prometheus的9090端口
    - targets: ['localhost:9100']
      labels:
        instance: test
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;2.动态加载配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/prometheus/prometheus.yml
scrape_configs:
    #动态添加node_exporter
  - job_name: 'DT_configs'
    file_sd_configs:
      - files: [/etc/prometheus.d/*.yml]
        refresh_interval: 5s

vi /etc/prometheus.d/test.yml
- targets: ['localhost:9100']
  labels:
    instance: test
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;配置prometheus的target监控告警规则&lt;/h3&gt;
&lt;h4&gt;第一步 添加告警规则&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 创建告警规则目录,方便管理
mdkir /etc/prometheus/rules

# 以创建linux系统基础监控为例
vi /etc/prometheus/rules/linux_system.yml
groups:
- name: example
  rules:

  - alert: 实例丢失
    expr: up{job=&amp;quot;node-exporter&amp;quot;} == 0
    for: 1m
    labels:
      severity: page
    annotations:
      summary: &amp;quot;服务器实例 {{ $labels.instance }} 丢失&amp;quot;
      description: &amp;quot;{{ $labels.instance }} 上的任务 {{ $labels.job }} 已经停止了 1 分钟已上了&amp;quot;

  - alert: 磁盘容量小于 5%
    expr: 100 - ((node_filesystem_avail_bytes{job=&amp;quot;node-exporter&amp;quot;,mountpoint=~&amp;quot;.*&amp;quot;,fstype=~&amp;quot;ext4|xfs|ext2|ext3&amp;quot;} * 100) / node_filesystem_size_bytes {job=&amp;quot;node-exporter&amp;quot;,mountpoint=~&amp;quot;.*&amp;quot;,fstype=~&amp;quot;ext4|xfs|ext2|ext3&amp;quot;}) &amp;gt; 95
    for: 30s
    annotations:
      summary: &amp;quot;服务器实例 {{ $labels.instance }} 磁盘不足 告警通知&amp;quot;
      description: &amp;quot;{{ $labels.instance }}磁盘 {{ $labels.device }} 资源 已不足 5%, 当前值: {{ $value }}&amp;quot;

  - alert: &amp;quot;内存容量小于 20%&amp;quot;
    expr: ((node_memory_MemTotal_bytes - node_memory_MemFree_bytes - node_memory_Buffers_bytes - node_memory_Cached_bytes) / (node_memory_MemTotal_bytes )) * 100 &amp;gt; 80
    for: 30s
    labels:
      severity: warning
    annotations:
      summary: &amp;quot;服务器实例 {{ $labels.instance }} 内存不足 告警通知&amp;quot;
      description: &amp;quot;{{ $labels.instance }}内存资源已不足 20%,当前值: {{ $value }}&amp;quot;

  - alert: &amp;quot;CPU 平均负载大于 4 个&amp;quot;
    expr: node_load5 &amp;gt; 4
    for: 30s
    annotations:
      sumary: &amp;quot;服务器实例 {{ $labels.instance }} CPU 负载 告警通知&amp;quot;
      description: &amp;quot;{{ $labels.instance }}CPU 平均负载(5 分钟) 已超过 4 ,当前值: {{ $value }}&amp;quot;

  - alert: &amp;quot;磁盘读 I/O 超过 30MB/s&amp;quot;
    expr: irate(node_disk_read_bytes_total{device=&amp;quot;sda&amp;quot;}[1m]) &amp;gt; 30000000
    for: 30s
    annotations:
      sumary: &amp;quot;服务器实例 {{ $labels.instance }} I/O 读负载 告警通知&amp;quot;
      description: &amp;quot;{{ $labels.instance }}I/O 每分钟读已超过 30MB/s,当前值: {{ $value }}&amp;quot;

  - alert: &amp;quot;磁盘写 I/O 超过 30MB/s&amp;quot;
    expr: irate(node_disk_written_bytes_total{device=&amp;quot;sda&amp;quot;}[1m]) &amp;gt; 30000000
    for: 30s
    annotations:
      sumary: &amp;quot;服务器实例 {{ $labels.instance }} I/O 写负载 告警通知&amp;quot;
      description: &amp;quot;{{ $labels.instance }}I/O 每分钟写已超过 30MB/s,当前值: {{ $value }}&amp;quot;

  - alert: &amp;quot;网卡流出速率大于 10MB/s&amp;quot;
    expr: (irate(node_network_transmit_bytes_total{device!~&amp;quot;lo&amp;quot;}[1m]) / 1000) &amp;gt; 1000000
    for: 30s
    annotations:
      sumary: &amp;quot;服务器实例 {{ $labels.instance }} 网卡流量负载 告警通知&amp;quot;
      description: &amp;quot;{{ $labels.instance }}网卡 {{ $labels.device }} 流量已经超过 10MB/s, 当前值: {{ $value }}&amp;quot;

  - alert: &amp;quot;CPU 使用率大于 90%&amp;quot;
    expr: 100 - ((avg by (instance,job,env)(irate(node_cpu_seconds_total{mode=&amp;quot;idle&amp;quot;}[30s]))) *100) &amp;gt; 90
    for: 30s
    annotations:
      sumary: &amp;quot;服务器实例 {{ $labels.instance }} CPU 使用率 告警通知&amp;quot;
      description: &amp;quot;{{ $labels.instance }}CPU 使用率已超过 90%, 当前值: {{ $value }}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;第二步 在prometheus.yml配置文件引入告警规则&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/prometheus/prometheus.yml
rule_files:
    # *.yml表示目录下所有的yml文件，也可以指定具体的单个告警规则文件
  - /etc/prometheus/rules/*.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;alertmanger安装配置&lt;/h2&gt;
&lt;p&gt;alertmanger 告警程序&lt;/p&gt;
&lt;h3&gt;下载&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://github.com/prometheus/alertmanager/releases/download/v0.23.0/alertmanager-0.23.0.linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;useradd --no-create-home --shell /bin/false alertmanager

tar zxvf alertmanager-0.23.0.linux-amd64.tar.gz
mkdir /etc/alertmanager
cp alertmanager-0.23.0.linux-amd64/{alertmanager,amtool} /usr/local/bin/
cp alertmanager-0.23.0.linux-amd64/alertmanager.yml /etc/alertmanager/

chown -R alertmanager:alertmanager /etc/alertmanager
chown -R alertmanager:alertmanager /usr/local/bin/{alertmanager,amtool}


cat &amp;gt; /etc/systemd/system/alertmanager.service &amp;lt;&amp;lt;EOF
[Unit]
Description=Prometheus Alertmanager
Wants=network-online.target
After=network-online.target

[Service]
User=alertmanager
Group=alertmanager
Type=simple
ExecStart=/usr/local/bin/alertmanager \
        --config.file=/etc/alertmanager/alertmanager.yml \
        --storage.path=&amp;quot;/etc/alertmanager/data/&amp;quot; \
        --data.retention=60h \
        --web.external-url http://0.0.0.0:9093
Restart=on-failure

[Install]
WantedBy=multi-user.target

EOF


systemctl daemon-reload
systemctl enable alertmanager
systemctl start alertmanager
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;配置alertmanager 与prometheus 告警管理&lt;/h3&gt;
&lt;h4&gt;第一步 配置告警介质(邮箱，微信，钉钉等)&lt;/h4&gt;
&lt;p&gt;配置文件分四个模块，global, templates, route, receivers&lt;/p&gt;
&lt;h5&gt;global 定义alertmanager全局配置&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 定义alertmanager全局配置
global:
  resolve_timeout: 5m # 定义持续多长时间没接收告警就标记为resolved
  smtp_smarthost: 'smtp.qiye.aliyun.com:465'
  smtp_from: 'mjin@erongdu.com'
  smtp_auth_username: 'mjin@erongdu.com'
  smtp_auth_password: '72nF9pU9LG'
  smtp_require_tls: false
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;route 定义接收告警的处理方式，根据规则进行匹配并采取相应操作&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;route:
  group_by: ['alertname']
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 1h
  receiver: 'email.test'
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;邮箱发送告警&lt;/h6&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 定义alertmanager全局配置
global:
  resolve_timeout: 5m # 定义持续多长时间没接收告警就标记为resolved
  smtp_smarthost: 'smtp.qiye.aliyun.com:465'
  smtp_from: 'mjin@erongdu.com'
  smtp_auth_username: 'mjin@erongdu.com'
  smtp_auth_password: '72nF9pU9LG'
  smtp_require_tls: false
route:
  group_by: ['alertname']
  group_wait: 30s
  group_interval: 5m
  repeat_interval: 1h
  receiver: 'email.test'
receivers:
- name: 'web.hook'
  webhook_configs:
  - url: 'http://127.0.0.1:5001/'
- name: 'email.test'
  email_configs:
  - to: 'ops@erongdu.com'
    send_resolved: true
inhibit_rules:
  - source_match:
      severity: 'critical'
    target_match:
      severity: 'warning'
    equal: ['alertname', 'dev', 'instance']
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;钉钉告警&lt;/h6&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;钉钉告警插件地址：
    https://github.com/timonwong/prometheus-webhook-dingtalk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;安装&lt;/em&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;tar zxvf prometheus-webhook-dingtalk-2.0.0.linux-amd64.tar.gz 
 cp prometheus-webhook-dingtalk-2.0.0.linux-amd64/prometheus-webhook-dingtalk /usr/local/bin/


# 配置文件
vi /etc/prometheus-webhook-config.yml 
## Request timeout
# timeout: 5s

## Uncomment following line in order to write template from scratch (be careful!)
#no_builtin_template: true

## Customizable templates path
#templates:
#  - contrib/templates/legacy/template.tmpl

## You can also override default template using `default_message`
## The following example to use the 'legacy' template from v0.3.0
#default_message:
#  title: '{{ template &amp;quot;legacy.title&amp;quot; . }}'
#  text: '{{ template &amp;quot;legacy.content&amp;quot; . }}'

## Targets, previously was known as &amp;quot;profiles&amp;quot;
targets:
  webhook1:
    url: https://oapi.dingtalk.com/robot/send?access_token=xxxxx

# 添加启动文件
cat &amp;gt; /etc/systemd/system/prometheus-webhook-dingtalk.service &amp;lt;&amp;lt;EOF
[Unit]
Description=prometheus-webhook-dingtalk
After=network-online.target

[Service]
Restart=on-failure
ExecStart=/usr/local/bin/prometheus-webhook-dingtalk --ding.profile=ops_dingding=自己钉钉机器人的Webhook地址

[Install]
WantedBy=multi-user.target

EOF


# 启动服务并设置开机自启动
systemctl daemon-reload
systemctl start prometheus-webhook-dingtalk


# 测试发送，链接中给你的webhook1为配置文件中的对应
curl   -H &amp;quot;Content-Type: application/json&amp;quot;  -d '{ &amp;quot;version&amp;quot;: &amp;quot;4&amp;quot;, &amp;quot;status&amp;quot;: &amp;quot;firing&amp;quot;, escription&amp;quot;:&amp;quot;description_content&amp;quot;}'  http://localhost:8060/dingtalk/webhook1/send
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;第二步 配置alertmanager 与 prometheus 告警关联&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim /etc/prometheus/prometheus.yml
alerting:
  alertmanagers:
    - static_configs:
        - targets:
            # alertmanager的url
          - localhost:9093
          # - alertmanager:9093
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;pushgateway&lt;/h2&gt;
&lt;p&gt;pushgateway 使用场景一般是prometheus无法直接获取节点机器监控指标时使用，节点机器将数据推送到pushgateway程序，然后Prometheus去pushgateway拿取数据&lt;/p&gt;
&lt;h3&gt;下载&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://github.com/prometheus/pushgateway/releases/download/v1.4.2/pushgateway-1.4.2.linux-amd64.tar.gz
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;安装并配置systemctl启动&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;tar zxvf pushgateway-1.4.2.linux-amd64.tar.gz
cd pushgateway-1.4.2.linux-amd64
cp pushgateway /usr/local/bin/

# 配置systemd
cat &amp;gt; /etc/systemd/system/pushgateway.service &amp;lt;&amp;lt;EOF
[Unit]
Description=Prometheus Node Exporter
Wants=network-online.target
After=network-online.target

[Service]
Type=simple
ExecStart=/usr/local/bin/pushgateway
Restart=on-failure

[Install]
WantedBy=multi-user.target

EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;grafana的安装配置&lt;/h2&gt;
&lt;p&gt;grafana图像展示&lt;/p&gt;
&lt;h3&gt;下载&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://dl.grafana.com/oss/release/grafana-8.4.1-1.x86_64.rpm
yum localinstall grafana-8.4.1-1.x86_64.rpm -y
systemctl start grafana-server
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;初始密码： admin/admin&lt;/p&gt;</html_content></item><item><title>运维监控-prometheus常用监控示例</title><description>&lt;h3&gt;常用监控指标示例&lt;/h3&gt;
&lt;p&gt;linux系统监控模板
https://grafana.com/grafana/dashboards/8919&lt;/p&gt;
&lt;h4&gt;内存使用率&lt;/h4&gt;
&lt;p&gt;使⽤率 = 1 - （实际可⽤内存 / 总内存）* 100
总内存: node_memory_MemTotal_bytes
Cached内存:</description><html_content>&lt;h3&gt;常用监控指标示例&lt;/h3&gt;
&lt;p&gt;linux系统监控模板
https://grafana.com/grafana/dashboards/8919&lt;/p&gt;
&lt;h4&gt;内存使用率&lt;/h4&gt;
&lt;p&gt;使⽤率 = 1 - （实际可⽤内存 / 总内存）* 100
总内存: node_memory_MemTotal_bytes
Cached内存: node_memory_Cached_bytes
Buffers内存:   node_memory_Buffers_bytes
可用内存:   node_memory_MemAvailable_bytes&lt;/p&gt;
&lt;p&gt;内存使用率:
    公式：(1 - (node_memory_MemAvailable_bytes / node_memory_MemTotal_bytes ))* 100
可用内存（单位：M）&lt;/p&gt;
&lt;p&gt;公式：node_memory_MemAvailable_bytes / 1024 / 1024&lt;/p&gt;
&lt;h4&gt;硬盘io使用情况&lt;/h4&gt;
&lt;p&gt;((rate(node_disk_read_bytes_total[1m] )+ rate(node_disk_written_bytes_total[1m])) / 1024 /1024) &amp;gt; 0 &lt;/p&gt;
&lt;p&gt;硬盘使⽤率 是 read + written 读和写 都会占⽤IO /1024 两次后 就由 bytes =&amp;gt; Mbs&lt;/p&gt;
&lt;h4&gt;硬盘使用情况&lt;/h4&gt;
&lt;p&gt;磁盘总大小: node_filesystem_size_bytes
磁盘剩余空间:   node_filesystem_avail_bytes&lt;/p&gt;
&lt;p&gt;磁盘总大小（单位: G）&lt;/p&gt;
&lt;p&gt;公式：node_filesystem_size_bytes {fstype=~"ext4|xfs"} / 1024 / 1024 / 1024&lt;/p&gt;
&lt;p&gt;磁盘剩余大小（单位: G）&lt;/p&gt;
&lt;p&gt;公式：node_filesystem_avail_bytes {fstype=~"ext4|xfs"}  / 1024 / 1024 / 1024&lt;/p&gt;
&lt;p&gt;磁盘使用率
　　公式：(1-(node_filesystem_free_bytes{fstype=~"ext4|xfs"} / node_filesystem_size_bytes{fstype=~"ext4|xfs"})) * 100&lt;/p&gt;
&lt;h4&gt;网卡流量&lt;/h4&gt;
&lt;p&gt;网卡入网流量 （指定某一个网卡，比如ens32）&lt;/p&gt;
&lt;p&gt;公式：irate(node_network_receive_bytes_total{device='ens32'}[5m])&lt;/p&gt;
&lt;p&gt;网卡出网流量（指定某一个网卡，比如ens32）&lt;/p&gt;
&lt;p&gt;公式：irate(node_network_transmit_bytes_total{device='ens32'}[5m])&lt;/p&gt;
&lt;h4&gt;cpu使用情况&lt;/h4&gt;
&lt;p&gt;CPU使用率&lt;/p&gt;
&lt;p&gt;公式：100 - (avg by (instance) (irate(node_cpu_seconds_total{mode="idle"}[5m])) * 100)&lt;/p&gt;
&lt;p&gt;CPU负载&lt;/p&gt;
&lt;p&gt;公式：&lt;/p&gt;
&lt;p&gt;node_load1     ## 1分钟负载&lt;/p&gt;
&lt;p&gt;node_load5     ##5分钟负载&lt;/p&gt;
&lt;p&gt;node_load15   ##15分钟负载&lt;/p&gt;
&lt;h4&gt;docker容器监控&lt;/h4&gt;
&lt;h4&gt;tcp连接数监控&lt;/h4&gt;</html_content></item><item><title>containerd镜像管理</title><description>&lt;p&gt;我在 k8s 集群中尝试使用 containerd 作为 CRI，发现镜像下载和导入与 docker 存在一些区别，大致如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;containerd 命令行工具 &lt;strong&gt;ctr&lt;/strong&gt; 特性不如 docker 丰富，如 ctr 1.2 并没有 tag 子命令，直到 1.3 才有&lt;/li&gt;
&lt;li&gt;为支持多租户隔离，containerd 有</description><html_content>&lt;p&gt;我在 k8s 集群中尝试使用 containerd 作为 CRI，发现镜像下载和导入与 docker 存在一些区别，大致如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;containerd 命令行工具 &lt;strong&gt;ctr&lt;/strong&gt; 特性不如 docker 丰富，如 ctr 1.2 并没有 tag 子命令，直到 1.3 才有&lt;/li&gt;
&lt;li&gt;为支持多租户隔离，containerd 有 namespace 概念，不同 namespace 下的 image、container 均不同，直接使用 ctr 操作时，会使用 default namespace&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用的是 ctr 1.2，可以通过 docker tag 镜像，再使用 ctr 导入镜像&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker save k8s.gcr.io/pause -o pause.tar
ctr -n &amp;lt;namespace&amp;gt; images import pause.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;k8s 只会使用 k8s.io namespace 中镜像。当导入k8s使用的镜像的时候，需要指定namespace&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;[root@k8s-worker-01 ~]# ctr namespace ls
NAME    LABELS 
default        
k8s.io         
[root@k8s-worker-01 ~]# ctr -n k8s.io images import metrics-server_v0.4.1.tar 
unpacking k8s.gcr.io/metrics-server/metrics-server:v0.4.1 (sha256:379ccb5f1062c75384800b21b346eed316c648c12c80389d26aff7e67e746a89)...done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ctr导出镜像&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ctr -n &amp;lt;namespaces&amp;gt; image  export  heapster-amd64:v1.5.4.tar k8s.gcr.io/heapster-amd64:v1.5.4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ctr导入镜像&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ctr -n k8s.io images import heapster-amd64:v1.5.4.tar
ctr -n k8s.io images import --base-name k8s.gcr.io/heapster-amd64 heapster-amd64:v1.5.4.tar
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>使用kubeasz工具安装k8s集群</title><description>&lt;p&gt;项目github地址&lt;code&gt;https://github.com/easzlab/kubeasz&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;一、集群规划和安装前准备工作&lt;/h2&gt;
&lt;h3&gt;1. 集群规划&lt;/h3&gt;
&lt;p&gt;| 角色 | 数量 | 描述 |
| --- | --- | --- |
| 管理节点 | 1 | 运行ansible/ezctl脚本，可复用master节点或者单独一台 |
|</description><html_content>&lt;p&gt;项目github地址&lt;code&gt;https://github.com/easzlab/kubeasz&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;一、集群规划和安装前准备工作&lt;/h2&gt;
&lt;h3&gt;1. 集群规划&lt;/h3&gt;
&lt;p&gt;| 角色 | 数量 | 描述 |
| --- | --- | --- |
| 管理节点 | 1 | 运行ansible/ezctl脚本，可复用master节点或者单独一台 |
| etcd节点 | 3 | etcd集群，奇数节点 |
| master节点 | 3 | 高可用集群至少2台master |
| node节点 | N台 | 根据需求自行增减节点 |&lt;/p&gt;
&lt;h3&gt;2. 各节点时间同步&lt;/h3&gt;
&lt;p&gt;2.1 第一种同步方法，各节点执行如下命令&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ntpdate time.windows.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.2 第二种是安装chrony
待补充..&lt;/p&gt;
&lt;h3&gt;3. 内核升级到最新&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 载入公钥
rpm --import https://www.elrepo.org/RPM-GPG-KEY-elrepo.org
rpm -Uvh http://www.elrepo.org/elrepo-release-7.0-3.el7.elrepo.noarch.rpm
yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt.x86_64
yum remove kernel-tools-libs.x86_64 kernel-tools.x86_64 -y
yum --disablerepo=\* --enablerepo=elrepo-kernel install -y kernel-lt-tools.x86_64

#查看默认启动顺序
awk -F\' '$1==&amp;quot;menuentry &amp;quot; {print $2}' /etc/grub2.cfg  
CentOS Linux (4.4.183-1.el7.elrepo.x86_64) 7 (Core)  
CentOS Linux (3.10.0-327.10.1.el7.x86_64) 7 (Core)  
CentOS Linux (0-rescue-c52097a1078c403da03b8eddeac5080b) 7 (Core)
#默认启动的顺序是从0开始，新内核是从头插入（目前位置在0，而4.4.4的是在1），所以需要选择0。
grub2-set-default 0  
#重启并检查
reboot
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;4. 管理节点配置&lt;/h3&gt;
&lt;h4&gt;4.1 安装ansible工具&lt;/h4&gt;
&lt;p&gt;管理节点依赖ansible批量操作工具来管理各节点，所以需要安装ansible&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 注意pip 21.0以后不再支持python2和python3.5，需要如下安装
# To install pip for Python 2.7 install it from https://bootstrap.pypa.io/2.7/ :
# 第一种安装
curl -O https://bootstrap.pypa.io/pip/2.7/get-pip.py
python get-pip.py
#或者第二种安装
yum install -y epel-release
yum install -y python-pip

# 升级pip
python -m pip install --upgrade &amp;quot;pip &amp;lt; 21.0&amp;quot;
pip install -U 'setuptools&amp;lt;45'

# pip安装ansible(国内如果安装太慢可以直接用pip阿里云加速)
pip install ansible -i https://mirrors.aliyun.com/pypi/simple/
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;4.2 配置各节点免秘钥登录&lt;/h4&gt;
&lt;p&gt;管理节点需要管理其他节点，方便脚本执行等，配置管理节点可免秘钥登录到其他各节点，包括自身&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 更安全 Ed25519 算法
ssh-keygen -t ed25519 -N '' -f ~/.ssh/id_ed25519
# 或者传统 RSA 算法
ssh-keygen -t rsa -b 2048 -N '' -f ~/.ssh/id_rsa

ssh-copy-id $IPs #$IPs为所有节点地址包括自身，按照提示输入yes 和root密码
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;4.3 下载准备安装所需软件&lt;/h4&gt;
&lt;p&gt;下载安装k8s需要的所有文件，文件下载目录&lt;code&gt;/etc/kubeasz&lt;/code&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 下载工具脚本easzup，举例使用kubeasz版本2.0.2
export release=3.0.0
curl -C- -fLO --retry 3 https://github.com/easzlab/kubeasz/releases/download/${release}/ezdown
chmod +x ./ezdown
# 使用工具脚本下载
./ezdown -D
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;二、 使用kubeasz工具的ezctl命令安装k8s集群&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ezctl&lt;/code&gt;命令可以创建多个集群，通过不同的集群名称区分不同的集群，现在创建第一个k8s集群,假设集群名&lt;code&gt;k8s-01&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;生成集群创建配置文件&lt;/h3&gt;
&lt;p&gt;通过命令生成k8s-01集群创建需要的配置文件，生成的配置文件保存在&lt;code&gt;/etc/kubeasz/clusters/k8s-01/&lt;/code&gt;,在目录下我们会看到两个配置文件&lt;code&gt;hosts&lt;/code&gt;和&lt;code&gt;config.yml&lt;/code&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 生成创建集群的配置文件
cd /etc/kubeasz
ezctl new k8s-01
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;根据集群规划修改配置文件&lt;/h3&gt;
&lt;p&gt;生成的两个文件是初始配置文件。我们需要根据集群的规划进行自定义修改或调整
&lt;code&gt;hosts&lt;/code&gt;文件主要配置的信息是集群各节点的服务器信息
&lt;code&gt;config.yml&lt;/code&gt;文件主要配置创建k8s时的一些组件配置信息&lt;/p&gt;
&lt;h3&gt;开始安装&lt;/h3&gt;
&lt;p&gt;安装很简单，可以一步一步的安装，也可以通过&lt;code&gt;all&lt;/code&gt;参数一次安装完成，具体的安装使用可以通过帮助命令查看&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;./ezctl setup --help
Usage: ezctl setup &amp;lt;cluster&amp;gt; &amp;lt;step&amp;gt;
available steps:
    01     prepare         to prepare CA/certs &amp;amp; kubeconfig &amp;amp; other system settings 
    02     etcd            to setup the etcd cluster
    03     runtime         to setup the container runtime(docker or containerd)
    04     kube-master     to setup the master nodes
    05     kube-node       to setup the worker nodes
    06     network         to setup the network plugin
    07     cluster-addon   to setup other useful plugins
    all                    to run 01~07 all at once

examples: ./ezctl setup test-k8s 01
          ./ezctl setup test-k8s 02
          ./ezctl setup test-k8s all
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我们要创建k8s-01集群，只需要根据帮助文档进行安装&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;cd /etc/kubeasz
# 一步到位安装
./ezctl setup k8s-01 all

# 分步安装
./ezctl setup k8s-01 01
./ezctl setup k8s-01 02
...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;配置master节点负载均衡&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;修改host文件，修改ex-lb配置段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行ex-lb相关的roles任务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;ansible-playbook -i ../clusters/k8s-01/hosts ex-lb.yml
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;执行成功后修改~/.kube/config文件，将server地址修改成hosts里ex-lb段配置的VIP地址和端口号即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;三、 集群管理常见操作&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;./ezctl --help
Usage: ezctl COMMAND [args]
-------------------------------------------------------------------------------------
Cluster setups:
    list                             to list all of the managed clusters
    checkout    &amp;lt;cluster&amp;gt;            to switch default kubeconfig of the cluster
    new         &amp;lt;cluster&amp;gt;            to start a new k8s deploy with name 'cluster'
    setup       &amp;lt;cluster&amp;gt;  &amp;lt;step&amp;gt;    to setup a cluster, also supporting a step-by-step way
    start       &amp;lt;cluster&amp;gt;            to start all of the k8s services stopped by 'ezctl stop'
    stop        &amp;lt;cluster&amp;gt;            to stop all of the k8s services temporarily
    upgrade     &amp;lt;cluster&amp;gt;            to upgrade the k8s cluster
    destroy     &amp;lt;cluster&amp;gt;            to destroy the k8s cluster
    backup      &amp;lt;cluster&amp;gt;            to backup the cluster state (etcd snapshot)
    restore     &amp;lt;cluster&amp;gt;            to restore the cluster state from backups
    start-aio                        to quickly setup an all-in-one cluster with 'default' settings

Cluster ops:
    add-etcd    &amp;lt;cluster&amp;gt;  &amp;lt;ip&amp;gt;      to add a etcd-node to the etcd cluster
    add-master  &amp;lt;cluster&amp;gt;  &amp;lt;ip&amp;gt;      to add a master node to the k8s cluster
    add-node    &amp;lt;cluster&amp;gt;  &amp;lt;ip&amp;gt;      to add a work node to the k8s cluster
    del-etcd    &amp;lt;cluster&amp;gt;  &amp;lt;ip&amp;gt;      to delete a etcd-node from the etcd cluster
    del-master  &amp;lt;cluster&amp;gt;  &amp;lt;ip&amp;gt;      to delete a master node from the k8s cluster
    del-node    &amp;lt;cluster&amp;gt;  &amp;lt;ip&amp;gt;      to delete a work node from the k8s cluster

Extra operation:
    kcfg-adm    &amp;lt;cluster&amp;gt;  &amp;lt;args&amp;gt;    to manage client kubeconfig of the k8s cluster

Use &amp;quot;ezctl help &amp;lt;command&amp;gt;&amp;quot; for more information about a given command.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;1. 添加和删除master节点&lt;/h3&gt;
&lt;p&gt;1.1 添加master节点&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;./ezctl add-master k8s-01 172.16.88.113
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;1.2 删除master节点&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;./ezctl del-master k8s-01 172.16.88.113
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2. 添加和删除node节点&lt;/h3&gt;
&lt;p&gt;2.1 添加node节点
将172.16.88.115添加到k8s-01集群的node节点&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;./ezctl add-node k8s-01 172.16.88.115
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2.2 删除node节点&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;./ezctl del-node k8s-01 172.16.88.115
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;3. 给节点打标签、删除标签&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 打标签
kubectl label node 172.16.88.205 app=ingress-nginx

# 删除标签
kubectl label node 172.16.88.205 app-
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>harbor私有镜像仓库安装</title><description>&lt;h5&gt;下载harbor&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;下载链接:       https://github.com/goharbor/harbor/releases
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;自签证书&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code</description><html_content>&lt;h5&gt;下载harbor&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;下载链接:       https://github.com/goharbor/harbor/releases
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;自签证书&lt;/h5&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#Getting Certificate Authority
openssl genrsa -out ca.key 4096
openssl req -x509 -new -nodes -sha512 -days 3650 \
    -subj &amp;quot;/C=CN/ST=Zhejiang/L=Hangzhou/O=register/OU=Personal/CN=registry.k8s.com&amp;quot; \
    -key ca.key \
    -out ca.crt

#Getting Server Certificate
openssl genrsa -out registry.k8s.com.key 4096
openssl req -sha512 -new \
    -subj &amp;quot;/C=CN/ST=Zhejiang/L=Hangzhou/O=register/OU=Personal/CN=registry.k8s.com&amp;quot; \
    -key registry.k8s.com.key \
    -out registry.k8s.com.csr

cat &amp;gt; v3.ext &amp;lt;&amp;lt;-EOF
authorityKeyIdentifier=keyid,issuer
basicConstraints=CA:FALSE
keyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth 
subjectAltName = @alt_names

[alt_names]
DNS.1=registry.k8s.com
DNS.2=registry.k8s
DNS.3=localhost.localdomain
EOF

openssl x509 -req -sha512 -days 3650 \
    -extfile v3.ext \
    -CA ca.crt -CAkey ca.key -CAcreateserial \
    -in registry.k8s.com.csr \
    -out registry.k8s.com.crt
&lt;/code&gt;&lt;/pre&gt;

&lt;h5&gt;安装harbor&lt;/h5&gt;
&lt;h6&gt;下载docker-compose&lt;/h6&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;curl -L &amp;quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-$(uname -s)-$(uname -m)&amp;quot; -o /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;解压harbor&lt;/h6&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;tar xvf harbor-offline-installer-v1.8.2.tgz
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;配置harbor&lt;/h6&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;vim harbor.yml
hostname: register.k8s.com
https:
  port: 443
  certificate: ./ssl/registry.k8s.com.crt
  private_key: ./ssl/registry.k8s.com.key  
harbor_admin_password: youpassword
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;安装&lt;/h6&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;sh install.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;h6&gt;harbor服务管理&lt;/h6&gt;
&lt;p&gt;查看&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker-compose ps
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;关闭&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker-compose stop
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker-compose start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改配置重新生效&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker-compose down -v
vim harbor.yml
prepare --with-notary --with-clair --with-chartmuseum   参数可选
docker-compose up -d
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;公钥拷贝到客户端&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mkdir /etc/docker/certs.d/register.k8s.com -p
scp registry.k8s.com.crt root@172.16.88.xx:/etc/docker/certs.d/registry.k8s.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过浏览器创建项目后即可使用,例创建test项目&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker login register.k8s.com
username:
password:
docker tag SOURCE_IMAGE[:TAG] register.k8s.com/test/IMAGE[:TAG]
docker push register.k8s.com/test/IMAGE[:TAG]
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>python 爬虫常用模块BeautifulSoup</title><description>&lt;p&gt;BeautifulSoup是一个模块，该模块用于接收一个HTML或XML字符串，
然后将其进行格式化，之后遍可以使用他提供的方法进行快速查找指定元素，
从而使得在HTML或XML中查找指定元素变得简单&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;pip install</description><html_content>&lt;p&gt;BeautifulSoup是一个模块，该模块用于接收一个HTML或XML字符串，
然后将其进行格式化，之后遍可以使用他提供的方法进行快速查找指定元素，
从而使得在HTML或XML中查找指定元素变得简单&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;pip install BeautifulSoup4
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;bs4支持的解析器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;|  解析器  |  使用方法  |  优势  |  劣势  |
| ----------- | ----------- | ----------- | ----------- |
| Python标准库 | BeautifulSoup(html_doc, "html.parser") | (1) Python的内置标准库; (2)执行速度适中;(3)文档容错能力强 | Python 2.7.3或3.2.2之前的版本中文档容错能力差 |
|  lxml HTML解析器 |  BeautifulSoup(html_doc,"lxml")  |  (1)速度快; (2)文档容错能力强  |  需要安装C语言库  |
| lxml XML解析器 | BeautifulSoup(html_doc,"lxml) BeautifulSoup(html_doc, "xml") | (1)速度快;(2)唯一支持XML的解析器 | 需要安装C语言库 |
| html5lib | BeautifulSoup(html_doc, "html5lib") | (1)最好的容错性;(2)以浏览器的方式解析文档(3)生成HTML5格式的文档 | (1)速度慢;(2)不依赖外部扩展 |&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;# 导入模块
from bs4 import BeautifulSoup
#基本使用
#下面两个一样，features指定解析器
soup = BeautifulSoup(html_doc,features=&amp;quot;html.parser&amp;quot;)
soup = BeautifulSoup(html_doc,&amp;quot;html.parser&amp;quot;)

# 返回第一个查找对象 find
print(soup.find(&amp;quot;p&amp;quot;))
print(soup.find(id=&amp;quot;p2&amp;quot;))
print(soup.find(&amp;quot;p&amp;quot;,id=&amp;quot;p2&amp;quot;))

# 返回对象列表, find_all
print(soup.find_all(&amp;quot;p&amp;quot;))
print(soup.find_all(id=&amp;quot;p2&amp;quot;))
print(soup.find_all(&amp;quot;p&amp;quot;,id=&amp;quot;p2&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>python经常使用的一些配置</title><description>&lt;h2&gt;修改python的pip源&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mkdir ~/.pip
vim ~/.pip/pip.conf
#添加如下内容
[global]
timeout = 6000 
index-url = http://pypi.douban.com/simple/</description><html_content>&lt;h2&gt;修改python的pip源&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;mkdir ~/.pip
vim ~/.pip/pip.conf
#添加如下内容
[global]
timeout = 6000 
index-url = http://pypi.douban.com/simple/ 
[install]
use-mirrors = true 
mirrors = http://pypi.douban.com/simple/  
trusted-host = pypi.douban.com
&lt;/code&gt;&lt;/pre&gt;

&lt;!--more--&gt;
&lt;h2&gt;pyton2写脚本时如果遇到编码问题可以尝试以下解决办法&lt;/h2&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;# -*- coding: utf-8 -*-
import sys
reload(sys)
sys.setdefaultencoding(&amp;quot;utf-8&amp;quot;)
import os
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>anaconda的安装与使用</title><description>&lt;h2&gt;下载安装Anaconda&lt;/h2&gt;
&lt;p&gt;anaconda官方下载地址&lt;code&gt;https://repo.anaconda.com/archive/&lt;/code&gt;,选择自己需要的版本&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget</description><html_content>&lt;h2&gt;下载安装Anaconda&lt;/h2&gt;
&lt;p&gt;anaconda官方下载地址&lt;code&gt;https://repo.anaconda.com/archive/&lt;/code&gt;,选择自己需要的版本&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;wget https://repo.anaconda.com/archive/Anaconda3-2021.05-Linux-x86_64.sh
bash Anaconda3-2021.05-Linux-x86_64.sh
#根据提示输入完成安装即可
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;anaconda使用&lt;/h2&gt;
&lt;h3&gt;关闭base基础环境自动激活&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;conda config --set auto_activate_base false
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;创建、复制、删除环境&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 创建新环境
conda create --name python37 python=3.7
conda create -n python37 python=3.7

# 复制环境,py37为复制后的环境名
conda create --name py37 --clone python37

# 删除环境,需要在未激活状态下删除,下面两种方式都可以
conda remove --name py37 --all
conda env remove --name py37
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;激活和退出环境&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;# 激活
conda activate python37

# 退出
conda deactivate
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;列出已创建的环境&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;conda info --envs
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;conda的包管理&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;#!/bin/bash
# 列出当前环境以安装的包
conda list

# 搜索包
conda search py     #模糊查找
conda search --full-name numpy  #精确查找

# 安装包
conda install numpy pandas  #安装多个包
conda install numpy=1.10    #安装指定版本的包
conda install --name python37 numpy #给指定环境安装包

# 更新包

# 更新所有包
conda update --all
conda upgrade --al

# 更新单个包
conda update numpy

# 删除包
conda remove --name python37 numpy  #删除指定环境的包
conda remove numpy  #删除当前环境的包
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>Django DRF 序列化相关参数</title><description>&lt;p&gt;Django Rest Framework的ModelSerializer是一个方便的工具，可以帮助我们快速地创建RESTful</description><html_content>&lt;p&gt;Django Rest Framework的ModelSerializer是一个方便的工具，可以帮助我们快速地创建RESTful API。以下是ModelSerializer的各个参数和方法以及参数验证的详细解释：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ModelSerializer参数：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;model：必需参数，指定序列化的模型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;fields：序列化器要序列化的字段。可以是一个字符串列表，也可以是'&lt;strong&gt;all&lt;/strong&gt;'，表示所有字段。&lt;/li&gt;
&lt;li&gt;exclude：序列化器不序列化的字段。可以是一个字符串列表。&lt;/li&gt;
&lt;li&gt;read_only_fields：只读字段。只在序列化输出时使用，不在反序列化输入时使用。可以是一个字符串列表。&lt;/li&gt;
&lt;li&gt;write_only_fields：只写字段。只在反序列化输入时使用，不在序列化输出时使用。可以是一个字符串列表。&lt;/li&gt;
&lt;li&gt;validators：用于验证输入的序列化器的全局验证器。应该是一个列表或元组，其中每个元素是一个验证函数。&lt;/li&gt;
&lt;li&gt;extra_kwargs：为模型字段指定额外的关键字参数，比如设置默认值或最大长度。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;depth：控制嵌套关系的深度。如果需要嵌套多层关系，可以设置depth的值来控制嵌套的层数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;create()和update()方法：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在ModelSerializer中，我们可以重写create()和update()方法，以便在创建和更新对象时执行自定义的逻辑。create()方法接收一个经过验证的数据字典，并返回创建的模型实例。update()方法接收一个模型实例、经过验证的数据字典，返回更新后的模型实例。&lt;/p&gt;
&lt;p&gt;```python
   class YourModelSerializer(serializers.ModelSerializer):
       class Meta:
           model = YourModel
           fields = '&lt;strong&gt;all&lt;/strong&gt;'&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;   def create(self, validated_data):
       # 自定义逻辑
       return YourModel.objects.create(**validated_data)

   def update(self, instance, validated_data):
       # 自定义逻辑
       instance.name = validated_data.get('name', instance.name)
       instance.email = validated_data.get('email', instance.email)
       instance.save()
       return instance
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;validate()方法：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在ModelSerializer中，我们可以重写validate()方法，以便在对序列化数据进行验证时执行自定义的逻辑。validate()方法接收一个经过验证的数据字典，并返回验证后的数据字典。如果验证失败，可以抛出ValidationError异常。&lt;/p&gt;
&lt;p&gt;```python
   class YourModelSerializer(serializers.ModelSerializer):
       class Meta:
           model = YourModel
           fields = '&lt;strong&gt;all&lt;/strong&gt;'&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;   def validate(self, data):
       # 自定义逻辑
       if 'email' in data and '@' not in data['email']:
           raise serializers.ValidationError('Invalid email address')
       return data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;```&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参数验证：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DRF提供了各种验证器，可以应用于序列化器的字段或者整个序列化器本身。常用的验证器包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;validators：全局验证器，用于验证整个序列化器的数据。&lt;/li&gt;
&lt;li&gt;required：指定字段是否为必填项。&lt;/li&gt;
&lt;li&gt;allow_null：指定字段是否允&lt;/li&gt;
&lt;/ul&gt;</html_content></item><item><title>python的paramiko模块的使用</title><description>&lt;p&gt;Paramiko 是一个用 Python 语言编写的 SSHv2 协议客户端，它提供了基于 SSH 协议进行远程服务器连接和文件传输的功能。下面是 Paramiko 的一些详细使用方法：&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;使用 pip 工具进行安装：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;pip install paramiko
&lt;/code&gt;&lt;/pre&gt;</description><html_content>&lt;p&gt;Paramiko 是一个用 Python 语言编写的 SSHv2 协议客户端，它提供了基于 SSH 协议进行远程服务器连接和文件传输的功能。下面是 Paramiko 的一些详细使用方法：&lt;/p&gt;
&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;使用 pip 工具进行安装：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;pip install paramiko
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;基本用法&lt;/h2&gt;
&lt;h3&gt;连接远程服务器&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import paramiko

ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 允许自动添加新主机到本地 ~/.ssh/known_hosts 文件中

ssh.connect(hostname='server_ip', port=22, username='username', password='password')

stdin, stdout, stderr = ssh.exec_command('ls -l')
print(stdout.read().decode())

ssh.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;使用密钥文件连接远程服务器&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import paramiko

ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 允许自动添加新主机到本地 ~/.ssh/known_hosts 文件中

key = paramiko.RSAKey.from_private_key_file('/path/to/key.pem')
ssh.connect(hostname='server_ip', port=22, username='username', pkey=key)

stdin, stdout, stderr = ssh.exec_command('ls -l')
print(stdout.read().decode())

ssh.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;上传文件到远程服务器&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import paramiko

ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 允许自动添加新主机到本地 ~/.ssh/known_hosts 文件中

ssh.connect(hostname='server_ip', port=22, username='username', password='password')

sftp = ssh.open_sftp()
sftp.put('/path/to/local/file.txt', '/path/to/remote/file.txt')

sftp.close()
ssh.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;从远程服务器下载文件&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import paramiko

ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 允许自动添加新主机到本地 ~/.ssh/known_hosts 文件中

ssh.connect(hostname='server_ip', port=22, username='username', password='password')

sftp = ssh.open_sftp()
sftp.get('/path/to/remote/file.txt', '/path/to/local/file.txt')

sftp.close()
ssh.close()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;进阶用法&lt;/h2&gt;
&lt;h3&gt;通过 SSH 隧道连接数据库&lt;/h3&gt;
&lt;p&gt;```python
import paramiko
import pymysql&lt;/p&gt;
&lt;p&gt;ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())  # 允许自动添加新主机到本地 ~/.ssh/known_hosts 文件中&lt;/p&gt;
&lt;p&gt;ssh.connect(hostname='ssh_server_ip', port=22, username='ssh_username', password='ssh_password')&lt;/p&gt;
&lt;h1&gt;建立 SSH 隧道连接数据库&lt;/h1&gt;
&lt;p&gt;transport = ssh.get_transport()
local_port = 3306
remote_addr = ('db_server_ip', 3306)
destination_addr = ('localhost', local_port)
transport.request_port_forward(*destination_addr, remote_addr)&lt;/p&gt;
&lt;h1&gt;连接本地 MySQL 数据库&lt;/h1&gt;
&lt;p&gt;conn = pymysql.connect(host='localhost', port=local_port, user='mysql_username', password='mysql_password', database='mysql_db')&lt;/p&gt;
&lt;h1&gt;执行 SQL 查询&lt;/h1&gt;
&lt;p&gt;cur = conn.cursor()
cur.execute('SELECT * FROM mysql.user')
result = cur.fetchall()
print(result)&lt;/p&gt;
&lt;p&gt;cur.close()
conn&lt;/p&gt;</html_content></item><item><title>python的列表类型常见处理方式</title><description>&lt;p&gt;在Python中，处理列表（list）类型的数据时，有许多常见的操作和处理方式。下面列举了一些常见的处理方式：&lt;/p&gt;
&lt;h4&gt;遍历列表：&lt;/h4&gt;
&lt;p&gt;在Python中，有多种方式可以遍历列表。下面介绍了几种常见的遍历列表的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用for循环遍历：使用&lt;code&gt;for&lt;/code&gt;循环可以逐个访问列表中的元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre</description><html_content>&lt;p&gt;在Python中，处理列表（list）类型的数据时，有许多常见的操作和处理方式。下面列举了一些常见的处理方式：&lt;/p&gt;
&lt;h4&gt;遍历列表：&lt;/h4&gt;
&lt;p&gt;在Python中，有多种方式可以遍历列表。下面介绍了几种常见的遍历列表的方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用for循环遍历：使用&lt;code&gt;for&lt;/code&gt;循环可以逐个访问列表中的元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3, 4, 5]
for item in my_list:
    print(item)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;使用while循环和索引遍历：可以使用&lt;code&gt;while&lt;/code&gt;循环和索引变量来遍历列表。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3, 4, 5]
index = 0
while index &amp;lt; len(my_list):
    print(my_list[index])
    index += 1
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;列表解析（List comprehension）：使用列表解析可以更简洁地遍历列表并进行操作。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3, 4, 5]
squared_list = [item**2 for item in my_list]
print(squared_list)  # 输出平方后的列表：[1, 4, 9, 16, 25]
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;内置函数enumerate()：使用&lt;code&gt;enumerate()&lt;/code&gt;函数可以同时获取元素和索引。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3, 4, 5]
for index, item in enumerate(my_list):
    print(index, item)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;内置函数zip()：使用&lt;code&gt;zip()&lt;/code&gt;函数可以同时遍历多个列表，并将对应位置的元素打包成元组。如果两个列表长度不一样，会以短的那个列表长度来打包&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;list1 = [1, 2, 3]
list2 = ['a', 'b', 'c']
for item1, item2 in zip(list1, list2):
    print(item1, item2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是常见的遍历列表的方式。根据具体的需求，您可以选择适合的方法来遍历和处理列表。&lt;/p&gt;
&lt;h4&gt;索引和切片：通过索引访问列表中的特定元素，或使用切片获取列表的子集。&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3, 4, 5]
print(my_list[0])      # 输出第一个元素：1
print(my_list[1:3])    # 输出索引1到2的子列表：[2, 3]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;修改元素：通过索引，可以修改列表中的特定元素。&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3, 4, 5]
my_list[2] = 10        # 将索引为2的元素修改为10
print(my_list)         # 输出修改后的列表：[1, 2, 10, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;添加元素：使用&lt;code&gt;append()&lt;/code&gt;方法在列表末尾添加元素，或使用&lt;code&gt;insert()&lt;/code&gt;方法在指定位置插入元素。&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3]
my_list.append(4)      # 在末尾添加元素4
print(my_list)         # 输出添加后的列表：[1, 2, 3, 4]

my_list.insert(1, 5)   # 在索引1的位置插入元素5
print(my_list)         # 输出插入后的列表：[1, 5, 2, 3, 4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;删除元素：使用&lt;code&gt;remove()&lt;/code&gt;方法根据值删除元素，或使用&lt;code&gt;del&lt;/code&gt;语句根据索引删除元素。&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3, 4, 5]
my_list.remove(3)      # 删除值为3的元素
print(my_list)         # 输出删除后的列表：[1, 2, 4, 5]

del my_list[0]         # 删除索引为0的元素
print(my_list)         # 输出删除后的列表：[2, 4, 5]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;列表长度：使用&lt;code&gt;len()&lt;/code&gt;函数获取列表的长度（即列表中元素的数量）。&lt;/h4&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_list = [1, 2, 3, 4, 5]
length = len(my_list)
print(length)          # 输出列表的长度：5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是处理列表类型数据时常见的一些操作和处理方式。还有许多其他操作可以应用于列表，如排序、反转、合并等。根据具体的需求，您可以选择适合的方法来操作和处理列表。&lt;/p&gt;</html_content></item><item><title>python的os模块常用方法</title><description>&lt;p&gt;os模块是python中最基本常用的模块之一，这里归纳一下常用的方法以便后续查找使用&lt;/p&gt;
&lt;p&gt;os模块对文件和文件夹操作的一些常用方法整理&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code&gt;os.listdir('.')    #获取当前目录下的目录和文件，返回结果是列表
os.getcwd()   </description><html_content>&lt;p&gt;os模块是python中最基本常用的模块之一，这里归纳一下常用的方法以便后续查找使用&lt;/p&gt;
&lt;p&gt;os模块对文件和文件夹操作的一些常用方法整理&lt;/p&gt;
&lt;!--more--&gt;

&lt;pre class="codehilite"&gt;&lt;code&gt;os.listdir('.')    #获取当前目录下的目录和文件，返回结果是列表
os.getcwd()    #获取当前工作目录
os.chdir('/tmp')    #改变工作目录到/tmp目录
os.path.isdir('/root/test')    #判断/root/test是不是目录，是则返回True,不是或不存在则返回False
os.path.isfile('/root/test.py')     #判断/root/test.py是不是文件，是则返回True,不是或不存在则返回False
os.path.exists('test')        #判断是否存在文件或目录test
os.path.abspath('./test.py')    #获取绝对路径
os.path.dirname(os.path.abspath('./test.py'))    #返回test.py文件的路径
os.path.basename(os.path.abspath('./test.py'))    #返回test.py文件名

os.path.split('/root/test')    #将参数按目录和文件名的形式分开(不会判断最后的是文件或文件夹以及它是否存在，紧紧是将参数按路径格式进行分割)

os.path.splitext('test.py')    #分割文件的文件名和后缀名,与os.path.split一样，并不会判断文件是否真实存在
os.path.join(path,name)    #连接目录与文件或目录,比如os.path.join('./','haha','test.py'),返回结果是'./haha/test.py'
os.curdir    #返回当前目录, '.'

os.symlink('abspath/filename','ln_file')    #建立软连接，源需要绝对路径
os.unlink('ln_file')    #取消软连接

os.system('shell')    #调用系统命令
os.remove()       #删除文件 
os.rename()       #重命名文件 
os.walk()       #生成目录树下的所有文件名 
os.chdir()       #改变目录 
os.mkdir/makedirs()     #创建目录/多层目录 
os.rmdir/removedirs     #删除目录/多层目录
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>python的configparser模块的使用</title><description>&lt;p&gt;&lt;code&gt;configparser&lt;/code&gt; 模块提供了一种用于读写配置文件的方法。以下是详细的使用方法：&lt;/p&gt;
&lt;h2&gt;1. 导入模块&lt;/h2&gt;
&lt;p&gt;首先，您需要导入 &lt;code&gt;configparser&lt;/code&gt; 模块：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import</description><html_content>&lt;p&gt;&lt;code&gt;configparser&lt;/code&gt; 模块提供了一种用于读写配置文件的方法。以下是详细的使用方法：&lt;/p&gt;
&lt;h2&gt;1. 导入模块&lt;/h2&gt;
&lt;p&gt;首先，您需要导入 &lt;code&gt;configparser&lt;/code&gt; 模块：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import configparser
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;2. 创建一个 ConfigParser 对象&lt;/h2&gt;
&lt;p&gt;要开始读取或写入配置文件，您需要创建一个 &lt;code&gt;ConfigParser&lt;/code&gt; 对象。可以使用 &lt;code&gt;configparser.ConfigParser()&lt;/code&gt; 函数创建该对象。&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;config = configparser.ConfigParser()
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3. 读取配置文件&lt;/h2&gt;
&lt;p&gt;要从配置文件中读取数据，您需要使用 &lt;code&gt;read()&lt;/code&gt; 方法。例如，要读取名为 &lt;code&gt;config.ini&lt;/code&gt; 的文件：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;config.read('config.ini')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果您有多个配置文件，则可以传递一个列表：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;config.read(['config.ini', 'config2.ini'])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;4. 读取配置值&lt;/h2&gt;
&lt;p&gt;要读取配置文件中的值，请使用 &lt;code&gt;get()&lt;/code&gt; 方法。例如，要获取 &lt;code&gt;config.ini&lt;/code&gt; 文件中 &lt;code&gt;[section]&lt;/code&gt; 部分的 &lt;code&gt;option&lt;/code&gt; 值：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;value = config.get('section', 'option')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;get()&lt;/code&gt; 方法有一个可选的 &lt;code&gt;fallback&lt;/code&gt; 参数，如果在配置文件中找不到给定的 &lt;code&gt;option&lt;/code&gt;，则使用该参数的值。&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;value = config.get('section', 'option', fallback='default_value')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果您需要读取整数值，可以使用 &lt;code&gt;getint()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;value = config.getint('section', 'option')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似地，如果您需要读取布尔值，则可以使用 &lt;code&gt;getboolean()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;value = config.getboolean('section', 'option')
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;5. 写入配置值&lt;/h2&gt;
&lt;p&gt;要将值写入配置文件，请使用 &lt;code&gt;set()&lt;/code&gt; 方法。例如，要将 &lt;code&gt;[section]&lt;/code&gt; 部分的 &lt;code&gt;option&lt;/code&gt; 设置为 &lt;code&gt;value&lt;/code&gt;：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;config.set('section', 'option', 'value')
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;6. 保存配置文件&lt;/h2&gt;
&lt;p&gt;要将更改保存回文件，请使用 &lt;code&gt;write()&lt;/code&gt; 方法。例如，要将更改保存回 &lt;code&gt;config.ini&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;with open('config.ini', 'w') as configfile:
    config.write(configfile)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将使用 &lt;code&gt;with&lt;/code&gt; 语句打开文件并将更改写入文件中。&lt;/p&gt;
&lt;p&gt;这是 &lt;code&gt;configparser&lt;/code&gt; 模块的基本用法。还有一些其他方法，例如 &lt;code&gt;add_section()&lt;/code&gt; 和 &lt;code&gt;remove_section()&lt;/code&gt; 用于添加或删除部分，以及 &lt;code&gt;options()&lt;/code&gt; 和 &lt;code&gt;items()&lt;/code&gt; 用于列出部分中的选项或键值对。请查阅官方文档以获取更多信息。&lt;/p&gt;</html_content></item><item><title>python 爬虫常用模块lxml使用</title><description>&lt;ol&gt;
&lt;li&gt;lxml库的安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;pip install lxml
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;xpath常用规则说明&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;| 表达式    | 规则描述    |
| ----------- | -----------</description><html_content>&lt;ol&gt;
&lt;li&gt;lxml库的安装&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;pip install lxml
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;xpath常用规则说明&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;| 表达式    | 规则描述    |
| ----------- | ----------- |
| nodename | 选取此节点打所以子节点，xpath('body') |
| / | 从当前节点选取直接子节点 |
| // | 从当前节点选取子孙节点 |
| . | 选取当前节点 |
| .. | 选取当前节点的父节点 |
| @ | 选取属性 |
| * | 通配符,选取所有元素节点与元素名 |
| @* | 选取所有属性 |
| [@attrib] | 选取具有给定属性的所有元素 |
| @attrib=''value' | 选取给定属性具有给定值得所有元素 |
| text() |  选取文本，/text()选取标签中直系的文本内容，//text()选取标签中所有文本内容 |&lt;/p&gt;
&lt;p&gt;查找某个特定的节点或者包含某个特定值的节点，用“[]”括起来。&lt;/p&gt;
&lt;p&gt;实例&lt;/p&gt;
&lt;p&gt;| 表达式    | 规则描述    |
| ----------- | ----------- |
| /div/p[n] | 选取div子元素的第n个p元素 |
| /div/p[last()] |  选取div子元素的最后一个p元素 |
| /div/p[last()-1] |    选取div子元素的倒数第二个p元素 |
| /div/p[book&amp;lt;n] |  选取div子元素的前n-1个book元素 |
| //div/[@id] |     选取所有拥有名称为id属性的div节点 |
| //div[@id='app' |     选取所有div节点，且拥有id属性的值为app的属性 |&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;举例&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;from lxml import etree,html

ret = &amp;quot;&amp;quot;&amp;quot;
&amp;lt;div&amp;gt;
    &amp;lt;ul&amp;gt;
         &amp;lt;li class=&amp;quot;item-0&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;link1.html&amp;quot;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&amp;quot;item-1&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;link2.html&amp;quot;&amp;gt;second item&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
         &amp;lt;li class=&amp;quot;item-0&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;link5.html&amp;quot;&amp;gt;a属性&amp;lt;/a&amp;gt;
     &amp;lt;/ul&amp;gt;
 &amp;lt;/div&amp;gt;

&amp;quot;&amp;quot;&amp;quot;


ret1 = requests.get(&amp;quot;http://www.linke.fun&amp;quot;)
#从文本获取解析对象，有两种方式etree.HTML()和html.fromstring()方法，对比两种方式，etree解析功能更多，html专解析html
html = etree.HTML(ret)
html1 = html.fromstring(ret1.content)

# 读取html文件进行解析
html2=etree.parse('test.html',etree.HTMLParser())

#获取所有节点
## 获取所有节点,//表示获取所有子孙节点,*表示所有
print(html.xpath('//*'))

#获取子节点
## 获取div下的ul子节点
print(html.xpath('//div/ul'))

#获取父节点
## 获取ul节点的父节点,使用.. 或者parent::*
print(html.xpath('//ul/..'))
print(html.xpath('//ul/parent::*'))

#按属性匹配节点
## 一个属性里只有单个属性值获取，通过属性匹配过滤查找节点,形式为[@key=value]
print(html.xpath('//ul[@id=&amp;quot;002&amp;quot;]/*'))  #选取id=002的ul节点

## 一个属性里有多个属性值时使用contains获取，对比获取class=&amp;quot;aaa item-0&amp;quot;和class=&amp;quot;aaa&amp;quot;区别
print(html.xpath('//li[@class=&amp;quot;aaa&amp;quot;]/a'))   #只能匹配class=&amp;quot;aaa&amp;quot;
print(html.xpath('//li[contains(@class,&amp;quot;aaa&amp;quot;)]/a')) # 可以匹配class=&amp;quot;aaa&amp;quot;和class=&amp;quot;aaa item-0&amp;quot;

## 多属性匹配,可以使用and运算符连接,查找&amp;quot;&amp;lt;li class=&amp;quot;aaa&amp;quot; name=&amp;quot;item&amp;quot;&amp;gt;&amp;lt;a href=&amp;quot;link1.html&amp;quot;&amp;gt;第一个&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;&amp;quot;
print(html.xpath('//li[@class=&amp;quot;aaa&amp;quot; and @name=&amp;quot;item&amp;quot;]/a')）

#获取属性
print(html.xpath('//li[@class=&amp;quot;aaa&amp;quot;]/a/@href)')) #获取a节点打href值

#获取文本
print(html.xpath('//li[@class=&amp;quot;aaa&amp;quot;]/a/text()')) #获取a节点打文本内容

#顺序选择
print(html.xpath('//li[contains(@class,&amp;quot;aaa&amp;quot;)]/a/text()')) #获取所有li节点下a节点的内容
print(html.xpath('//li[1][contains(@class,&amp;quot;aaa&amp;quot;)]/a/text()')) #获取第一个
print(html.xpath('//li[last()][contains(@class,&amp;quot;aaa&amp;quot;)]/a/text()')) #获取最后一个
print(html.xpath('//li[position()&amp;gt;2 and position()&amp;lt;4][contains(@class,&amp;quot;aaa&amp;quot;)]/a/text()')) #获取第三个
print(html.xpath('//li[last()-2][contains(@class,&amp;quot;aaa&amp;quot;)]/a/text()' #获取倒数第三个

## 节点轴选择
print(html.xpath('//ul/ancestor::*')) # 获取ul节点的所有祖先节点
print(html.xpath('//ul/ancestor::div')) # 获取ul节点的所有祖先div节点
print(html.xpath('//li/attribute::class')) # 获取ul节点的所有属性值
print(html.xpath('//ul/child::li')) # 获取ul节点的所有直接li子节点
print(html.xpath('//ul/descendant::a')) # 获取ul节点的所有子孙节点的a节点
print(html.xpath('//ul[@id=001]/following::*')) # 获取当前子节点之后的所有节点,第一个ul节点之后是第二个ul节点，输出为第二个ul节点和它的所有子孙节点
print(html.xpath('//ul/following-sibling::*')) # 获取当前节点打所有同级节点
&lt;/code&gt;&lt;/pre&gt;</html_content></item><item><title>python的字典类型常见处理方式</title><description>&lt;p&gt;在Python中，字典（dictionary）类型是一种常见且重要的数据结构，它提供了键-值对的存储方式。以下是一些常见的字典处理方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问字典元素：使用键（key）访问字典中的值（value）。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_dict =</description><html_content>&lt;p&gt;在Python中，字典（dictionary）类型是一种常见且重要的数据结构，它提供了键-值对的存储方式。以下是一些常见的字典处理方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;访问字典元素：使用键（key）访问字典中的值（value）。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_dict = {&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 25, &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;}
print(my_dict[&amp;quot;name&amp;quot;])  # 输出：&amp;quot;Alice&amp;quot;
print(my_dict[&amp;quot;age&amp;quot;])   # 输出：25
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;添加或修改字典元素：通过键来添加或修改字典中的元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_dict = {&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 25, &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;}
my_dict[&amp;quot;occupation&amp;quot;] = &amp;quot;Engineer&amp;quot;    # 添加新的键值对
my_dict[&amp;quot;age&amp;quot;] = 26                   # 修改现有键的值
print(my_dict)                        # 输出：{&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 26, &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;, &amp;quot;occupation&amp;quot;: &amp;quot;Engineer&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;删除字典元素：使用&lt;code&gt;del&lt;/code&gt;语句删除指定的键值对。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_dict = {&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 25, &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;}
del my_dict[&amp;quot;age&amp;quot;]
print(my_dict)  # 输出：{&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;遍历字典：使用循环结构遍历字典的键或值。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_dict = {&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 25, &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;}
# 遍历键(keys)
for key in my_dict:
    print(key)
# 遍历值(values)
for value in my_dict.values():
    print(value)
# 遍历键值对(items)
for key, value in my_dict.items():
    print(key, value)
#使用enumerate()函数
my_dict = {&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 25, &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;}
for index, key in enumerate(my_dict):
    value = my_dict[key]
    print(index, key, value)
#使用字典解析
my_dict = {&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 25, &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;}
new_dict = {key: value for key, value in my_dict.items()}
print(new_dict)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;获取字典长度：使用&lt;code&gt;len()&lt;/code&gt;函数获取字典中键值对的数量。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_dict = {&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 25, &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;}
length = len(my_dict)
print(length)  # 输出：3
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;检查键是否存在：使用&lt;code&gt;in&lt;/code&gt;关键字检查某个键是否存在于字典中。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_dict = {&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 25, &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;}
if &amp;quot;name&amp;quot; in my_dict:
    print(&amp;quot;Name exists in the dictionary.&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;获取字典的键列表、值列表或键值对列表：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;my_dict = {&amp;quot;name&amp;quot;: &amp;quot;Alice&amp;quot;, &amp;quot;age&amp;quot;: 25, &amp;quot;city&amp;quot;: &amp;quot;New York&amp;quot;}
keys = list(my_dict.keys())         # 获取键列表
values = list(my_dict.values())     # 获取值列表
items = list(my_dict.items())       # 获取键值对列表
print(keys)
print(values)
print(items)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这些是常见的字典处理方式，可以根据具体的需求和场景选择适合的方法来操作和处理字典。字典提供了灵活且强大的功能，可以用于各种数据存储和处理的任务。&lt;/p&gt;</html_content></item><item><title>linux利用python编写计划任务同步文件</title><description>&lt;h3&gt;python利用rsync每隔30秒同步一次文件并记录到日志&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import subprocess
import datetime
from apscheduler.schedulers.blocking import BlockingScheduler

def</description><html_content>&lt;h3&gt;python利用rsync每隔30秒同步一次文件并记录到日志&lt;/h3&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import subprocess
import datetime
from apscheduler.schedulers.blocking import BlockingScheduler

def sync_files():
    # 原始路径
    source_path = &amp;quot;/home/dev/192.168.10.114&amp;quot;
    # 目标路径,如果是远程目录,需要配置ssh免密，否则需要输入密码
    destination_path = &amp;quot;/tmp/&amp;quot;

    # 获取当前时间作为日志记录时间
    timestamp = datetime.datetime.now().strftime(&amp;quot;%Y-%m-%d %H:%M:%S&amp;quot;)
    log_message = f&amp;quot;[{timestamp}] Starting file synchronization...\n&amp;quot;

    try:
        rsync_cmd = f&amp;quot;rsync -avz --delete {source_path} {destination_path}&amp;quot;
        output = subprocess.check_output(rsync_cmd, shell=True, stderr=subprocess.STDOUT)
        log_message += output.decode(&amp;quot;utf-8&amp;quot;) + &amp;quot;\n&amp;quot;

        log_message += f&amp;quot;[{timestamp}] File synchronization completed successfully.\n&amp;quot;
    except subprocess.CalledProcessError as e:
        log_message += f&amp;quot;[{timestamp}] File synchronization failed. Error: {e.output.decode('utf-8')}\n&amp;quot;

    # 将日志写入文件
    with open(&amp;quot;/tmp/log.txt&amp;quot;, &amp;quot;a&amp;quot;) as log_file:
        log_file.write(log_message)

if __name__ == '__main__':
    scheduler = BlockingScheduler()
    scheduler.add_job(sync_files, 'interval', seconds=30)
    scheduler.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;代码中subprocess.check_output和supprocess.call的不同&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;subprocess.call&lt;/code&gt;和&lt;code&gt;subprocess.check_output&lt;/code&gt;是Python的&lt;code&gt;subprocess&lt;/code&gt;模块提供的两个函数，用于执行外部命令。它们之间的区别如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;subprocess.call&lt;/code&gt;：&lt;/li&gt;
&lt;li&gt;功能：&lt;code&gt;call&lt;/code&gt;函数用于执行指定的命令，并等待命令执行完成后返回。&lt;/li&gt;
&lt;li&gt;返回值：返回命令的执行状态，一般情况下，返回值为0表示命令执行成功，非零值表示命令执行失败。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出：命令的输出将直接打印到标准输出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;subprocess.check_output&lt;/code&gt;：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;功能：&lt;code&gt;check_output&lt;/code&gt;函数用于执行指定的命令，并等待命令执行完成后返回命令的输出结果。&lt;/li&gt;
&lt;li&gt;返回值：返回命令的输出结果（字节串类型）。&lt;/li&gt;
&lt;li&gt;异常：如果命令执行失败（返回值非零），则会引发&lt;code&gt;CalledProcessError&lt;/code&gt;异常。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，&lt;code&gt;call&lt;/code&gt;函数适用于只需要执行命令并检查执行状态的情况，而&lt;code&gt;check_output&lt;/code&gt;函数适用于需要获取命令执行的输出结果的情况。&lt;/p&gt;
&lt;p&gt;需要注意的是，&lt;code&gt;call&lt;/code&gt;和&lt;code&gt;check_output&lt;/code&gt;函数都是同步执行的，即程序会在执行命令的过程中暂停等待，直到命令执行完成。如果需要异步执行命令，可以考虑使用&lt;code&gt;subprocess.Popen&lt;/code&gt;函数。&lt;/p&gt;
&lt;p&gt;下面是一个简单的示例，演示了&lt;code&gt;call&lt;/code&gt;和&lt;code&gt;check_output&lt;/code&gt;函数的使用：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import subprocess

# 使用call函数执行命令
exit_code = subprocess.call(&amp;quot;ls -l&amp;quot;, shell=True)
print(&amp;quot;Command executed with exit code:&amp;quot;, exit_code)

# 使用check_output函数执行命令并获取输出结果
output = subprocess.check_output(&amp;quot;ls -l&amp;quot;, shell=True)
print(&amp;quot;Command output:&amp;quot;)
print(output.decode(&amp;quot;utf-8&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上述示例中，首先使用&lt;code&gt;call&lt;/code&gt;函数执行了一个&lt;code&gt;ls -l&lt;/code&gt;的命令，并将执行状态存储在&lt;code&gt;exit_code&lt;/code&gt;变量中，然后打印了执行状态。接下来，使用&lt;code&gt;check_output&lt;/code&gt;函数执行同样的命令，并将输出结果存储在&lt;code&gt;output&lt;/code&gt;变量中，最后打印了输出结果。&lt;/p&gt;
&lt;p&gt;请注意，&lt;code&gt;shell=True&lt;/code&gt;参数用于在shell环境中执行命令，&lt;code&gt;decode("utf-8")&lt;/code&gt;用于将输出结果从字节串转换为字符串。&lt;/p&gt;
&lt;h3&gt;添加到开机自启动&lt;/h3&gt;
&lt;p&gt;要将该同步脚本作为Linux系统的守护进程，并实现开机自启动，你可以使用Systemd服务来完成。Systemd是现代Linux系统的守护进程管理器，它提供了管理和控制系统服务的功能。&lt;/p&gt;
&lt;p&gt;以下是具体的设置步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建一个Systemd服务配置文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在Linux系统中，Systemd服务配置文件通常存储在&lt;code&gt;/etc/systemd/system/&lt;/code&gt;目录下，以&lt;code&gt;.service&lt;/code&gt;为后缀。你可以选择在该目录下创建一个新的服务配置文件，例如&lt;code&gt;file-sync.service&lt;/code&gt;。&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-shell"&gt;sudo nano /etc/systemd/system/file-sync.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在打开的文件中，添加以下内容：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;[Unit]
Description=File Synchronization Service
After=network.target

[Service]
User=your_username
ExecStart=/usr/bin/python3 /path/to/your_script.py

[Install]
WantedBy=default.target
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请确保按照实际情况修改以下内容：
- &lt;code&gt;Description&lt;/code&gt;：描述服务的信息。
- &lt;code&gt;User&lt;/code&gt;：你希望该服务以哪个用户身份运行，将&lt;code&gt;your_username&lt;/code&gt;替换为你的用户名。
- &lt;code&gt;ExecStart&lt;/code&gt;：指定要运行的Python解释器路径和你的同步脚本的路径。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;保存并关闭文件。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;按下&lt;code&gt;Ctrl + X&lt;/code&gt;，然后按下&lt;code&gt;Y&lt;/code&gt;，最后按下&lt;code&gt;Enter&lt;/code&gt;来保存并关闭文件。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;启用并启动服务。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;执行以下命令启用并启动服务：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-shell"&gt;sudo systemctl enable file-sync.service
sudo systemctl start file-sync.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会启用该服务，并立即启动它。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;验证服务状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你可以执行以下命令来验证服务的状态：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-shell"&gt;sudo systemctl status file-sync.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果一切正常，你应该能够看到服务正在运行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开机自启动设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要让该服务在系统开机时自动启动，执行以下命令：&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-shell"&gt;sudo systemctl enable file-sync.service
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这将会在系统开机时自动启动该服务。&lt;/p&gt;
&lt;p&gt;现在，你的同步脚本已经作为一个守护进程运行，并实现了开机自启动。你可以根据需要对脚本和服务进行调整和管理。&lt;/p&gt;
&lt;h3&gt;scheduler.add_job解析&lt;/h3&gt;
&lt;p&gt;根据您提供的代码片段，看起来您正在使用一个调度程序（scheduler）来执行名为&lt;code&gt;sync_files&lt;/code&gt;的函数。&lt;code&gt;scheduler.add_job()&lt;/code&gt;函数用于向调度程序添加一个任务，并指定任务的执行方式和参数。&lt;/p&gt;
&lt;p&gt;具体来说，&lt;code&gt;add_job()&lt;/code&gt;函数的参数解析如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一个参数 (&lt;code&gt;sync_files&lt;/code&gt;) 是要执行的函数或方法的名称或引用。这是您希望调度程序定期执行的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个参数 (&lt;code&gt;'interval'&lt;/code&gt;) 是触发器的类型。在这种情况下，您使用了&lt;code&gt;'interval'&lt;/code&gt;触发器，它会在指定的时间间隔内重复执行任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;seconds=30&lt;/code&gt;是一个关键字参数，用于指定触发器的时间间隔。在这里，任务将每隔30秒执行一次。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;综上所述，您的代码片段将会向调度程序添加一个任务，该任务是定期（每隔30秒）执行名为&lt;code&gt;sync_files&lt;/code&gt;的函数。请注意，这只是调度程序的一部分，您可能还需要其他代码来实际启动和运行调度程序。&lt;/p&gt;
&lt;h3&gt;触发器类型&lt;/h3&gt;
&lt;p&gt;在调度程序中，常见的触发器类型有以下几种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;date&lt;/code&gt;（日期触发器）：在指定的日期和时间执行一次任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;interval&lt;/code&gt;（间隔触发器）：在指定的时间间隔内重复执行任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cron&lt;/code&gt;（Cron触发器）：根据Cron表达式设置任务执行的时间计划。Cron表达式可以非常灵活地定义任务执行的时间，包括分钟、小时、日期、月份和星期几等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;trigger&lt;/code&gt;（自定义触发器）：您可以创建自定义的触发器类来满足特定的调度需求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些触发器类型为任务的执行提供了不同的时间安排方式，使您能够根据具体需求来安排任务的执行。您可以根据任务的执行频率、时间间隔或特定日期/时间来选择适合的触发器类型。&lt;/p&gt;
&lt;h3&gt;触发器类型举例&lt;/h3&gt;
&lt;p&gt;当使用调度程序时，以下是不同类型的触发器的示例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;date&lt;/code&gt; 触发器示例：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;scheduler.add_job(my_function, 'date', run_date=datetime(2023, 5, 10, 8, 30, 0))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述示例中，&lt;code&gt;my_function&lt;/code&gt; 函数将在 2023 年 5 月 10 日 8:30:00 执行一次。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;interval&lt;/code&gt; 触发器示例：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;scheduler.add_job(my_function, 'interval', seconds=60)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述示例中，&lt;code&gt;my_function&lt;/code&gt; 函数将每隔 60 秒执行一次。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cron&lt;/code&gt; 触发器示例：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;scheduler.add_job(my_function, 'cron', minute='*/15', hour='9-17', day_of_week='mon-fri')
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述示例中，&lt;code&gt;my_function&lt;/code&gt; 函数将在每小时的每隔 15 分钟执行一次，从周一到周五的 9 点到 17 点之间。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自定义触发器示例：
您可以根据自己的需求创建自定义的触发器类，这里只展示一个简单的示例：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;class MyCustomTrigger:
    def __init__(self, some_parameter):
        self.parameter = some_parameter

    def get_next_run_time(self, previous_run_time):
        # 自定义计算下一次运行时间的逻辑
        # 返回下一次运行时间的 datetime 对象

# 使用自定义触发器
my_trigger = MyCustomTrigger(some_value)
scheduler.add_job(my_function, my_trigger)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上述示例中，您可以创建一个自定义的触发器类&lt;code&gt;MyCustomTrigger&lt;/code&gt;，根据自己的逻辑计算下一次运行时间，并将其传递给调度程序的 &lt;code&gt;add_job()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;这些示例涵盖了常见的触发器类型，您可以根据自己的需求选择适合的触发器类型，并根据触发器的参数进行调整。&lt;/p&gt;</html_content></item><item><title>python常用内置模块</title><description>&lt;h4&gt;加密模块hashlib&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;MD5加密和SHA1加密，方法类似&lt;/strong&gt;
1. 就算一个字符串的md5值&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import hashlib
import</description><html_content>&lt;h4&gt;加密模块hashlib&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;MD5加密和SHA1加密，方法类似&lt;/strong&gt;
1. 就算一个字符串的md5值&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import hashlib
import time

#加密字符串'123'和当前时间戳组成的字符串的md5值
ctime=time.time()
m = hashlib.md5(bytes('123'+str(ctime),encoding='utf-8'))

# 查看加密字符串
print m.hexdigest()
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;将一个字符串分段多次加密，结果也是一样
更上例一样&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import hashlib
import time

#先计算字符串'123'的md5值
m = hashlib.md5(bytes('123',encoding='utf-8'))
# 在叠加计算当前时间戳的md5值
m.update(bytes(str(ctime),encoding='utf-8'))


# 查看加密字符串
print m.hexdigest()
&lt;/code&gt;&lt;/pre&gt;</html_content></item></search>