<?xml version='1.0' encoding='utf-8'?>
<search><item><title>搞了一个摸鱼小工具</title><description>&lt;p&gt;作为一个工作上没有太多发展的牛马，每天的空闲时间倒是不少，所以总是喜欢盯着手机看盘，长时间这样，一来在公司里影响不是很好，再者昨天也有说长时间的看盘对我来说并没有什么好处，钱没赚到还把自己的心态搞的乱七八糟。但是我又想偶尔看一下我关注的那些。想了半天，搞一个小窗口放在电脑桌面上实时显示想关注的代码不就可以了，一来减少自己盯着手机看盘的时间，还可以让自己多干点其它的事情，这简直就是一个满足自己</description><html_content>&lt;p&gt;作为一个工作上没有太多发展的牛马，每天的空闲时间倒是不少，所以总是喜欢盯着手机看盘，长时间这样，一来在公司里影响不是很好，再者昨天也有说长时间的看盘对我来说并没有什么好处，钱没赚到还把自己的心态搞的乱七八糟。但是我又想偶尔看一下我关注的那些。想了半天，搞一个小窗口放在电脑桌面上实时显示想关注的代码不就可以了，一来减少自己盯着手机看盘的时间，还可以让自己多干点其它的事情，这简直就是一个满足自己摸鱼的小神器啊。&lt;/p&gt;
&lt;p&gt;然而我这写代码的能力有点牵强，但是不怕，这一刻咱在体会一下AI给我们带来的便利吧。需求一描述，GPT分分钟给我来了一段代码。我直接复制粘贴到我本地环境当中运行测试一下，在优化一下部分文字显示内容。摸鱼小神器就出来了。&lt;/p&gt;
&lt;p&gt;&lt;img alt="2024-12-19_142000" src="http://nas.izcat.com:9001/webpic/2024-12-19_142000.png" /&gt;&lt;/p&gt;
&lt;p&gt;嗯，界面简陋，需求满足，放在桌面上就算被人看到了，也不会觉得再摸鱼，是我想要的样子。昨天使用到今天，确实减少了我闲下来就去盯手机看的时间，希望这可以帮我控制和减少看盘的时间。代码还是挺简单的，如果有觉得正好合适的可以问问GPT，或者问我要。所谓工具好不好，合适最重要&lt;/p&gt;</html_content></item><item><title>心态有点乱</title><description>&lt;p&gt;继上次调仓之后，走势都不是很理想，观察了两三天的走势没有走出自己预期的样子，图形走坏，流动性也差，想趁反弹减仓都没有机会，在前天看着大盘整体都不是很好的时候做了止损操作做了换股，结果预期昨天的反弹修复，似乎又打脸了，总之心态有点乱了。看看这操作更像是都涨跌。完全没有章法，全是靠着自己的一股脑在瞎操作。&lt;/p&gt;
&lt;p&gt;股票投资是门学问。要学的东西太多。太在意短期的数字涨跌容易搞乱心态，没有定力</description><html_content>&lt;p&gt;继上次调仓之后，走势都不是很理想，观察了两三天的走势没有走出自己预期的样子，图形走坏，流动性也差，想趁反弹减仓都没有机会，在前天看着大盘整体都不是很好的时候做了止损操作做了换股，结果预期昨天的反弹修复，似乎又打脸了，总之心态有点乱了。看看这操作更像是都涨跌。完全没有章法，全是靠着自己的一股脑在瞎操作。&lt;/p&gt;
&lt;p&gt;股票投资是门学问。要学的东西太多。太在意短期的数字涨跌容易搞乱心态，没有定力还是要减少看盘，因为这样会让自己忘了买入时的计划或者想法。乱了心态自然乱了操作。这样怎么能长久下去呢。&lt;/p&gt;
&lt;p&gt;改变自己，从记录自己的真实想法和操作开始，慢慢总结复盘，慢慢改正，希望未来能看到自己在这条路上有长进。&lt;/p&gt;</html_content></item><item><title>K线技术分析指标学习记录-看懂RSI</title><description>&lt;p&gt;&lt;strong&gt;RSI指标解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RSI（&lt;strong&gt;相对强弱指数&lt;/strong&gt;）是一个常用的技术分析指标，用来衡量一只股票在&lt;strong&gt;特定时间内涨跌的力度对比&lt;/strong&gt;，可帮助我们判断股票是否&lt;strong&gt;超买&lt;/strong&gt;或&lt;strong&gt;超卖&lt;/strong&gt;。通俗点说，就是它是告诉你当前市场是不是&lt;strong&gt;涨太多了（需要</description><html_content>&lt;p&gt;&lt;strong&gt;RSI指标解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RSI（&lt;strong&gt;相对强弱指数&lt;/strong&gt;）是一个常用的技术分析指标，用来衡量一只股票在&lt;strong&gt;特定时间内涨跌的力度对比&lt;/strong&gt;，可帮助我们判断股票是否&lt;strong&gt;超买&lt;/strong&gt;或&lt;strong&gt;超卖&lt;/strong&gt;。通俗点说，就是它是告诉你当前市场是不是&lt;strong&gt;涨太多了（需要回调）&lt;/strong&gt; 或者 &lt;strong&gt;跌太多了（可能反弹）&lt;/strong&gt; 。这个指标简单直观，短线交易非常常用，特别是震荡行情当中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RSI的取值和计算方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;取值范围&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RSI 的值在0 到 100之间：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高于 70&lt;/strong&gt;：表示股票可能&lt;strong&gt;超买&lt;/strong&gt;，即价格涨得太猛了，可能会回调。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;低于 30&lt;/strong&gt;：表示股票可能&lt;strong&gt;超卖&lt;/strong&gt;，即价格跌得太狠了，可能会反弹。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中间区域（30~70）&lt;/strong&gt;：一般没有明确的买卖信号，市场较为平稳。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RSI是怎么算的？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一种传统计算公式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A 表示n天上涨幅度之后，B表示n天下跌幅度之和&lt;/p&gt;
&lt;p&gt;RSI（n)=A/（A+B)×100%&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二种计算公式&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计算一定周期内的涨幅和跌幅&lt;/strong&gt;（以14天的周期为例）：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RSI 计算最近 14 天的涨跌幅。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;把这 14 天内每天的涨幅加总得到 &lt;strong&gt;平均涨幅&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同理，把 14 天内每天的跌幅加总得到 &lt;strong&gt;平均跌幅&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;计算强弱比（RS）：&lt;/strong&gt;
   $$
   RS = \frac{\text{平均涨幅}}{\text{平均跌幅}}
   $$&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;比如，最近 14 天平均涨幅是 2，平均跌幅是 1，RS = 2 / 1 = 2。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;计算 RSI：&lt;/strong&gt;
   $$
   RSI = 100 - \frac{100}{1 + RS}
   $$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果 RS = 2
   $$
   RSI = 100 - \frac{100}{1 + 2} = 100 - 33.33 = 66.67
   $$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单的举个例子&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设某股票最近 14 天的收盘价涨跌如下(如果相比前一天是涨，就在涨幅这边加入，跌幅为0，同理，如果相比前一天是跌，在跌幅这边加入，涨幅为0)：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;日期&lt;/th&gt;
&lt;th&gt;涨幅&lt;/th&gt;
&lt;th&gt;跌幅&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第1天&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第2天&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第3天&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第4天&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;td&gt;...&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第14天&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;$$
\begin{align}
平均涨幅 = \frac{2 + 3 + 1}{14} = 0.43 
\
平均跌幅 = \frac{1 + 2}{14} = 0.21
\
RS=\frac{0.43}{0.21} = 2.05
\
RSI=100 - \frac{100}{1 + 2.05} \approx 67.2
\end{align}
$$&lt;/p&gt;
&lt;p&gt;这意味着 RSI 处于 67 附近，接近 70，可能进入超买区&lt;/p&gt;
&lt;p&gt;相比之下，第二种计算方式较为复杂， 但计算的RSI 的值更平滑，更加稳定&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;股票软件上的RSI指标解析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在没了解RSI指标之前，我是看不懂股票软件上的RSI指标的，比如日K线的RSI指标是&lt;code&gt;RSI(6,12,24) RSI1:41.279 RSI2: 49.594 RSI3: 52.606&lt;/code&gt;这个是什么意思。在前面的学习案例里，我们使用的是14日为周期计算的。这里的&lt;code&gt;RSI(6,12,24)&lt;/code&gt;其实就是多周期，代表了6，12，24三个不同的周期，后面的RSI1/RSI2/RSI3分别是对应周期的RSI值。&lt;/p&gt;</html_content></item><item><title>今天清仓了一只票</title><description>&lt;p&gt;都说炒股炒的是心态。最近突然有想记录一下自己股票操作和当时的心情，希望能够提升自己的复盘能力和一个稳定的心态吧，怎么说呢。有些情绪明明知道是不该的，但还是会经常出现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;昨日减仓&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;怎么说呢，可能是人内心的贪婪或者执念吧。其实从整体的去看明明是一个很好的成绩了可偏偏还是有那种亏钱了的感觉，或许是心里的小想法在作祟吧。最近有一只票走势挺</description><html_content>&lt;p&gt;都说炒股炒的是心态。最近突然有想记录一下自己股票操作和当时的心情，希望能够提升自己的复盘能力和一个稳定的心态吧，怎么说呢。有些情绪明明知道是不该的，但还是会经常出现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;昨日减仓&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;怎么说呢，可能是人内心的贪婪或者执念吧。其实从整体的去看明明是一个很好的成绩了可偏偏还是有那种亏钱了的感觉，或许是心里的小想法在作祟吧。最近有一只票走势挺好，我一直持有着，但是当涨幅越来越高的时候，今天日内走势是在高位冲高回落的时候，虽然是上涨的，也还没有到心里的目标价位，但自己的内心却发生了变化，最终没忍住做出了减仓的动作，且减仓位置临近日内低点，距离高点有十几个点的差价。心情有很大的落差。可能从这个落差来看就是没有减仓在合适的位置吧。&lt;/p&gt;
&lt;p&gt;减仓股票(2024-12-09):  酷特智能&lt;/p&gt;
&lt;p&gt;减仓理由：&lt;/p&gt;
&lt;p&gt;今日股价创阶段新高，离历史高点近在咫尺，日内却走出了冲高回落的走势，回落11个点左右，虽然是上涨的，但是量能相比前一日是缩量，46%左右的换手，最终在收盘前减仓一半。&lt;/p&gt;
&lt;p&gt;本来内心还是不想减仓的，但是尾盘回落较多，鉴于这种走势，担心第二天低开调整，最终还是做了减仓，没有监管也有一波回调，但是没有想过要减仓，但这次却没有前面回调时持仓的信心了。其实个人感觉在这里减仓一点问题都没有，如果明天低开还可以做T，如果自己预判错误，那就任由剩下的半仓去继续操作。&lt;/p&gt;
&lt;p&gt;心情落差：可能是股价的走势还没有达到内心预设的盈利，但又担心自己的坚持最后会像今天的走势一样，越坚持回吐的越多这两种心里的矛盾冲突导致的吧。总之，心态变了，持股方式也跟着变化了。还是得好好沉淀自己。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;今日清仓&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我操作有个坏习惯，喜欢全仓某一只股票，而且是短时间内打满仓位，最多也就同时持有两只。而且当开始减仓之后基本也会短时间清仓。所以继昨天减仓之后，今天早盘在冲高几个点的时候我就咔咔全部给清掉了，后续盘中走势还创出了比昨天更高的股价，当时心里还有点想着自己是不是不该这么操作，人总是矛盾的，当看着下午的走势跟昨天差不多，且收盘结果更差的时候，我竟然有点觉得自己的操作应该是对的。昨天还在为减仓感到心里有落差，但是看了今天的走势，似乎又感觉昨天减仓也没有那么差了。回顾今天的走势，跟昨天几乎是一样的，依旧是创阶段新高，依旧是冲高回落，回落的幅度更大，依旧是缩量。现在我更感觉现在就是这波上升的鱼尾行情了。既然清仓了，那就不在纠结它怎么走吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新开仓位&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;继早盘清仓之后，又迅速的开了新仓，两只票，每只票给了半仓，直接把仓位全打出去了。其实自己也知道不该那么着急的新开仓位，这也是我这个操作坏习惯吧。当时的心里想着昨天尾盘的利好消息，所以就早早的仓位打出去了。可是今天的走势基本都是冲高回落，今天账面没有亏钱，那是早盘清仓的盈利弥补了今日新开仓位的亏损。两只票目前都亏损2.5个点左右，看看明天情况再说吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;体现的坏毛病&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;患得患失，股票长了觉得错过了几个亿一样的。跌了又庆幸。这种情绪不该有&lt;/li&gt;
&lt;li&gt;急于开仓，在知道不适合开仓的位置开仓，冲动总是战胜理性，这种行为不该有&lt;/li&gt;
&lt;/ol&gt;</html_content></item><item><title>与快递小哥的小插曲</title><description>&lt;p&gt;&lt;strong&gt;与快递小哥的插曲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前几天菜鸟裹裹下单预约了一个快递，因为在上班只能是第二天邮寄的，但是因为选的特惠寄，当时下单的时候不能选择揽件时间，就下完单立马进行了修改。隔了没多久快递小哥就打电话过来说取件了，我说我约的明天。也不知道这小哥是怎么回事，在电话里很冲的说到”你在看看“就把我电话挂了。整的我一脸蒙蔽，我还真以为我搞错了，一看没搞错呀。过了一会，</description><html_content>&lt;p&gt;&lt;strong&gt;与快递小哥的插曲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前几天菜鸟裹裹下单预约了一个快递，因为在上班只能是第二天邮寄的，但是因为选的特惠寄，当时下单的时候不能选择揽件时间，就下完单立马进行了修改。隔了没多久快递小哥就打电话过来说取件了，我说我约的明天。也不知道这小哥是怎么回事，在电话里很冲的说到”你在看看“就把我电话挂了。整的我一脸蒙蔽，我还真以为我搞错了，一看没搞错呀。过了一会，估计小哥知道自己搞错了，又说明天早上来拿件，让我准备好。&lt;/p&gt;
&lt;p&gt;第二天我早早的按他说的时间把快递放在了家门口就出门了，上午的时候收到快递费用账单，我一看2kg，可我的快递明明就1kg以内的东西，于是我电话过去咨询，结果这小哥又是那种很冲的语气说按体积算的，长宽高多少多少啥的，搞的我欠他什么东西一样。我都不知道还有这个说法。可能是他的语气实在不好吧，我当时就火了，让他就按实际重量给我寄，最终没谈好，我就没让他拿走。本来几块钱的差价，好好说或许我会觉得没问题。对于小哥的这种态度。我挂了电话就直接进行了投诉，目前投诉还在处理中，我的快递订单是显示以揽收，但实际未拿走的状态。&lt;/p&gt;
&lt;p&gt;其实我的诉求很简单，按实际重量给我寄出，是多少邮费就是多少，可是非得按体积来给我算个按偏重的来计费，我想如果我在包裹外层在套一层袋子，没有长宽高的了，他会怎么算费用呢？所以这我觉得是不合理的。就算有规定，那你在出账单之前跟我解释了我也可以理解，可是没告知的情况下给我按重的计费，当我不清楚的情况下去咨询的时候还是这种不友好的态度，这我是不能接受的。&lt;/p&gt;</html_content></item><item><title>博客输出内容的一些想法</title><description>&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我其实不是一个喜欢记录的人，而且我也不是一个擅长写作和记录的人，所以对于”记录“这件事并没有很好的持续过，可以预见的是每次弄博客到最后都是不了了之的结果，不然也不会有现在这回事了。但有时候又确实想记录点东西，比如一些操作记录想后续方便查阅，又比如有些emo的时候想有个地方宣泄一下。所以这次我想好好的坚持一下，把这个博客维护的更久一点。</description><html_content>&lt;p&gt;&lt;strong&gt;写在前面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我其实不是一个喜欢记录的人，而且我也不是一个擅长写作和记录的人，所以对于”记录“这件事并没有很好的持续过，可以预见的是每次弄博客到最后都是不了了之的结果，不然也不会有现在这回事了。但有时候又确实想记录点东西，比如一些操作记录想后续方便查阅，又比如有些emo的时候想有个地方宣泄一下。所以这次我想好好的坚持一下，把这个博客维护的更久一点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记录的内容&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如今的生活也就是工作和家庭了。以前还总隔三岔五的与朋友聚聚，如今也很少有这些社交了，几乎没有了。对于公司的团建活动都已经是能不参加的就不参加了，更多的时候还是喜欢宅家，也许是因为这样，所以想要记录点东西的想法在脑子里也越来越多的时候出现了。&lt;/p&gt;
&lt;p&gt;对于博客内容这一块，还是想怎么记录就怎么记录了，工作、生活、兴趣爱好等想记录了就记录下，主打一个随意，这里就是我的后花园了。总体规划的是折腾、随笔这两个大分类吧。折腾记录与工作或者技术相关类的、随笔记录一些生活、心情、和兴趣爱好相关的吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;坚持吧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我这人有个不好的地方，有些事情干着干着突然会质疑这件事的必要性、重要性或者说意义什么的。我也不知道这是为什么，可能我的性格比较随性吧，就比如现在说的"记录"这件事，搞不好哪天我内心又在想记录这些干啥。所以这次不管怎么说，都希望自己能记录的更久。&lt;/p&gt;</html_content></item><item><title>博客的搜索功能是怎么实现的</title><description>&lt;p&gt;之前我介绍了我的博客的实现，其中最后的demo里面有个搜索功能，今天就来介绍下这个搜索功能的实现吧。其实静态博客的搜索功能实现起来挺简单的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们有一个&lt;code&gt;posts&lt;/code&gt; 的包含所有文章信息的列表，</description><html_content>&lt;p&gt;之前我介绍了我的博客的实现，其中最后的demo里面有个搜索功能，今天就来介绍下这个搜索功能的实现吧。其实静态博客的搜索功能实现起来挺简单的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;假设我们有一个&lt;code&gt;posts&lt;/code&gt; 的包含所有文章信息的列表， 通过&lt;code&gt;generate_search_xml&lt;/code&gt;函数处理传入的&lt;code&gt;posts&lt;/code&gt;参数，将文章的标题、内容等信息写入一个&lt;code&gt;search.xml&lt;/code&gt;文件内，后续在通过搜索页面对该文件内容进行搜索实现搜索展示。这里涉及到两个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;search.xml&lt;/code&gt;文件的生成，由&lt;code&gt;generate_search_xml&lt;/code&gt;函数实现&lt;/li&gt;
&lt;li&gt;搜索页面对&lt;code&gt;search.xml&lt;/code&gt;文件进行搜索，并展示搜索结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;generate_search_xml&lt;/code&gt;函数实现&lt;/strong&gt;&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import xml.etree.ElementTree as ET
def generate_search_xml(posts):
    &amp;quot;&amp;quot;&amp;quot;根据文章信息生成 search.xml&amp;quot;&amp;quot;&amp;quot;
    search_xml = ET.Element('search')

    for post in posts:
        title = post['title']
        html_content = post['html_content']
        metadata = post['metadata']

        # 生成描述，提取文章正文的前200个字符作为描述
        description = html_content[:200].strip()  # 提取内容的前200个字符作为描述
        if len(description) == 200 and html_content[200] not in [' ', '&amp;lt;']:  # 防止截断在单词或标签中间
            description = description.rsplit(' ', 1)[0]

        item = ET.SubElement(search_xml, 'item')
        title_elem = ET.SubElement(item, 'title')
        title_elem.text = title
        description_elem = ET.SubElement(item, 'description')
        description_elem.text = description
        # metadata_elem = ET.SubElement(item, 'metadata')
        # metadata_elem.text = metadata
        html_content_elem = ET.SubElement(item, 'html_content')
        html_content_elem.text = html_content

    # 写入到 search.xml 文件
    tree = ET.ElementTree(search_xml)
    output_path = os.path.join(OUTPUT_DIR, 'search.xml')
    tree.write(output_path, encoding='utf-8', xml_declaration=True)
    # print(f&amp;quot;search.xml 文件已保存至 {output_path}&amp;quot;)
    print(f&amp;quot;Generated {search_xml}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面这个函数，将每篇文章的信息以&lt;code&gt;&amp;lt;item&amp;gt;&lt;/code&gt;元素添加到&lt;code&gt;search.xml&lt;/code&gt;文件的根元素&lt;code&gt;&amp;lt;search&amp;gt;&lt;/code&gt;当中，每个 &lt;code&gt;&amp;lt;item&amp;gt;&lt;/code&gt; (也就是每篇文章)包含：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt;: 文章标题&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;description&amp;gt;&lt;/code&gt;: 文章描述（前200个字符）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;html_content&amp;gt;&lt;/code&gt;: 文章的完整 HTML 内容&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;搜索页面的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先通过&lt;code&gt;loadXML()&lt;/code&gt;函数加载&lt;code&gt;search.xml&lt;/code&gt;文件到&lt;code&gt;searchData&lt;/code&gt;列表，然后通过&lt;code&gt;id="search-input"&lt;/code&gt;获取搜索关键字&lt;code&gt;query&lt;/code&gt;，通过方法&lt;code&gt;filter&lt;/code&gt;查找包含关键字&lt;code&gt;query&lt;/code&gt;的内容。最后对查找结果使用&lt;code&gt;displayResults&lt;/code&gt;方法进行生成展示&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;搜索页模板&lt;code&gt;search.html&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-html"&gt;{% extends &amp;quot;base.html&amp;quot; %}

{% block title %}搜索页面{% endblock %}

{% block content %}
    &amp;lt;!-- 页面主要内容 --&amp;gt;
    &amp;lt;div class=&amp;quot;search-box content&amp;quot;&amp;gt;
{#        &amp;lt;h1&amp;gt;搜索页面&amp;lt;/h1&amp;gt;#}

        &amp;lt;div id=&amp;quot;search-container&amp;quot;&amp;gt;
            &amp;lt;img src=&amp;quot;../static/img/搜索_search.png&amp;quot; alt=&amp;quot;Search Icon&amp;quot; class=&amp;quot;search-icon&amp;quot;&amp;gt; &amp;lt;!-- 这里是你的搜索图标图片路径 --&amp;gt;
            &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;search-input&amp;quot; placeholder=&amp;quot;请输入搜索关键字&amp;quot; oninput=&amp;quot;search()&amp;quot;&amp;gt;
        &amp;lt;/div&amp;gt;

        &amp;lt;div id=&amp;quot;search-results&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
    &amp;lt;script&amp;gt;
        // 初始化变量
        let searchData = [];

        // 加载 search.xml 数据
        function loadXML() {
            fetch('search.xml')
                .then(response =&amp;gt; response.text())
                .then(data =&amp;gt; {
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(data, 'text/xml');
                    const items = xmlDoc.getElementsByTagName('item');
                    searchData = [];

                    for (let i = 0; i &amp;lt; items.length; i++) {
                        let title = items[i].getElementsByTagName('title')[0].textContent;
                        let description = items[i].getElementsByTagName('description')[0].textContent;
                        let html_content = items[i].getElementsByTagName('html_content')[0].textContent;
                        searchData.push({ title, description,html_content });
                    }
                })
                .catch(error =&amp;gt; console.error('加载 XML 数据失败:', error));
        }

        function search() {
            const query = document.getElementById('search-input').value.trim().toLowerCase();

            // 如果搜索框为空，清空结果并返回
            if (query === '') {
                document.getElementById('search-results').innerHTML = ''; // 清空搜索结果
                return;
            }

            // 如果有搜索内容，执行搜索操作
            const results = searchData.filter(item =&amp;gt;
                item.title.toLowerCase().includes(query) || item.description.toLowerCase().includes(query) || item.html_content.toLowerCase().includes(query)
            );
            displayResults(query,results);
        }

        // 显示搜索结果
        function displayResults(query,results) {
            const resultsContainer = document.getElementById('search-results');
            resultsContainer.innerHTML = '';

            if (results.length === 0) {
                resultsContainer.innerHTML = '&amp;lt;p&amp;gt;没有找到相关结果&amp;lt;/p&amp;gt;';
                return;
            }

            results.forEach(item =&amp;gt; {
                const resultTitle = document.createElement('h1');
                resultTitle.innerHTML=`包含关键字&amp;lt;span class=&amp;quot;query-color&amp;quot;&amp;gt;${query}&amp;lt;/span&amp;gt;的文章:`;
                resultsContainer.appendChild(resultTitle);
                const resultItem = document.createElement('div');
                resultItem.className = 'result-item';
                resultItem.innerHTML = `
                    &amp;lt;div class=&amp;quot;result-title&amp;quot;&amp;gt;
                            &amp;lt;img src=&amp;quot;../static/img/文字_text.png&amp;quot;&amp;gt;
                            &amp;lt;a href=&amp;quot;article/${item.title}.html&amp;quot;&amp;gt;${item.title}&amp;lt;/a&amp;gt;
                    &amp;lt;/div&amp;gt;
                    &amp;lt;div class=&amp;quot;result-description&amp;quot;&amp;gt;${item.description}&amp;lt;/div&amp;gt;
                `;
                resultsContainer.appendChild(resultItem);
            });
        }

        // 初始化时加载 XML 数据
        window.onload = loadXML;
    &amp;lt;/script&amp;gt;

{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;搜索页面渲染函数实现&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;def generate_search_pages():
    &amp;quot;&amp;quot;&amp;quot; 根据search_template 生成搜索页面&amp;quot;&amp;quot;&amp;quot;
    search_template = env.get_template('search.html')
    search_output_file = os.path.join(OUTPUT_DIR, f&amp;quot;search.html&amp;quot;)
    # 创建目录（如果不存在）
    # os.makedirs(os.path.dirname(share_output_file), exist_ok=True)
    with open(search_output_file, 'w', encoding='utf-8') as file:
        file.write(search_template.render())
    print(f&amp;quot;Generated {search_output_file}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样搜索功能就完成了。&lt;/p&gt;</html_content></item><item><title>从零开始实现一个属于自己的静态博客</title><description>&lt;p&gt;&lt;strong&gt;为什么产生这个想法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实，之前也有弄过个人博客站点，主要是想用来记录平时工作的一些文档，但最后终究是为了搭建而搭建，最开始使用的wordpress这种带后台的建站工具，但是个人不是很喜欢在后台编辑器里面写文章，最后不了了之，再之后又使用hexo这种静态博客生成工具,直接将自己本地的md格式文档直接生成静态博客，从这个角度来说确实挺适合我这种，但</description><html_content>&lt;p&gt;&lt;strong&gt;为什么产生这个想法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实，之前也有弄过个人博客站点，主要是想用来记录平时工作的一些文档，但最后终究是为了搭建而搭建，最开始使用的wordpress这种带后台的建站工具，但是个人不是很喜欢在后台编辑器里面写文章，最后不了了之，再之后又使用hexo这种静态博客生成工具,直接将自己本地的md格式文档直接生成静态博客，从这个角度来说确实挺适合我这种，但是一直都没有找到一个自己觉得满意的主题，最后依旧作罢。最近又萌生了搭建博客的想法，结合前面两次的经验，想想还是自己写一个，以后如果有调整样式也更得心应手些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;博客的产生&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;规划&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于平时的文档都是使用md格式写的，所以打算直接将md文档进行解析来生成博客。但是考虑到平时文档存放基本是在一个目录内无序存放，可能在某个子文件夹内，也可能在根目录下，所以不打算使用子文件夹来做分类目录，所有需要的“分类”、“标签”、“时间”等信息都放在markdown文档的&lt;code&gt;Front Matter&lt;/code&gt;里面。这也是唯一的格式要求(主要考虑博客的分类和标签功能)&lt;/p&gt;
&lt;p&gt;下面是一个参考示例，写作markdown文档的最开头处&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code&gt;---
title: Front Matter示例，写在markdown文档的最开头处
date: 2024-11-15
categories: web建站
tags: ['个人博客']
---
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;主要功能分析与实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首先考虑如何将markdown文档的YAML Front Matter部分和内容部分分离&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;首先检查内容是否以 &lt;code&gt;---&lt;/code&gt; 开头，这是 YAML Front Matter 的标准标识符。如果是，它会在内容的第三个字符后(排除第一个&lt;code&gt;---&lt;/code&gt; )找到第二个 &lt;code&gt;---&lt;/code&gt;，从而确定 Front Matter 的结束位置。然后，它提取 &lt;code&gt;---&lt;/code&gt; 之间的部分作为 YAML 数据，并将其解析为字典。最后，它将 YAML Front Matter 部分提取出来，使用 &lt;code&gt;PyYAML&lt;/code&gt; 库的 &lt;code&gt;safe_load&lt;/code&gt; 函数将 &lt;code&gt;front_matter&lt;/code&gt; 部分解析为 Python 字典。&lt;code&gt;safe_load&lt;/code&gt; 是一个安全的解析方法，它能防止执行可能有害的 YAML 内容，&lt;code&gt;yaml.safe_load(front_matter)&lt;/code&gt; 返回解析后的字典和剩余的正文内容。如果没有找到有效的 Front Matter，函数会返回一个空字典和原始内容，功能实现函数如下&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import yaml

def parse_front_matter(content):
    &amp;quot;&amp;quot;&amp;quot;
    content参数为读取的markdown文件原始内容
    解析 YAML Front Matter，分离Front Matter与内容部分(body)
    &amp;quot;&amp;quot;&amp;quot;
    if content.startswith('---'):
        end_index = content.find('---', 3)
        if end_index != -1:
            front_matter = content[3:end_index]
            body = content[end_index + 3:]
            #返回front matter信息和内容
            return yaml.safe_load(front_matter), body 
    #没有front matter信息则返回空字典和内容
    return {}, content 
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;考虑内容部分的格式转换，转换成html格式进行渲染&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依赖&lt;code&gt;markdown&lt;/code&gt;库，使用&lt;code&gt;markdown.markdown()&lt;/code&gt; 函数，将 Markdown 格式的文本转换为 HTML。这个函数接受多个参数，其中第一个是要转换的 Markdown 内容（&lt;code&gt;md_content&lt;/code&gt;），第二个是一个扩展列表（&lt;code&gt;extensions=extensions&lt;/code&gt;），用来启用特定的 Markdown 扩展。&lt;code&gt;CodeHiliteExtension&lt;/code&gt;扩展为代码块提供语法高亮。&lt;code&gt;FencedCodeExtension&lt;/code&gt;扩展支持使用围栏代码块语法（即用 ````` 包裹的代码块）。&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;import markdown
from markdown.extensions.codehilite import CodeHiliteExtension
from markdown.extensions.fenced_code import FencedCodeExtension

def convert_markdown_to_html(md_content):
    &amp;quot;&amp;quot;&amp;quot;将 Markdown 内容转换为 HTML&amp;quot;&amp;quot;&amp;quot;
    extensions = [CodeHiliteExtension(), FencedCodeExtension()]
    return markdown.markdown(md_content, extensions=extensions)
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;遍历文档目录，收集文章信息数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有了前面的两步，现在可以成功的将一个markdown文档里的数据进行拆分了，这样就可以将目录内的所有文档的数据提取出来组合成一个文档数据的列表，方便后续其他渲染函数使用，这里我组合了三种数据，posts收集文章信息数据(包括标题、其它元素据、文章内容)，tags收集元数据里的标签信息，categories收集分类信息，实现函数如下:&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;# 配置目录
POSTS_DIR = 'posts'
OUTPUT_DIR = 'output'

def get_by_metadata_process_posts():
    '''
    获取文章信息
    包括文章、标签、分类
    '''
    if not os.path.exists(OUTPUT_DIR):
        os.makedirs(OUTPUT_DIR)

    tags = {}
    categories = {}
    posts = []

    for root, dirs, files in os.walk(POSTS_DIR):
        for filename in files:
            if filename.endswith('.md'):
                file_path = os.path.join(root, filename)
                with open(file_path, 'r', encoding='utf-8') as file:
                    content = file.read()
                    metadata, body = parse_front_matter(content)
                    title = metadata.get('title', filename.replace('.md', ''))
                    html_content = convert_markdown_to_html(body)

                    # 收集文章信息
                    posts.append({'title': title, 'html_content': html_content, 'metadata': metadata})

                    # 更新标签
                    for tag in metadata.get('tags', []):
                        tags.setdefault(tag, []).append(title)

                    # 获取子目录作为分类
                    categories.setdefault(metadata.get('category', '未分类'), []).append(title)
                    #category = os.path.basename(root)  # 获取当前目录的名称
                    #categories.setdefault(category, []).append(title)

                    # 获取一级子目录作为分类
                    # relative_path = os.path.relpath(root, POSTS_DIR)  # 获取相对路径
                    # category = relative_path.split(os.sep)[0]  # 获取一级子目录
                    # categories.setdefault(category, []).append(title)
    # 生成 search.xml 文件,后续搜索功能需要使用
    generate_search_xml(posts)
    return posts, tags, categories
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;使用jinja2模板渲染生成html文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;渲染生成html文件之前，创建一个html模板,这里介绍首页的生成，新建一个templates目录存放所有的模板文件，template/index.html为首页模板文件,下面是我的首页模板文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-html"&gt;{% extends &amp;quot;base.html&amp;quot; %}

{% block title %}各自花开{% endblock %}


{% block banner%}
    &amp;lt;div class=&amp;quot;banner container banner-content&amp;quot;&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;div class=&amp;quot;photo-wall&amp;quot;&amp;gt;
                &amp;lt;div class=&amp;quot;photo-item&amp;quot;&amp;gt;
                    &amp;lt;span class=&amp;quot;photo-text&amp;quot;&amp;gt;各&amp;lt;/span&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div class=&amp;quot;photo-item&amp;quot;&amp;gt;
                    &amp;lt;span class=&amp;quot;photo-text&amp;quot;&amp;gt;自&amp;lt;/span&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div class=&amp;quot;photo-item&amp;quot;&amp;gt;
                    &amp;lt;span class=&amp;quot;photo-text&amp;quot;&amp;gt;花&amp;lt;/span&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;div class=&amp;quot;photo-item&amp;quot;&amp;gt;
                    &amp;lt;span class=&amp;quot;photo-text&amp;quot;&amp;gt;开&amp;lt;/span&amp;gt;
                &amp;lt;/div&amp;gt;
                &amp;lt;!-- Add more photo items as needed --&amp;gt;
            &amp;lt;/div&amp;gt;

        &amp;lt;/div&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;h1&amp;gt;凡事需三思,谨言慎行&amp;lt;/h1&amp;gt;
            &amp;lt;p&amp;gt;对世界有看法，对生活有态度，让花成花，让树成树，认可任何一种观点和习惯&amp;lt;/p&amp;gt;
        &amp;lt;/div&amp;gt;

    &amp;lt;/div&amp;gt;
{% endblock %}

{% block content %}
    &amp;lt;div class=&amp;quot;content&amp;quot;&amp;gt;
        &amp;lt;h3&amp;gt;最近更新 &amp;lt;span class=&amp;quot;new-icon&amp;quot;&amp;gt;New&amp;lt;/span&amp;gt;&amp;lt;/h3&amp;gt;
        &amp;lt;ul&amp;gt;
        {% if contents %}
            &amp;lt;div class=&amp;quot;content-list&amp;quot;&amp;gt;
                {% for content in contents %}
                    &amp;lt;span&amp;gt;
                        &amp;lt;img src=&amp;quot;../static/img/文字_text.png&amp;quot; class=&amp;quot;content-icon&amp;quot;&amp;gt;
                        &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;article/{{ content[&amp;quot;title&amp;quot;] }}.html&amp;quot;&amp;gt;{{ content[&amp;quot;title&amp;quot;] }}&amp;lt;/a&amp;gt; {{ content[&amp;quot;metadata&amp;quot;][&amp;quot;date&amp;quot;] }}&amp;lt;/li&amp;gt;
                    &amp;lt;/span&amp;gt;
                {% endfor %}
            &amp;lt;/div&amp;gt;
        {% endif %}

        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;
{% endblock %}


{% block sidebar %}
    &amp;lt;aside class=&amp;quot;sidebar&amp;quot;&amp;gt;

        &amp;lt;!-- 作者介绍 --&amp;gt;
    &amp;lt;div class=&amp;quot;sidebar-section author-intro&amp;quot;&amp;gt;
        &amp;lt;h3&amp;gt;关于作者&amp;lt;/h3&amp;gt;
        &amp;lt;div class=&amp;quot;author-info&amp;quot;&amp;gt;
            &amp;lt;p&amp;gt;一个内心有想法但却随性，期望改变但最终随遇而安的矛盾存在&amp;lt;/p&amp;gt;
            &amp;lt;p&amp;gt;博客文章同步更新微信公众号【各自花开】，期待您的关注~&amp;lt;/p&amp;gt;
            &amp;lt;img src=&amp;quot;../static/img/qrcode_1280.jpg&amp;quot; alt=&amp;quot;作者头像&amp;quot; class=&amp;quot;author-avatar&amp;quot;&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;!-- 热门标签 --&amp;gt;
    &amp;lt;div class=&amp;quot;sidebar-section tags&amp;quot;&amp;gt;
        &amp;lt;h3&amp;gt;热门标签&amp;lt;/h3&amp;gt;
        &amp;lt;ul class=&amp;quot;tag-list&amp;quot;&amp;gt;
            {% for tag in tags %}
                &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;./tags/{{ tag }}.html&amp;quot;&amp;gt;{{ tag }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            {% endfor %}
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;!-- 推荐文章 --&amp;gt;
    &amp;lt;div class=&amp;quot;sidebar-section recommended&amp;quot;&amp;gt;
        &amp;lt;h3&amp;gt;分类&amp;lt;/h3&amp;gt;
        &amp;lt;ul class=&amp;quot;recommended-list&amp;quot;&amp;gt;
            {% for category in categories %}
                &amp;lt;li&amp;gt;&amp;lt;a href=&amp;quot;./categories/{{ category }}.html&amp;quot;&amp;gt;{{ category }}&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
            {% endfor %}
        &amp;lt;/ul&amp;gt;
    &amp;lt;/div&amp;gt;

&amp;lt;/aside&amp;gt;

{% endblock %}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首页渲染函数，执行该函数会在OUTPUT_DIR目录下生成一个首页index.html文件&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-python"&gt;# 设置模板文件夹路径
template_dir = 'templates'
# 创建一个模板加载器
loader = FileSystemLoader(template_dir)
# 创建 Jinja2 环境
env = Environment(loader=loader)

def generate_index_page(posts,tags=None,categories=None):
    &amp;quot;&amp;quot;&amp;quot;生成首页&amp;quot;&amp;quot;&amp;quot;
    # 加载模板
    index_template = env.get_template('index.html')

    # 默认值为空列表
    if tags is None:
        tags = []

    if categories is None:
        categories = []

    # posts[:5] 显示5条
    html = index_template.render(contents=posts,tags=tags, categories=categories)
    output_file = os.path.join(OUTPUT_DIR, 'index.html')
    with open(output_file, 'w', encoding='utf-8') as file:
        file.write(html)
    print(f&amp;quot;Generated {output_file}&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其它页面比如文章页、标签页等参照首页的生成方式去渲染，当所有页面都渲染生成之后，就可以部署了，这样我的博客就建成了，最后给大家展示一下我自己写的博客吧&lt;/p&gt;
&lt;p&gt;&lt;img alt="Blog_Demo" src="http://nas.izcat.com:9001/webpic/Blog_Demo.gif" /&gt;&lt;/p&gt;</html_content></item><item><title>Typora结合PicGo使用minio插件搭建个人图床上传图片</title><description>&lt;p&gt;&lt;strong&gt;引言&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;我们在平时写文章或者博客的时候，经常使用markdown格式来编写，而Typora就是一款Markdown编辑器被大家使用，但是我们在写作过程当中经常需要插入图片，由于图片保存在本地，插入到文章之后引用的也是本地地址导致我们写好的文章发布出去的时候图片无法被加载。所以我们需要一个专门的地方来存放这些图片，而这个地方就叫图床，像微信公众号</description><html_content>&lt;p&gt;&lt;strong&gt;引言&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;我们在平时写文章或者博客的时候，经常使用markdown格式来编写，而Typora就是一款Markdown编辑器被大家使用，但是我们在写作过程当中经常需要插入图片，由于图片保存在本地，插入到文章之后引用的也是本地地址导致我们写好的文章发布出去的时候图片无法被加载。所以我们需要一个专门的地方来存放这些图片，而这个地方就叫图床，像微信公众号等大厂家的写作平台都自带图床，写作的时候我们把图片上传之后在插入到平台的写作编辑器里即可，对于我们本地写作的话也可以实现这样的功能，就是需要自建图床,本文我们介绍使用minio来搭建一个图床，然后借助PicGO这款软件，我们在Typora里面配置PicGo之后，当我们插入图片之后，会自动把图片上传到minio图床内，并将Typora编辑器内的图片地址修改成图床图片的访问地址，这样当我们文章写好发布出去的时候就不用担心图片无法加载了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;涉及的软件&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Typora&lt;/li&gt;
&lt;li&gt;minio&lt;/li&gt;
&lt;li&gt;PicGO&lt;/li&gt;
&lt;li&gt;NodeJs（PicGo安装需要）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;开始动起来吧&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一、使用minio搭建对象存储&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 什么是minio&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;minio是一个高性能的对象存储服务，支持分布式存储，具有高扩展性、高可用性，部署方式多样，部署简单，官方有详细的&lt;a href="https://min.io/docs/minio/container/index.html"&gt;安装文档&lt;/a&gt;可参考&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 使用docker部署minio&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;minio的安装方式很多，我们这里选择使用docker部署&lt;/p&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-bash"&gt;docker run \
-p 9000:9000 \
-p 9001:9001 \
--name minio \
-d --restart=always \
-e &amp;quot;MINIO_ROOT_USER=admin&amp;quot; \
-e &amp;quot;MINIO_ROOT_PASSWORD=passwd&amp;quot; \
-v /volume1/docker/minio/data:/data \
-v /volume1/docker/minio/config:/root/.minio \
minio/minio server /data --console-address &amp;quot;:9001&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;3. 登录minio服务web控制台创建bucket以及accessKey和secretKey&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建bucket并配置匿名访问权限为&lt;code&gt;readonly&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;点击&lt;code&gt;Buckets&lt;/code&gt;-&amp;gt;点击右上角的&lt;code&gt;Create Buckes&lt;/code&gt; -&amp;gt;然后在&lt;code&gt;Create Bucket&lt;/code&gt;页面输入&lt;code&gt;Bucket Name&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Snipaste_2024-10-30_15-59-43" src="http://nas.izcat.com:9001/webpic/Snipaste_2024-10-30_15-59-43_repeat_1730275414950__230387.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Snipaste_2024-10-30_16-00-34" src="http://nas.izcat.com:9001/webpic/Snipaste_2024-10-30_16-00-34_repeat_1730275405309__649124.png" /&gt;&lt;/p&gt;
&lt;p&gt;设置创建的Bucket的匿名访问为&lt;code&gt;radonly&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Snipaste_2024-10-30_16-02-05" src="http://nas.izcat.com:9001/webpic/Snipaste_2024-10-30_16-02-05_repeat_1730275373013__439525.png" /&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建&lt;code&gt;accessKey&lt;/code&gt;和&lt;code&gt;secretKey&lt;/code&gt;并记录下来，在后面&lt;code&gt;PicGo&lt;/code&gt;配置插件minio插件时需要使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="Snipaste_2024-10-30_16-17-01" src="http://nas.izcat.com:9001/webpic/Snipaste_2024-10-30_16-17-01_repeat_1730276261677__986201.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、安装PicGo，配置minio插件&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. PicGo介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PicGO是一个用于快速上传图片并获取图片URL链接的工具，&lt;a href="https://molunerfinn.com/PicGo/"&gt;PicGO官网&lt;/a&gt; 下载安装即可，需要注意的是这款软件的安装依赖&lt;code&gt;Nodejs&lt;/code&gt;,所以需要先安装NodeJs环境。&lt;/p&gt;
&lt;p&gt;软件安装比较简单，这里就不介绍&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. PicGo安装配置minio插件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;minio插件全称&lt;code&gt;picgo-plugin-minio&lt;/code&gt;，可以在它的&lt;a href="https://github.com/Herbertzz/picgo-plugin-minio"&gt;官网&lt;/a&gt;查看更多信息，安装好&lt;code&gt;PicGo&lt;/code&gt;软件之后在软件的&lt;code&gt;插件设置&lt;/code&gt;界面输入关键字&lt;code&gt;minio&lt;/code&gt;搜索插件，然后点击安装即可，安装完成会显示已安装，然后在&lt;code&gt;图床设置&lt;/code&gt; 选项里面可以看到多出一个&lt;code&gt;minio 图床&lt;/code&gt;选项&lt;/p&gt;
&lt;p&gt;&lt;img alt="Snipaste_2024-10-30_16-30-44" src="http://nas.izcat.com:9001/webpic/Snipaste_2024-10-30_16-30-44_repeat_1730277107674__930034.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="Snipaste_2024-10-30_16-32-37" src="http://nas.izcat.com:9001/webpic/Snipaste_2024-10-30_16-32-37_repeat_1730277196695__724948.png" /&gt;&lt;/p&gt;
&lt;p&gt;PicGo配置minio图床，具体的使用以及参数说明可以参考&lt;a href="https://github.com/Herbertzz/picgo-plugin-minio"&gt;picgo-plugin-minio&lt;/a&gt;插件的官方说明&lt;/p&gt;
&lt;p&gt;&lt;img alt="Snipaste_2024-10-30_16-35-51" src="http://nas.izcat.com:9001/webpic/Snipaste_2024-10-30_16-35-51_repeat_1730277419862__276891.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、安装Typora并配置PicGo自动上传&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Typora的安装没有什么好说明的，需要注意的是这款软件是以前是不收费的，后来改成收费软件了，觉得好用可以支持一下正版，这里主要说说Typora如何配置PicGo来实现图片自动上传的&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;文件&lt;/code&gt;-&amp;gt;&lt;code&gt;偏好设置&lt;/code&gt;-&amp;gt;&lt;code&gt;图像&lt;/code&gt;进行设置&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;插入图片时&lt;/code&gt;选项设置成上传图片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;上传服务设定&lt;/code&gt;选项进行picgo服务相关设置&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt="" src="http://nas.izcat.com:9001/webpic/Snipaste_2024-10-30_17-01-56_repeat_1730278931812__477406.png" /&gt;&lt;/p&gt;
&lt;p&gt;配置完成可以点击&lt;code&gt;验证图片上传选项&lt;/code&gt;进行验证&lt;/p&gt;
&lt;p&gt;&lt;img alt="Snipaste_2024-10-30_16-48-40" src="http://nas.izcat.com:9001/webpic/Snipaste_2024-10-30_16-48-40_repeat_1730278609242__941936.png" /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;回顾整个配置过程并不复杂，需要注意PicGo安装minio插件的时候，我开始点击安装很多次都安装不上，最后怀疑是个人网络问题导致，开了科学上网之后安装成功，碰到类似问题的可以参考处理一下。&lt;/p&gt;</html_content></item><item><title>使用ddns-go实现家庭网络ddns域名动态解析</title><description>&lt;p&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多家庭都会有nas设备来存放个人资料、剧集。或者小型miniPc来当服务器使用的情况，我前段时间就从某鱼搞了一台二手的N5105来当个人服务器,缺点是放在家里内网外部是无法直接访问到，当然想要实现外部访问的话，方案肯定是有的，如今实现这个需求使用较多的方案个人认为就是内网穿透和域名动态解析(ddns)了，使用内网穿透需要借助公网服务器,</description><html_content>&lt;p&gt;&lt;strong&gt;引言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;很多家庭都会有nas设备来存放个人资料、剧集。或者小型miniPc来当服务器使用的情况，我前段时间就从某鱼搞了一台二手的N5105来当个人服务器,缺点是放在家里内网外部是无法直接访问到，当然想要实现外部访问的话，方案肯定是有的，如今实现这个需求使用较多的方案个人认为就是内网穿透和域名动态解析(ddns)了，使用内网穿透需要借助公网服务器,也就是需要花钱采购公网服务器，这个是需要投入资金成本的，而今天给大家介绍的是域名动态解析的方案，这种方案不需要投入资金成本，只需要更改家庭带宽的拨号方式为桥架模式即可，以我家使用的中国电信为例，默认使用的是路由模式，宽带安装好之后即可使用，不需要路由器拨号，是没有公网IP的，电话客服让其更改为桥接模式并开通公网IP，然后通过路由器拨号上网的方式即可获取公网IP，这样使用ddns的前提条件就满足啦。其实很多路由器都有ddns的功能，但是很多都是自带需要注册第三方服务使用它们提供的子域名的那些，我不太喜欢使用，所以打算自己部署&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;不是改成了桥接模式就一定会有公网IP的，本人刚开通的时候确实有公网IP，使用一段时间之后的某一天突然无法使用了。排查了好久，发现实际查询的公网IP和PPOE拨号获取的IP地址不一样，让电信排查之后，告知没有开通公网IP。也是很无语，估计是被他们偷偷的关闭掉了，让其再次开通后一切又正常了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;方案实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过一翻资料查阅，发现&lt;code&gt;ddns-go&lt;/code&gt;挺不错，支持的域名服务商很多，部署支持Mac、Windows、Linux系统，支持ARM、x86架构。部署方便，还支持docker。我有一台黑群晖设备放在家里的，平时在公司也有访问它的需求，正好借助群晖的docker容器的方式部署。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;镜像地址&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;https://hub.docker.com/r/jeessy/ddns-go&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;部署&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在镜像地址页有详细的部署方式，我选的是不使用&lt;code&gt;host模式&lt;/code&gt;的运行方式,根据自己的需求自行选择即可&lt;/p&gt;
&lt;p&gt;```bash
   docker run -d --name ddns-go --restart=always -p 9876:9876 -v /volume1/docker/ddns-go:/root jeessy/ddns-go&lt;/p&gt;
&lt;p&gt;```&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置aliddns&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;配置aliddns也很方便，部署完成之后，在浏览器打开ddns-go管理界面进行配置。登陆时需要输入账号密码，首次输入时随意，会自动创建，后续使用这个账号密码登录&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!note]&lt;/p&gt;
&lt;p&gt;提前登录阿里云准备好&lt;code&gt;AccessKey ID&lt;/code&gt;和&lt;code&gt;AccessKey Secret&lt;/code&gt;,配置时需要用到&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;登录之后的界面如下图，根据自己的信息填入之后保存&lt;/p&gt;
&lt;p&gt;&lt;img alt="ddns-go-01" src="http://nas.izcat.com:9001/webpic/ddns-go-01.png" /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;验证&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一切配置完成之后，查看阿里云的域名解析，多了一条对应的域名解析记录。解析的IP地址与我的带宽出口IP也是一致的，然后我在路由器里添加了端口映射，在外部使用&lt;code&gt;telnet&lt;/code&gt;检查了一下端口是通的，对应的服务也能够访问到。&lt;/p&gt;</html_content></item><item><title>切换到python虚拟环境时报错'无法加载文件Activate.ps1，因为在此系统上禁止运行脚本'解决办法</title><description>&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在windows的PowerShell或者Pycharm切换到python虚拟环境时报错“无法加载文件.\myenv\Scripts\Activate.ps1，因为在此系统上禁止运行脚本”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理办法&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;管理员身份运行PowerShell&lt;/p&gt;
&lt;/li&gt;</description><html_content>&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在windows的PowerShell或者Pycharm切换到python虚拟环境时报错“无法加载文件.\myenv\Scripts\Activate.ps1，因为在此系统上禁止运行脚本”&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理办法&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;管理员身份运行PowerShell&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在PowerShell里执行通过执行 &lt;code&gt;Get-ExecutionPolicy&lt;/code&gt; 查看当前策略和执行&lt;code&gt;Set-ExecutionPolicy Bypass&lt;/code&gt;修改当前策略为&lt;code&gt;Bypass&lt;/code&gt;即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="codehilite"&gt;&lt;code class="language-powershell"&gt;PS C:\Windows\system32&amp;gt; Get-ExecutionPolicy
Restricted
PS C:\Windows\system32&amp;gt; Set-ExecutionPolicy Bypass

执行策略更改
执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170
中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?
[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): y
PS C:\Windows\system32&amp;gt; Get-ExecutionPolicy
Bypass
PS C:\Windows\system32&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</html_content></item></search>